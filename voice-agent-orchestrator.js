#!/usr/bin/env node

/**
 * VOICE-AGENT ORCHESTRATION SYSTEM
 * 
 * Integrates voice interaction with agent orchestration for seamless delegation.
 * Users can speak commands that are intelligently routed to appropriate AI agents.
 * 
 * Features:
 * - Natural language voice processing
 * - Intelligent agent selection and routing
 * - Context-aware command interpretation
 * - Real-time voice feedback and status
 * - Cross-device voice synchronization
 * - Agent capability matching
 * - Voice command history and learning
 */

const EventEmitter = require('events');
const WebSocket = require('ws');
const crypto = require('crypto');
const fetch = require('node-fetch');

class VoiceAgentOrchestrator extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.wsPort = options.wsPort || 3336;
        this.agentBridgeUrl = options.agentBridgeUrl || 'http://localhost:9999';
        this.localAIUrl = options.localAIUrl || 'http://localhost:11434';
        
        // Voice processing configuration
        this.voiceConfig = {
            languages: ['en-US', 'en-GB'],
            confidenceThreshold: 0.7,
            maxSilenceDuration: 2000, // 2 seconds
            commandTimeout: 30000,    // 30 seconds
            enableNLP: true,
            enableContext: true
        };
        
        // Agent orchestration
        this.availableAgents = new Map();
        this.agentCapabilities = new Map();
        this.activeAgentSessions = new Map();
        this.agentPerformanceMetrics = new Map();
        
        // Voice command processing
        this.commandPatterns = new Map();
        this.commandHistory = new Map(); // sessionId -> commands
        this.contextMemory = new Map();  // sessionId -> context
        this.learningData = new Map();   // command -> success rate
        
        // WebSocket connections
        this.voiceConnections = new Map();
        this.deviceSessions = new Map();
        
        // Natural Language Processing
        this.nlpCache = new Map();
        this.intentClassifier = null;
        this.entityExtractor = null;
        
        console.log('🎤 Voice-Agent Orchestration System initialized');
        this.initialize();
    }
    
    async initialize() {
        await this.setupCommandPatterns();
        await this.discoverAgents();
        await this.startWebSocketServer();
        await this.initializeNLP();
        
        // Start periodic agent health checks
        setInterval(() => {
            this.checkAgentHealth();
        }, 30000);
        
        console.log('✅ Voice-Agent Orchestrator ready');
    }
    
    async setupCommandPatterns() {
        // Define voice command patterns and their agent mappings
        this.commandPatterns.set('document_processing', {
            patterns: [
                /process.*document/i,
                /analyze.*file/i,
                /convert.*pdf/i,
                /extract.*text/i,
                /generate.*from.*document/i
            ],
            agents: ['document-agent', 'ai-parser'],
            requiredCapabilities: ['document-processing', 'text-extraction'],
            priority: 'high',
            context: ['file-upload', 'document-analysis']
        });
        
        this.commandPatterns.set('code_generation', {
            patterns: [
                /generate.*code/i,
                /create.*app/i,
                /build.*mvp/i,
                /write.*function/i,
                /develop.*feature/i
            ],
            agents: ['code-generator', 'mvp-builder', 'ai-developer'],
            requiredCapabilities: ['code-generation', 'software-development'],
            priority: 'high',
            context: ['development', 'programming']
        });
        
        this.commandPatterns.set('git_operations', {
            patterns: [
                /commit.*changes/i,
                /push.*github/i,
                /create.*branch/i,
                /merge.*pull.*request/i,
                /git.*status/i
            ],\n            agents: ['git-agent', 'version-control'],\n            requiredCapabilities: ['git-operations', 'version-control'],\n            priority: 'medium',\n            context: ['git', 'version-control']\n        });\n        \n        this.commandPatterns.set('system_status', {\n            patterns: [\n                /show.*status/i,\n                /what.*happening/i,\n                /agent.*status/i,\n                /system.*health/i,\n                /check.*agents/i\n            ],\n            agents: ['system-monitor', 'health-checker'],\n            requiredCapabilities: ['system-monitoring', 'health-check'],\n            priority: 'low',\n            context: ['monitoring', 'status']\n        });\n        \n        this.commandPatterns.set('canvas_interaction', {\n            patterns: [\n                /draw.*canvas/i,\n                /create.*design/i,\n                /edit.*visual/i,\n                /sync.*canvas/i,\n                /share.*screen/i\n            ],\n            agents: ['canvas-agent', 'design-assistant'],\n            requiredCapabilities: ['canvas-manipulation', 'visual-design'],\n            priority: 'medium',\n            context: ['canvas', 'design', 'collaboration']\n        });\n        \n        this.commandPatterns.set('ai_conversation', {\n            patterns: [\n                /ask.*ai/i,\n                /chat.*with/i,\n                /question.*about/i,\n                /explain.*how/i,\n                /help.*me.*with/i\n            ],\n            agents: ['conversation-agent', 'ai-assistant'],\n            requiredCapabilities: ['natural-language', 'conversation'],\n            priority: 'medium',\n            context: ['conversation', 'help', 'assistance']\n        });\n        \n        console.log(`📋 ${this.commandPatterns.size} command patterns loaded`);\n    }\n    \n    async discoverAgents() {\n        console.log('🤖 Discovering available agents...');\n        \n        try {\n            // Query agent bridge for available agents\n            const response = await fetch(`${this.agentBridgeUrl}/api/agents/network/discover`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ includeCapabilities: true })\n            });\n            \n            if (response.ok) {\n                const agentsData = await response.json();\n                \n                agentsData.agents?.forEach(agent => {\n                    this.availableAgents.set(agent.id, {\n                        ...agent,\n                        lastSeen: new Date(),\n                        status: 'available',\n                        activeCommands: 0,\n                        averageResponseTime: 0\n                    });\n                    \n                    this.agentCapabilities.set(agent.id, agent.capabilities || []);\n                    \n                    console.log(`   🤖 Found agent: ${agent.id} (${agent.capabilities?.join(', ')})`);\n                });\n            }\n            \n        } catch (error) {\n            console.warn('⚠️  Agent discovery failed, using fallback agents:', error.message);\n            \n            // Fallback agent definitions\n            const fallbackAgents = [\n                {\n                    id: 'document-agent',\n                    name: 'Document Processor',\n                    capabilities: ['document-processing', 'text-extraction', 'pdf-conversion'],\n                    endpoint: '/api/agents/document'\n                },\n                {\n                    id: 'code-generator',\n                    name: 'Code Generator',\n                    capabilities: ['code-generation', 'software-development', 'mvp-creation'],\n                    endpoint: '/api/agents/code'\n                },\n                {\n                    id: 'git-agent',\n                    name: 'Git Operations',\n                    capabilities: ['git-operations', 'version-control', 'repository-management'],\n                    endpoint: '/api/agents/git'\n                }\n            ];\n            \n            fallbackAgents.forEach(agent => {\n                this.availableAgents.set(agent.id, {\n                    ...agent,\n                    lastSeen: new Date(),\n                    status: 'available',\n                    activeCommands: 0,\n                    averageResponseTime: 1000\n                });\n                \n                this.agentCapabilities.set(agent.id, agent.capabilities);\n            });\n        }\n        \n        console.log(`✅ ${this.availableAgents.size} agents discovered`);\n    }\n    \n    async startWebSocketServer() {\n        this.wss = new WebSocket.Server({ \n            port: this.wsPort,\n            perMessageDeflate: true\n        });\n        \n        this.wss.on('connection', (ws, req) => {\n            this.handleVoiceConnection(ws, req);\n        });\n        \n        console.log(`🎤 Voice orchestrator listening on port ${this.wsPort}`);\n    }\n    \n    handleVoiceConnection(ws, req) {\n        const deviceId = req.headers['x-device-id'] || crypto.randomUUID();\n        const sessionId = req.headers['x-session-id'] || crypto.randomUUID();\n        const deviceType = req.headers['x-device-type'] || 'unknown';\n        \n        console.log(`🎤 Voice device connected: ${deviceType} (${deviceId})`);\n        \n        const connection = {\n            ws,\n            deviceId,\n            sessionId,\n            deviceType,\n            connectionId: crypto.randomUUID(),\n            connectedAt: new Date(),\n            lastActivity: new Date(),\n            activeCommands: new Set(),\n            voiceHistory: []\n        };\n        \n        this.voiceConnections.set(connection.connectionId, connection);\n        this.deviceSessions.set(sessionId, connection);\n        \n        // Initialize command history and context for this session\n        if (!this.commandHistory.has(sessionId)) {\n            this.commandHistory.set(sessionId, []);\n            this.contextMemory.set(sessionId, {\n                currentContext: null,\n                previousCommands: [],\n                userPreferences: {},\n                activeAgents: new Set()\n            });\n        }\n        \n        ws.on('message', (data) => {\n            this.handleVoiceMessage(connection, data);\n        });\n        \n        ws.on('close', () => {\n            this.handleVoiceDisconnection(connection);\n        });\n        \n        // Send welcome and available commands\n        this.sendVoiceWelcome(connection);\n    }\n    \n    async handleVoiceMessage(connection, data) {\n        try {\n            const message = JSON.parse(data.toString());\n            const { type, sessionId } = message;\n            \n            connection.lastActivity = new Date();\n            \n            switch (type) {\n                case 'voice-command':\n                    await this.processVoiceCommand(connection, message);\n                    break;\n                case 'voice-stream':\n                    await this.processVoiceStream(connection, message);\n                    break;\n                case 'command-confirmation':\n                    await this.handleCommandConfirmation(connection, message);\n                    break;\n                case 'agent-feedback':\n                    await this.handleAgentFeedback(connection, message);\n                    break;\n                case 'context-update':\n                    await this.updateContext(connection, message);\n                    break;\n                default:\n                    console.warn(`Unknown voice message type: ${type}`);\n            }\n            \n        } catch (error) {\n            console.error('Voice message handling error:', error);\n            this.sendVoiceError(connection, 'Failed to process voice message');\n        }\n    }\n    \n    async processVoiceCommand(connection, message) {\n        const { command, confidence, metadata } = message;\n        const { sessionId } = connection;\n        \n        console.log(`🎤 Processing voice command: \"${command}\" (confidence: ${confidence})`);\n        \n        // Check confidence threshold\n        if (confidence < this.voiceConfig.confidenceThreshold) {\n            this.sendVoiceResponse(connection, {\n                type: 'clarification-needed',\n                message: `I didn't quite catch that. Could you repeat the command?`,\n                confidence: confidence\n            });\n            return;\n        }\n        \n        // Add to history\n        this.addToCommandHistory(sessionId, command, confidence);\n        \n        // Process with NLP and intent classification\n        const intent = await this.classifyIntent(command, connection);\n        const entities = await this.extractEntities(command);\n        \n        // Find matching command pattern\n        const commandMatch = this.findCommandMatch(command, intent);\n        \n        if (!commandMatch) {\n            this.sendVoiceResponse(connection, {\n                type: 'unknown-command',\n                message: `I'm not sure how to help with that. Try commands like \"process document\", \"show agent status\", or \"commit changes\".`,\n                availableCommands: this.getAvailableCommands()\n            });\n            return;\n        }\n        \n        // Select best agent for this command\n        const selectedAgent = await this.selectAgent(commandMatch, entities, connection);\n        \n        if (!selectedAgent) {\n            this.sendVoiceResponse(connection, {\n                type: 'no-agent-available',\n                message: `No agents are available to handle \"${command}\". Please try again later.`,\n                requiredCapabilities: commandMatch.requiredCapabilities\n            });\n            return;\n        }\n        \n        // Execute command through selected agent\n        await this.executeCommand(connection, command, selectedAgent, entities, commandMatch);\n    }\n    \n    async classifyIntent(command, connection) {\n        // Use cached result if available\n        const cacheKey = command.toLowerCase().trim();\n        if (this.nlpCache.has(cacheKey)) {\n            return this.nlpCache.get(cacheKey);\n        }\n        \n        try {\n            // Use local AI for intent classification\n            const response = await fetch(`${this.localAIUrl}/api/generate`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    model: 'mistral',\n                    prompt: `Classify the intent of this voice command into one of these categories:\n- document_processing\n- code_generation\n- git_operations\n- system_status\n- canvas_interaction\n- ai_conversation\n\nCommand: \"${command}\"\n\nIntent:`,\n                    stream: false,\n                    options: {\n                        temperature: 0.1,\n                        top_p: 0.9\n                    }\n                })\n            });\n            \n            if (response.ok) {\n                const data = await response.json();\n                const intent = data.response?.trim().toLowerCase();\n                \n                // Cache the result\n                this.nlpCache.set(cacheKey, intent);\n                \n                return intent;\n            }\n            \n        } catch (error) {\n            console.warn('Intent classification failed:', error.message);\n        }\n        \n        // Fallback to pattern matching\n        return this.fallbackIntentClassification(command);\n    }\n    \n    fallbackIntentClassification(command) {\n        const lowerCommand = command.toLowerCase();\n        \n        for (const [intent, config] of this.commandPatterns.entries()) {\n            for (const pattern of config.patterns) {\n                if (pattern.test(lowerCommand)) {\n                    return intent;\n                }\n            }\n        }\n        \n        return 'ai_conversation'; // Default fallback\n    }\n    \n    async extractEntities(command) {\n        try {\n            // Use local AI for entity extraction\n            const response = await fetch(`${this.localAIUrl}/api/generate`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    model: 'mistral',\n                    prompt: `Extract key entities from this command. Return as JSON with keys: file_type, action, target, parameters.\n\nCommand: \"${command}\"\n\nEntities:`,\n                    stream: false,\n                    options: {\n                        temperature: 0.1\n                    }\n                })\n            });\n            \n            if (response.ok) {\n                const data = await response.json();\n                try {\n                    return JSON.parse(data.response);\n                } catch {\n                    // Fallback to simple entity extraction\n                    return this.simpleEntityExtraction(command);\n                }\n            }\n            \n        } catch (error) {\n            console.warn('Entity extraction failed:', error.message);\n        }\n        \n        return this.simpleEntityExtraction(command);\n    }\n    \n    simpleEntityExtraction(command) {\n        const entities = {};\n        \n        // Extract file types\n        const fileTypes = ['pdf', 'doc', 'txt', 'md', 'html', 'json', 'csv'];\n        for (const type of fileTypes) {\n            if (command.toLowerCase().includes(type)) {\n                entities.file_type = type;\n                break;\n            }\n        }\n        \n        // Extract actions\n        const actions = ['create', 'generate', 'process', 'analyze', 'convert', 'show', 'commit', 'push'];\n        for (const action of actions) {\n            if (command.toLowerCase().includes(action)) {\n                entities.action = action;\n                break;\n            }\n        }\n        \n        return entities;\n    }\n    \n    findCommandMatch(command, intent) {\n        // First try to match by classified intent\n        if (intent && this.commandPatterns.has(intent)) {\n            return {\n                intent,\n                config: this.commandPatterns.get(intent),\n                matchType: 'intent'\n            };\n        }\n        \n        // Fallback to pattern matching\n        const lowerCommand = command.toLowerCase();\n        \n        for (const [patternIntent, config] of this.commandPatterns.entries()) {\n            for (const pattern of config.patterns) {\n                if (pattern.test(lowerCommand)) {\n                    return {\n                        intent: patternIntent,\n                        config,\n                        matchType: 'pattern'\n                    };\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    async selectAgent(commandMatch, entities, connection) {\n        const { config } = commandMatch;\n        const { sessionId } = connection;\n        \n        // Get context for better agent selection\n        const context = this.contextMemory.get(sessionId);\n        \n        // Filter agents by required capabilities\n        const capableAgents = [];\n        \n        for (const agentId of config.agents) {\n            const agent = this.availableAgents.get(agentId);\n            if (!agent || agent.status !== 'available') continue;\n            \n            const agentCapabilities = this.agentCapabilities.get(agentId) || [];\n            const hasRequiredCapabilities = config.requiredCapabilities.every(\n                cap => agentCapabilities.includes(cap)\n            );\n            \n            if (hasRequiredCapabilities) {\n                capableAgents.push({\n                    ...agent,\n                    capabilityMatch: this.calculateCapabilityMatch(agentCapabilities, config.requiredCapabilities),\n                    loadScore: this.calculateLoadScore(agent),\n                    contextScore: this.calculateContextScore(agent, context)\n                });\n            }\n        }\n        \n        if (capableAgents.length === 0) {\n            return null;\n        }\n        \n        // Sort by combined score (capability match + load + context)\n        capableAgents.sort((a, b) => {\n            const scoreA = a.capabilityMatch * 0.5 + a.loadScore * 0.3 + a.contextScore * 0.2;\n            const scoreB = b.capabilityMatch * 0.5 + b.loadScore * 0.3 + b.contextScore * 0.2;\n            return scoreB - scoreA;\n        });\n        \n        return capableAgents[0];\n    }\n    \n    calculateCapabilityMatch(agentCapabilities, requiredCapabilities) {\n        const matchCount = requiredCapabilities.filter(cap => \n            agentCapabilities.includes(cap)\n        ).length;\n        \n        return matchCount / requiredCapabilities.length;\n    }\n    \n    calculateLoadScore(agent) {\n        // Lower active commands = higher score\n        const maxCommands = 10;\n        return Math.max(0, (maxCommands - agent.activeCommands) / maxCommands);\n    }\n    \n    calculateContextScore(agent, context) {\n        if (!context || !context.activeAgents.has(agent.id)) {\n            return 0.5; // Neutral score for new agents\n        }\n        \n        // Prefer agents already in context\n        return 1.0;\n    }\n    \n    async executeCommand(connection, command, selectedAgent, entities, commandMatch) {\n        const { sessionId } = connection;\n        const commandId = crypto.randomUUID();\n        \n        console.log(`🎯 Executing command \"${command}\" with agent: ${selectedAgent.id}`);\n        \n        // Update agent status\n        selectedAgent.activeCommands++;\n        this.availableAgents.set(selectedAgent.id, selectedAgent);\n        \n        // Add to active commands\n        connection.activeCommands.add(commandId);\n        \n        // Update context\n        const context = this.contextMemory.get(sessionId);\n        context.currentContext = commandMatch.intent;\n        context.activeAgents.add(selectedAgent.id);\n        \n        // Send initial response\n        this.sendVoiceResponse(connection, {\n            type: 'command-started',\n            commandId,\n            message: `Delegating \"${command}\" to ${selectedAgent.name}...`,\n            agent: {\n                id: selectedAgent.id,\n                name: selectedAgent.name,\n                capabilities: this.agentCapabilities.get(selectedAgent.id)\n            },\n            estimatedDuration: this.estimateCommandDuration(commandMatch, entities)\n        });\n        \n        try {\n            const startTime = Date.now();\n            \n            // Delegate to agent\n            const agentResponse = await this.delegateToAgent(selectedAgent, {\n                command,\n                entities,\n                context: commandMatch.config.context,\n                sessionId,\n                commandId,\n                deviceType: connection.deviceType\n            });\n            \n            const duration = Date.now() - startTime;\n            \n            // Update performance metrics\n            this.updateAgentMetrics(selectedAgent.id, duration, true);\n            \n            // Send success response\n            this.sendVoiceResponse(connection, {\n                type: 'command-completed',\n                commandId,\n                message: this.formatAgentResponse(agentResponse),\n                result: agentResponse,\n                duration,\n                agent: selectedAgent.id\n            });\n            \n            // Learn from successful command\n            this.recordCommandSuccess(command, selectedAgent.id, duration);\n            \n        } catch (error) {\n            console.error(`Command execution failed:`, error);\n            \n            // Update metrics for failure\n            this.updateAgentMetrics(selectedAgent.id, 0, false);\n            \n            // Send error response\n            this.sendVoiceResponse(connection, {\n                type: 'command-failed',\n                commandId,\n                message: `Failed to execute \"${command}\": ${error.message}`,\n                error: error.message,\n                suggestedActions: this.getSuggestedActions(commandMatch)\n            });\n            \n        } finally {\n            // Cleanup\n            selectedAgent.activeCommands--;\n            this.availableAgents.set(selectedAgent.id, selectedAgent);\n            connection.activeCommands.delete(commandId);\n        }\n    }\n    \n    async delegateToAgent(agent, payload) {\n        const agentEndpoint = agent.endpoint || `/api/agents/${agent.id}`;\n        const url = `${this.agentBridgeUrl}${agentEndpoint}`;\n        \n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Voice-Command': 'true',\n                'X-Session-ID': payload.sessionId\n            },\n            body: JSON.stringify(payload),\n            timeout: 30000 // 30 second timeout\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Agent ${agent.id} returned ${response.status}: ${response.statusText}`);\n        }\n        \n        return response.json();\n    }\n    \n    formatAgentResponse(agentResponse) {\n        if (typeof agentResponse === 'string') {\n            return agentResponse;\n        }\n        \n        if (agentResponse.message) {\n            return agentResponse.message;\n        }\n        \n        if (agentResponse.result) {\n            return `Task completed: ${agentResponse.result}`;\n        }\n        \n        return 'Task completed successfully.';\n    }\n    \n    estimateCommandDuration(commandMatch, entities) {\n        // Estimate based on command type and complexity\n        const baseDurations = {\n            document_processing: 5000,\n            code_generation: 15000,\n            git_operations: 3000,\n            system_status: 1000,\n            canvas_interaction: 2000,\n            ai_conversation: 3000\n        };\n        \n        let duration = baseDurations[commandMatch.intent] || 5000;\n        \n        // Adjust based on entities (file size, complexity, etc.)\n        if (entities.file_type) {\n            const complexTypes = ['pdf', 'doc', 'html'];\n            if (complexTypes.includes(entities.file_type)) {\n                duration *= 1.5;\n            }\n        }\n        \n        return duration;\n    }\n    \n    sendVoiceResponse(connection, response) {\n        if (connection.ws.readyState === WebSocket.OPEN) {\n            connection.ws.send(JSON.stringify({\n                ...response,\n                timestamp: new Date(),\n                sessionId: connection.sessionId\n            }));\n        }\n    }\n    \n    sendVoiceWelcome(connection) {\n        this.sendVoiceResponse(connection, {\n            type: 'welcome',\n            message: 'Voice orchestrator ready. You can say commands like \"process document\", \"show agent status\", or \"commit changes\".',\n            availableAgents: Array.from(this.availableAgents.keys()),\n            supportedCommands: Array.from(this.commandPatterns.keys())\n        });\n    }\n    \n    sendVoiceError(connection, message) {\n        this.sendVoiceResponse(connection, {\n            type: 'error',\n            message,\n            timestamp: new Date()\n        });\n    }\n    \n    addToCommandHistory(sessionId, command, confidence) {\n        const history = this.commandHistory.get(sessionId) || [];\n        \n        history.push({\n            command,\n            confidence,\n            timestamp: new Date()\n        });\n        \n        // Keep last 50 commands\n        if (history.length > 50) {\n            history.shift();\n        }\n        \n        this.commandHistory.set(sessionId, history);\n    }\n    \n    recordCommandSuccess(command, agentId, duration) {\n        const key = `${command.toLowerCase()}-${agentId}`;\n        const existing = this.learningData.get(key) || { successCount: 0, totalAttempts: 0, avgDuration: 0 };\n        \n        existing.successCount++;\n        existing.totalAttempts++;\n        existing.avgDuration = (existing.avgDuration + duration) / 2;\n        \n        this.learningData.set(key, existing);\n    }\n    \n    updateAgentMetrics(agentId, duration, success) {\n        const metrics = this.agentPerformanceMetrics.get(agentId) || {\n            totalCommands: 0,\n            successfulCommands: 0,\n            averageResponseTime: 0,\n            lastUpdated: new Date()\n        };\n        \n        metrics.totalCommands++;\n        if (success) {\n            metrics.successfulCommands++;\n            metrics.averageResponseTime = (metrics.averageResponseTime + duration) / 2;\n        }\n        metrics.lastUpdated = new Date();\n        \n        this.agentPerformanceMetrics.set(agentId, metrics);\n    }\n    \n    async checkAgentHealth() {\n        console.log('🔍 Checking agent health...');\n        \n        for (const [agentId, agent] of this.availableAgents.entries()) {\n            try {\n                const response = await fetch(`${this.agentBridgeUrl}/api/agents/${agentId}/health`, {\n                    method: 'GET',\n                    timeout: 5000\n                });\n                \n                if (response.ok) {\n                    agent.status = 'available';\n                    agent.lastSeen = new Date();\n                } else {\n                    agent.status = 'unhealthy';\n                }\n                \n            } catch (error) {\n                agent.status = 'offline';\n                console.warn(`Agent ${agentId} health check failed:`, error.message);\n            }\n            \n            this.availableAgents.set(agentId, agent);\n        }\n    }\n    \n    getAvailableCommands() {\n        return Array.from(this.commandPatterns.keys()).map(intent => {\n            const config = this.commandPatterns.get(intent);\n            return {\n                intent,\n                examples: config.patterns.slice(0, 2).map(p => p.source.replace(/.*\\((.*?)\\).*/g, '$1')),\n                agents: config.agents\n            };\n        });\n    }\n    \n    getSuggestedActions(commandMatch) {\n        return [\n            'Try rephrasing the command',\n            'Check if the required files are available',\n            'Verify agent connectivity',\n            `Ask for help with ${commandMatch.intent} commands`\n        ];\n    }\n    \n    handleVoiceDisconnection(connection) {\n        console.log(`🎤 Voice device disconnected: ${connection.deviceType} (${connection.deviceId})`);\n        \n        // Cancel active commands\n        connection.activeCommands.forEach(commandId => {\n            console.log(`   Cancelling command: ${commandId}`);\n        });\n        \n        // Cleanup\n        this.voiceConnections.delete(connection.connectionId);\n        this.deviceSessions.delete(connection.sessionId);\n    }\n    \n    // Public API methods\n    getVoiceStats() {\n        const totalCommands = Array.from(this.commandHistory.values())\n            .reduce((sum, history) => sum + history.length, 0);\n        \n        const activeConnections = this.voiceConnections.size;\n        \n        const agentStats = Array.from(this.agentPerformanceMetrics.entries())\n            .map(([agentId, metrics]) => ({\n                agentId,\n                successRate: metrics.successfulCommands / metrics.totalCommands,\n                avgResponseTime: metrics.averageResponseTime,\n                totalCommands: metrics.totalCommands\n            }));\n        \n        return {\n            totalCommands,\n            activeConnections,\n            availableAgents: this.availableAgents.size,\n            supportedIntents: this.commandPatterns.size,\n            agentStats\n        };\n    }\n    \n    // Cleanup\n    async shutdown() {\n        console.log('🛑 Shutting down Voice-Agent Orchestrator...');\n        \n        if (this.wss) {\n            this.wss.close();\n        }\n        \n        // Clear all data\n        this.availableAgents.clear();\n        this.agentCapabilities.clear();\n        this.activeAgentSessions.clear();\n        this.agentPerformanceMetrics.clear();\n        this.commandPatterns.clear();\n        this.commandHistory.clear();\n        this.contextMemory.clear();\n        this.learningData.clear();\n        this.voiceConnections.clear();\n        this.deviceSessions.clear();\n        this.nlpCache.clear();\n        \n        console.log('✅ Voice orchestrator shutdown complete');\n    }\n}\n\n// Export for use in other modules\nmodule.exports = VoiceAgentOrchestrator;\n\n// Start standalone if run directly\nif (require.main === module) {\n    const voiceOrchestrator = new VoiceAgentOrchestrator({\n        wsPort: process.env.VOICE_WS_PORT || 3336,\n        agentBridgeUrl: process.env.AGENT_BRIDGE_URL || 'http://localhost:9999',\n        localAIUrl: process.env.LOCAL_AI_URL || 'http://localhost:11434'\n    });\n    \n    // Graceful shutdown\n    process.on('SIGINT', async () => {\n        await voiceOrchestrator.shutdown();\n        process.exit(0);\n    });\n    \n    console.log('🎤 Voice-Agent Orchestrator running standalone');\n    console.log('   WebSocket: ws://localhost:3336');\n    console.log('   Ready for voice commands and agent delegation!');\n}