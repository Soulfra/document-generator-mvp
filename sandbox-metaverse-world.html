<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåê‚öîÔ∏è Sandbox Metaverse World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Main HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }
        
        /* Building Interface */
        #buildMenu {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 10px;
            display: none;
            z-index: 101;
            pointer-events: all;
        }
        
        .build-grid {
            display: grid;
            grid-template-columns: repeat(5, 80px);
            gap: 10px;
        }
        
        .build-item {
            width: 80px;
            height: 80px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
            text-align: center;
            font-size: 12px;
        }
        
        .build-item:hover {
            background: rgba(0, 255, 0, 0.3);
            border-color: #0f0;
            transform: scale(1.1);
        }
        
        .build-item .icon {
            font-size: 30px;
            margin-bottom: 5px;
        }
        
        /* Inventory */
        #inventory {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 5px;
            padding: 10px;
            display: none;
            z-index: 101;
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.8);
            border: 1px solid #666;
            margin: 2px;
            display: inline-block;
            position: relative;
        }
        
        /* Chat */
        #chat {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            z-index: 100;
        }
        
        #chatMessages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            color: #fff;
            font-size: 12px;
        }
        
        #chatInput {
            background: rgba(50, 50, 50, 0.8);
            border: none;
            color: #fff;
            padding: 10px;
            font-family: inherit;
            border-top: 1px solid #666;
        }
        
        /* Player List */
        #playerList {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0;
            border-radius: 5px;
            padding: 10px;
            min-width: 150px;
            z-index: 100;
        }
        
        #playerList h3 {
            margin: 0 0 10px 0;
            color: #ff0;
            font-size: 14px;
        }
        
        .player-entry {
            color: #0f0;
            margin: 5px 0;
            font-size: 12px;
        }
        
        /* Mode Selector */
        #modeSelector {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #f0f;
            border-radius: 5px;
            padding: 10px;
            z-index: 100;
        }
        
        .mode-button {
            display: block;
            width: 120px;
            padding: 10px;
            margin: 5px 0;
            background: rgba(50, 50, 50, 0.8);
            border: 1px solid #666;
            color: #fff;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: all 0.3s;
        }
        
        .mode-button:hover {
            background: rgba(255, 0, 255, 0.3);
            border-color: #f0f;
        }
        
        .mode-button.active {
            background: rgba(255, 0, 255, 0.5);
            border-color: #f0f;
        }
        
        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #fff;
            box-shadow: 0 0 4px rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
        }
        
        /* World Map */
        #worldMap {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            border-radius: 5px;
            z-index: 100;
        }
        
        /* Vehicle HUD */
        #vehicleHUD {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #f60;
            border-radius: 5px;
            padding: 10px;
            display: none;
            z-index: 100;
            color: #f60;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #0f0;
        }
        
        .loading-text {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .loading-bar {
            width: 300px;
            height: 20px;
            border: 2px solid #0f0;
            position: relative;
        }
        
        .loading-progress {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <canvas id="worldMap"></canvas>
    
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-text">üåê LOADING METAVERSE...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div id="loadingStatus" style="margin-top: 20px;">Initializing world...</div>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div style="font-size: 20px; font-weight: bold;">üåê SANDBOX METAVERSE</div>
        <div>Health: <span id="health">100</span></div>
        <div>Resources: <span id="resources">1000</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Mode: <span id="currentMode">EXPLORE</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>
    
    <!-- Crosshair -->
    <div id="crosshair"></div>
    
    <!-- Player List -->
    <div id="playerList">
        <h3>üåê ONLINE PLAYERS</h3>
        <div id="playerEntries"></div>
    </div>
    
    <!-- Mode Selector -->
    <div id="modeSelector">
        <div style="color: #f0f; font-weight: bold; margin-bottom: 10px;">üéÆ GAME MODE</div>
        <button class="mode-button active" onclick="game.setMode('explore')">üö∂ Explore</button>
        <button class="mode-button" onclick="game.setMode('build')">üèóÔ∏è Build</button>
        <button class="mode-button" onclick="game.setMode('combat')">‚öîÔ∏è Combat</button>
        <button class="mode-button" onclick="game.setMode('vehicle')">üöó Vehicle</button>
        <button class="mode-button" onclick="game.setMode('fly')">‚úàÔ∏è Fly</button>
    </div>
    
    <!-- Build Menu -->
    <div id="buildMenu">
        <div style="color: #0f0; font-weight: bold; margin-bottom: 10px; text-align: center;">üèóÔ∏è BUILD MODE</div>
        <div class="build-grid">
            <div class="build-item" onclick="game.selectBuildItem('block')">
                <div class="icon">üß±</div>
                <div>Block</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('wall')">
                <div class="icon">üè¢</div>
                <div>Wall</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('floor')">
                <div class="icon">‚¨ú</div>
                <div>Floor</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('ramp')">
                <div class="icon">üìê</div>
                <div>Ramp</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('door')">
                <div class="icon">üö™</div>
                <div>Door</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('window')">
                <div class="icon">ü™ü</div>
                <div>Window</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('roof')">
                <div class="icon">üè†</div>
                <div>Roof</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('light')">
                <div class="icon">üí°</div>
                <div>Light</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('spawner')">
                <div class="icon">üåÄ</div>
                <div>Spawner</div>
            </div>
            <div class="build-item" onclick="game.selectBuildItem('vehicle')">
                <div class="icon">üöó</div>
                <div>Vehicle</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px; color: #666;">
            Left Click: Place | Right Click: Remove | ESC: Exit Build Mode
        </div>
    </div>
    
    <!-- Inventory -->
    <div id="inventory">
        <div style="color: #0ff; font-weight: bold; margin-bottom: 10px;">üì¶ INVENTORY</div>
        <div id="inventorySlots"></div>
    </div>
    
    <!-- Chat -->
    <div id="chat">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Press T to chat..." />
    </div>
    
    <!-- Vehicle HUD -->
    <div id="vehicleHUD">
        <div style="font-weight: bold; margin-bottom: 5px;">üöó VEHICLE</div>
        <div>Speed: <span id="vehicleSpeed">0</span> km/h</div>
        <div>Fuel: <span id="vehicleFuel">100</span>%</div>
        <div>Press F to exit</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class SandboxMetaverse {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                
                this.world = {
                    chunks: new Map(),
                    entities: new Map(),
                    players: new Map(),
                    vehicles: new Map(),
                    buildings: new Map()
                };
                
                this.player = null;
                this.mode = 'explore';
                this.buildMode = false;
                this.selectedBuildItem = 'block';
                this.buildPreview = null;
                
                this.resources = 1000;
                this.health = 100;
                
                this.mouse = { x: 0, y: 0 };
                this.keys = {};
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                
                this.ws = null;
                this.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
                
                this.init();
            }
            
            async init() {
                // Show loading screen
                this.updateLoading(10, 'Setting up renderer...');
                
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB); // Sky blue
                
                this.updateLoading(20, 'Creating world...');
                
                // Setup scene
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);
                
                // Lighting
                this.setupLighting();
                
                this.updateLoading(30, 'Generating terrain...');
                
                // Create world
                await this.createWorld();
                
                this.updateLoading(50, 'Creating player...');
                
                // Create player
                this.createPlayer();
                
                this.updateLoading(60, 'Setting up controls...');
                
                // Setup controls
                this.setupControls();
                
                this.updateLoading(70, 'Initializing systems...');
                
                // Setup systems
                this.setupBuildSystem();
                this.setupChat();
                this.setupMinimap();
                
                this.updateLoading(80, 'Connecting to server...');
                
                // Connect to multiplayer
                this.connectMultiplayer();
                
                this.updateLoading(90, 'Loading assets...');
                
                // Create some initial content
                this.spawnInitialContent();
                
                this.updateLoading(100, 'Ready!');
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    this.animate();
                }, 500);
            }
            
            updateLoading(progress, status) {
                document.getElementById('loadingProgress').style.width = progress + '%';
                document.getElementById('loadingStatus').textContent = status;
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Sun
                const sunLight = new THREE.DirectionalLight(0xffffff, 1);
                sunLight.position.set(100, 200, 100);
                sunLight.castShadow = true;
                sunLight.shadow.camera.left = -100;
                sunLight.shadow.camera.right = 100;
                sunLight.shadow.camera.top = 100;
                sunLight.shadow.camera.bottom = -100;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                this.scene.add(sunLight);
                
                // Hemisphere light for better ambient
                const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.6);
                this.scene.add(hemiLight);
            }
            
            async createWorld() {
                // Create terrain chunks
                const chunkSize = 100;
                const worldSize = 5; // 5x5 chunks
                
                for (let x = -worldSize; x <= worldSize; x++) {
                    for (let z = -worldSize; z <= worldSize; z++) {
                        this.createTerrainChunk(x * chunkSize, z * chunkSize, chunkSize);
                    }
                }
                
                // Add skybox
                this.createSkybox();
                
                // Add ocean
                this.createOcean();
                
                // Add some landmarks
                this.createLandmarks();
            }
            
            createTerrainChunk(x, z, size) {
                // Procedural terrain with Perlin noise simulation
                const geometry = new THREE.PlaneGeometry(size, size, 32, 32);
                const vertices = geometry.attributes.position.array;
                
                for (let i = 0; i < vertices.length; i += 3) {
                    const vx = vertices[i] + x;
                    const vz = vertices[i + 1] + z;
                    
                    // Simple height map
                    let height = 0;
                    height += Math.sin(vx * 0.01) * 10;
                    height += Math.cos(vz * 0.01) * 10;
                    height += Math.sin(vx * 0.02 + vz * 0.02) * 5;
                    height += Math.random() * 2 - 1;
                    
                    vertices[i + 2] = height;
                }
                
                geometry.computeVertexNormals();
                
                // Terrain material with texture-like colors
                const material = new THREE.MeshStandardMaterial({
                    color: 0x3a5f3a,
                    roughness: 0.8,
                    metalness: 0.2,
                    vertexColors: true
                });
                
                // Add vertex colors for variation
                const colors = [];
                for (let i = 0; i < vertices.length; i += 3) {
                    const height = vertices[i + 2];
                    let r, g, b;
                    
                    if (height < -5) {
                        // Water - blue
                        r = 0.2; g = 0.3; b = 0.8;
                    } else if (height < 0) {
                        // Beach - sandy
                        r = 0.8; g = 0.7; b = 0.5;
                    } else if (height < 10) {
                        // Grass - green
                        r = 0.3; g = 0.6; b = 0.3;
                    } else if (height < 20) {
                        // Hills - darker green
                        r = 0.2; g = 0.4; b = 0.2;
                    } else {
                        // Mountains - gray
                        r = 0.5; g = 0.5; b = 0.5;
                    }
                    
                    colors.push(r, g, b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.position.set(x, 0, z);
                terrain.receiveShadow = true;
                terrain.castShadow = true;
                
                this.scene.add(terrain);
                this.world.chunks.set(`${x},${z}`, terrain);
            }
            
            createSkybox() {
                // Simple gradient sky
                const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
                const skyMat = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(0x0077ff) },
                        bottomColor: { value: new THREE.Color(0xffffff) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                
                const sky = new THREE.Mesh(skyGeo, skyMat);
                this.scene.add(sky);
            }
            
            createOcean() {
                const oceanGeo = new THREE.PlaneGeometry(2000, 2000, 128, 128);
                const oceanMat = new THREE.MeshStandardMaterial({
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 0.1,
                    metalness: 0.1
                });
                
                const ocean = new THREE.Mesh(oceanGeo, oceanMat);
                ocean.rotation.x = -Math.PI / 2;
                ocean.position.y = -5;
                this.scene.add(ocean);
            }
            
            createLandmarks() {
                // Spawn city
                this.createCity(0, 0, 0);
                
                // Create some structures
                this.createStructure(100, 0, 100, 'tower');
                this.createStructure(-150, 0, -150, 'pyramid');
                this.createStructure(200, 0, -200, 'castle');
            }
            
            createCity(x, y, z) {
                const citySize = 50;
                const buildingCount = 20;
                
                for (let i = 0; i < buildingCount; i++) {
                    const bx = x + (Math.random() - 0.5) * citySize;
                    const bz = z + (Math.random() - 0.5) * citySize;
                    const width = 5 + Math.random() * 10;
                    const height = 10 + Math.random() * 40;
                    const depth = 5 + Math.random() * 10;
                    
                    const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                    const buildingMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3, 0.3 + Math.random() * 0.3)
                    });
                    
                    const building = new THREE.Mesh(buildingGeo, buildingMat);
                    building.position.set(bx, height / 2, bz);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    this.scene.add(building);
                    this.world.buildings.set(`building_${i}`, building);
                }
                
                // Add roads
                const roadGeo = new THREE.PlaneGeometry(citySize * 2, 10);
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                const roadNS = new THREE.Mesh(roadGeo, roadMat);
                roadNS.rotation.x = -Math.PI / 2;
                roadNS.position.set(x, 0.1, z);
                this.scene.add(roadNS);
                
                const roadEW = new THREE.Mesh(roadGeo, roadMat);
                roadEW.rotation.x = -Math.PI / 2;
                roadEW.rotation.z = Math.PI / 2;
                roadEW.position.set(x, 0.1, z);
                this.scene.add(roadEW);
            }
            
            createStructure(x, y, z, type) {
                let structure;
                
                switch (type) {
                    case 'tower':
                        const towerGeo = new THREE.CylinderGeometry(10, 15, 100, 8);
                        const towerMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                        structure = new THREE.Mesh(towerGeo, towerMat);
                        structure.position.set(x, 50, z);
                        break;
                        
                    case 'pyramid':
                        const pyramidGeo = new THREE.ConeGeometry(30, 40, 4);
                        const pyramidMat = new THREE.MeshStandardMaterial({ color: 0xdaa520 });
                        structure = new THREE.Mesh(pyramidGeo, pyramidMat);
                        structure.position.set(x, 20, z);
                        structure.rotation.y = Math.PI / 4;
                        break;
                        
                    case 'castle':
                        structure = new THREE.Group();
                        
                        // Base
                        const baseGeo = new THREE.BoxGeometry(40, 30, 40);
                        const baseMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
                        const base = new THREE.Mesh(baseGeo, baseMat);
                        base.position.y = 15;
                        structure.add(base);
                        
                        // Towers
                        for (let i = 0; i < 4; i++) {
                            const tGeo = new THREE.CylinderGeometry(5, 5, 40, 8);
                            const tMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
                            const tower = new THREE.Mesh(tGeo, tMat);
                            const angle = (i / 4) * Math.PI * 2;
                            tower.position.set(Math.cos(angle) * 20, 20, Math.sin(angle) * 20);
                            structure.add(tower);
                        }
                        
                        structure.position.set(x, y, z);
                        break;
                }
                
                if (structure) {
                    structure.castShadow = true;
                    structure.receiveShadow = true;
                    this.scene.add(structure);
                    this.world.buildings.set(`structure_${type}_${x}_${z}`, structure);
                }
            }
            
            createPlayer() {
                // Player group
                this.player = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.BoxGeometry(1, 2, 0.5);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0066cc });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                this.player.add(body);
                
                // Head
                const headGeo = new THREE.SphereGeometry(0.5);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 2.5;
                this.player.add(head);
                
                // Arms
                const armGeo = new THREE.BoxGeometry(0.3, 1.5, 0.3);
                const armMat = new THREE.MeshStandardMaterial({ color: 0x0066cc });
                
                const leftArm = new THREE.Mesh(armGeo, armMat);
                leftArm.position.set(-0.8, 1, 0);
                this.player.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeo, armMat);
                rightArm.position.set(0.8, 1, 0);
                this.player.add(rightArm);
                
                this.player.position.set(0, 10, 0);
                this.player.velocity = new THREE.Vector3();
                this.player.canJump = false;
                
                this.scene.add(this.player);
                
                // Camera setup
                this.camera.position.set(0, 5, 10);
            }
            
            setupControls() {
                // Mouse controls
                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body) {
                        this.mouse.x += e.movementX * 0.002;
                        this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, 
                            this.mouse.y - e.movementY * 0.002));
                    }
                    
                    this.mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });
                
                document.addEventListener('click', (e) => {
                    if (document.pointerLockElement !== document.body && !e.target.closest('button') && !e.target.closest('input')) {
                        document.body.requestPointerLock();
                    } else if (this.buildMode) {
                        this.placeBlock();
                    }
                });
                
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (this.buildMode) {
                        this.removeBlock();
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Build mode toggle
                    if (e.key === 'b') {
                        this.toggleBuildMode();
                    }
                    
                    // Inventory toggle
                    if (e.key === 'i') {
                        this.toggleInventory();
                    }
                    
                    // Chat
                    if (e.key === 't' && !this.chatting) {
                        this.startChat();
                    }
                    
                    // Mode switching
                    if (e.key >= '1' && e.key <= '5') {
                        const modes = ['explore', 'build', 'combat', 'vehicle', 'fly'];
                        this.setMode(modes[parseInt(e.key) - 1]);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupBuildSystem() {
                // Create build preview
                const previewGeo = new THREE.BoxGeometry(4, 4, 4);
                const previewMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.5
                });
                this.buildPreview = new THREE.Mesh(previewGeo, previewMat);
                this.buildPreview.visible = false;
                this.scene.add(this.buildPreview);
            }
            
            setupChat() {
                const chatInput = document.getElementById('chatInput');
                chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChat();
                        this.endChat();
                    } else if (e.key === 'Escape') {
                        this.endChat();
                    }
                });
                
                chatInput.style.display = 'none';
            }
            
            setupMinimap() {
                this.minimapCanvas = document.getElementById('worldMap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.minimapCanvas.width = 200;
                this.minimapCanvas.height = 200;
            }
            
            connectMultiplayer() {
                // Try to connect to WebSocket server
                try {
                    this.ws = new WebSocket('ws://localhost:8765');
                    
                    this.ws.onopen = () => {
                        console.log('Connected to server');
                        this.sendPlayerUpdate();
                        this.addChatMessage('System', 'Connected to server', '#0f0');
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleServerMessage(data);
                    };
                    
                    this.ws.onerror = () => {
                        console.log('Server connection failed - running in offline mode');
                        this.addChatMessage('System', 'Running in offline mode', '#ff0');
                    };
                    
                    this.ws.onclose = () => {
                        this.addChatMessage('System', 'Disconnected from server', '#f00');
                    };
                } catch (e) {
                    console.log('Multiplayer disabled - no server found');
                }
            }
            
            handleServerMessage(data) {
                switch (data.type) {
                    case 'player_update':
                        this.updateOtherPlayer(data.playerId, data.position, data.rotation);
                        break;
                    case 'chat':
                        this.addChatMessage(data.sender, data.message, '#fff');
                        break;
                    case 'world_update':
                        this.syncWorldState(data.world);
                        break;
                }
            }
            
            updateOtherPlayer(playerId, position, rotation) {
                if (playerId === this.playerId) return;
                
                if (!this.world.players.has(playerId)) {
                    // Create new player
                    const otherPlayer = this.createOtherPlayer();
                    this.world.players.set(playerId, otherPlayer);
                    this.scene.add(otherPlayer);
                }
                
                const otherPlayer = this.world.players.get(playerId);
                otherPlayer.position.copy(position);
                otherPlayer.rotation.y = rotation;
            }
            
            createOtherPlayer() {
                const group = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.BoxGeometry(1, 2, 0.5);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc0066 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 1;
                group.add(body);
                
                // Head
                const headGeo = new THREE.SphereGeometry(0.5);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 2.5;
                group.add(head);
                
                return group;
            }
            
            sendPlayerUpdate() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'player_update',
                        playerId: this.playerId,
                        position: this.player.position,
                        rotation: this.player.rotation.y
                    }));
                }
            }
            
            spawnInitialContent() {
                // Spawn some vehicles
                this.spawnVehicle(-50, 1, -50, 'car');
                this.spawnVehicle(50, 1, 50, 'helicopter');
                
                // Spawn some NPCs
                for (let i = 0; i < 10; i++) {
                    this.spawnNPC(
                        (Math.random() - 0.5) * 200,
                        1,
                        (Math.random() - 0.5) * 200
                    );
                }
            }
            
            spawnVehicle(x, y, z, type) {
                let vehicle;
                
                switch (type) {
                    case 'car':
                        vehicle = new THREE.Group();
                        
                        // Body
                        const carBodyGeo = new THREE.BoxGeometry(4, 1.5, 8);
                        const carBodyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                        const carBody = new THREE.Mesh(carBodyGeo, carBodyMat);
                        carBody.position.y = 1;
                        vehicle.add(carBody);
                        
                        // Wheels
                        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
                        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        
                        for (let i = 0; i < 4; i++) {
                            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                            wheel.rotation.z = Math.PI / 2;
                            wheel.position.set(
                                i < 2 ? -1.5 : 1.5,
                                0.5,
                                i % 2 === 0 ? 3 : -3
                            );
                            vehicle.add(wheel);
                        }
                        
                        vehicle.vehicleType = 'car';
                        vehicle.speed = 0;
                        vehicle.maxSpeed = 50;
                        break;
                        
                    case 'helicopter':
                        vehicle = new THREE.Group();
                        
                        // Body
                        const heliBodyGeo = new THREE.SphereGeometry(2, 8, 6);
                        const heliBodyMat = new THREE.MeshStandardMaterial({ color: 0x006600 });
                        const heliBody = new THREE.Mesh(heliBodyGeo, heliBodyMat);
                        vehicle.add(heliBody);
                        
                        // Rotor
                        const rotorGeo = new THREE.BoxGeometry(10, 0.1, 0.5);
                        const rotorMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const rotor = new THREE.Mesh(rotorGeo, rotorMat);
                        rotor.position.y = 2;
                        vehicle.add(rotor);
                        vehicle.rotor = rotor;
                        
                        vehicle.vehicleType = 'helicopter';
                        vehicle.speed = 0;
                        vehicle.maxSpeed = 100;
                        break;
                }
                
                if (vehicle) {
                    vehicle.position.set(x, y, z);
                    this.scene.add(vehicle);
                    this.world.vehicles.set(`vehicle_${type}_${x}_${z}`, vehicle);
                }
            }
            
            spawnNPC(x, y, z) {
                const npc = this.createOtherPlayer();
                npc.position.set(x, y, z);
                npc.isNPC = true;
                npc.target = new THREE.Vector3(x, y, z);
                npc.speed = 2;
                this.scene.add(npc);
                this.world.entities.set(`npc_${x}_${z}`, npc);
            }
            
            setMode(mode) {
                this.mode = mode;
                document.getElementById('currentMode').textContent = mode.toUpperCase();
                
                // Update UI based on mode
                document.querySelectorAll('.mode-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`.mode-button:nth-child(${['explore', 'build', 'combat', 'vehicle', 'fly'].indexOf(mode) + 2})`).classList.add('active');
                
                if (mode === 'build') {
                    this.toggleBuildMode(true);
                } else {
                    this.toggleBuildMode(false);
                }
            }
            
            toggleBuildMode(force) {
                if (force !== undefined) {
                    this.buildMode = force;
                } else {
                    this.buildMode = !this.buildMode;
                }
                
                document.getElementById('buildMenu').style.display = this.buildMode ? 'block' : 'none';
                this.buildPreview.visible = this.buildMode;
                
                if (!this.buildMode) {
                    this.setMode('explore');
                }
            }
            
            toggleInventory() {
                const inventory = document.getElementById('inventory');
                inventory.style.display = inventory.style.display === 'block' ? 'none' : 'block';
            }
            
            selectBuildItem(item) {
                this.selectedBuildItem = item;
                
                // Update preview based on selected item
                if (this.buildPreview) {
                    this.scene.remove(this.buildPreview);
                }
                
                let geometry;
                switch (item) {
                    case 'block':
                        geometry = new THREE.BoxGeometry(4, 4, 4);
                        break;
                    case 'wall':
                        geometry = new THREE.BoxGeometry(4, 8, 0.5);
                        break;
                    case 'floor':
                        geometry = new THREE.BoxGeometry(8, 0.5, 8);
                        break;
                    case 'ramp':
                        geometry = new THREE.BoxGeometry(4, 0.5, 8);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(4, 4, 4);
                }
                
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.5
                });
                
                this.buildPreview = new THREE.Mesh(geometry, material);
                this.buildPreview.visible = this.buildMode;
                this.scene.add(this.buildPreview);
            }
            
            placeBlock() {
                if (!this.buildMode || this.resources < 10) return;
                
                const position = this.buildPreview.position.clone();
                const geometry = this.buildPreview.geometry.clone();
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random())
                });
                
                const block = new THREE.Mesh(geometry, material);
                block.position.copy(position);
                block.castShadow = true;
                block.receiveShadow = true;
                
                this.scene.add(block);
                this.world.buildings.set(`block_${Date.now()}`, block);
                
                this.resources -= 10;
                
                // Send to server if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'place_block',
                        position: position,
                        blockType: this.selectedBuildItem
                    }));
                }
            }
            
            removeBlock() {
                if (!this.buildMode) return;
                
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                const intersects = this.raycaster.intersectObjects(Array.from(this.world.buildings.values()));
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    this.scene.remove(object);
                    
                    // Find and remove from world
                    for (const [key, value] of this.world.buildings.entries()) {
                        if (value === object) {
                            this.world.buildings.delete(key);
                            break;
                        }
                    }
                    
                    this.resources += 5;
                }
            }
            
            startChat() {
                this.chatting = true;
                const chatInput = document.getElementById('chatInput');
                chatInput.style.display = 'block';
                chatInput.focus();
                document.exitPointerLock();
            }
            
            endChat() {
                this.chatting = false;
                const chatInput = document.getElementById('chatInput');
                chatInput.style.display = 'none';
                chatInput.value = '';
                document.body.requestPointerLock();
            }
            
            sendChat() {
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                
                if (message) {
                    this.addChatMessage(this.playerId, message, '#0f0');
                    
                    // Send to server if connected
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'chat',
                            sender: this.playerId,
                            message: message
                        }));
                    }
                }
            }
            
            addChatMessage(sender, message, color = '#fff') {
                const chatMessages = document.getElementById('chatMessages');
                const messageEl = document.createElement('div');
                messageEl.style.color = color;
                messageEl.textContent = `${sender}: ${message}`;
                chatMessages.appendChild(messageEl);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Remove old messages
                while (chatMessages.children.length > 50) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
            
            updatePlayer(delta) {
                if (!this.player || this.chatting) return;
                
                const speed = this.keys['shift'] ? 15 : 8;
                const moveVector = new THREE.Vector3();
                
                // Movement based on mode
                if (this.mode === 'fly') {
                    // Flying mode
                    if (this.keys['w']) moveVector.z -= 1;
                    if (this.keys['s']) moveVector.z += 1;
                    if (this.keys['a']) moveVector.x -= 1;
                    if (this.keys['d']) moveVector.x += 1;
                    if (this.keys[' ']) moveVector.y += 1;
                    if (this.keys['shift']) moveVector.y -= 1;
                    
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mouse.x);
                    moveVector.normalize().multiplyScalar(speed * delta);
                    this.player.position.add(moveVector);
                } else {
                    // Ground movement
                    if (this.keys['w']) moveVector.z -= 1;
                    if (this.keys['s']) moveVector.z += 1;
                    if (this.keys['a']) moveVector.x -= 1;
                    if (this.keys['d']) moveVector.x += 1;
                    
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mouse.x);
                    moveVector.normalize().multiplyScalar(speed * delta);
                    
                    this.player.position.x += moveVector.x;
                    this.player.position.z += moveVector.z;
                    
                    // Jump
                    if (this.keys[' '] && this.player.canJump) {
                        this.player.velocity.y = 15;
                        this.player.canJump = false;
                    }
                    
                    // Gravity
                    this.player.velocity.y -= 30 * delta;
                    this.player.position.y += this.player.velocity.y * delta;
                    
                    // Ground collision
                    const groundHeight = this.getGroundHeight(this.player.position.x, this.player.position.z);
                    if (this.player.position.y < groundHeight + 3) {
                        this.player.position.y = groundHeight + 3;
                        this.player.velocity.y = 0;
                        this.player.canJump = true;
                    }
                }
                
                // Update rotation
                this.player.rotation.y = this.mouse.x;
                
                // Send update to server
                if (Date.now() - (this.lastUpdateSent || 0) > 50) { // 20 updates per second
                    this.sendPlayerUpdate();
                    this.lastUpdateSent = Date.now();
                }
            }
            
            getGroundHeight(x, z) {
                // Simple height calculation based on terrain function
                let height = 0;
                height += Math.sin(x * 0.01) * 10;
                height += Math.cos(z * 0.01) * 10;
                height += Math.sin(x * 0.02 + z * 0.02) * 5;
                return height;
            }
            
            updateCamera() {
                if (!this.player) return;
                
                const cameraOffset = new THREE.Vector3(0, 5, 10);
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mouse.x);
                
                this.camera.position.copy(this.player.position).add(cameraOffset);
                
                const lookAt = this.player.position.clone();
                lookAt.y += 2;
                this.camera.lookAt(lookAt);
            }
            
            updateBuildPreview() {
                if (!this.buildMode || !this.buildPreview) return;
                
                this.raycaster.setFromCamera(this.mouseVector, this.camera);
                const intersects = this.raycaster.intersectObjects([...this.world.chunks.values()]);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const snapped = new THREE.Vector3(
                        Math.round(point.x / 4) * 4,
                        Math.round(point.y / 4) * 4 + 2,
                        Math.round(point.z / 4) * 4
                    );
                    this.buildPreview.position.copy(snapped);
                }
            }
            
            updateNPCs(delta) {
                this.world.entities.forEach((npc, key) => {
                    if (!npc.isNPC) return;
                    
                    // Simple AI
                    if (npc.position.distanceTo(npc.target) < 2) {
                        // Pick new target
                        npc.target = new THREE.Vector3(
                            (Math.random() - 0.5) * 200,
                            1,
                            (Math.random() - 0.5) * 200
                        );
                    }
                    
                    // Move towards target
                    const direction = npc.target.clone().sub(npc.position).normalize();
                    npc.position.add(direction.multiplyScalar(npc.speed * delta));
                    
                    // Ground collision
                    const groundHeight = this.getGroundHeight(npc.position.x, npc.position.z);
                    npc.position.y = groundHeight + 3;
                    
                    // Look at target
                    npc.lookAt(npc.target);
                });
            }
            
            updateVehicles(delta) {
                this.world.vehicles.forEach((vehicle, key) => {
                    if (vehicle.vehicleType === 'helicopter' && vehicle.rotor) {
                        vehicle.rotor.rotation.y += delta * 10;
                    }
                });
            }
            
            updateMinimap() {
                const ctx = this.minimapCtx;
                const scale = 0.5;
                
                // Clear
                ctx.fillStyle = '#001100';
                ctx.fillRect(0, 0, 200, 200);
                
                // Grid
                ctx.strokeStyle = '#003300';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 20, 0);
                    ctx.lineTo(i * 20, 200);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * 20);
                    ctx.lineTo(200, i * 20);
                    ctx.stroke();
                }
                
                // Player
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(
                    100 + this.player.position.x * scale - 2,
                    100 - this.player.position.z * scale - 2,
                    4, 4
                );
                
                // Other players
                this.world.players.forEach((player, id) => {
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(
                        100 + player.position.x * scale - 2,
                        100 - player.position.z * scale - 2,
                        4, 4
                    );
                });
                
                // Buildings
                this.world.buildings.forEach((building, key) => {
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(
                        100 + building.position.x * scale - 1,
                        100 - building.position.z * scale - 1,
                        2, 2
                    );
                });
            }
            
            updateUI() {
                document.getElementById('health').textContent = Math.round(this.health);
                document.getElementById('resources').textContent = Math.round(this.resources);
                document.getElementById('position').textContent = 
                    `${this.player.position.x.toFixed(1)}, ${this.player.position.y.toFixed(1)}, ${this.player.position.z.toFixed(1)}`;
                
                // Update player list
                const playerEntries = document.getElementById('playerEntries');
                playerEntries.innerHTML = '';
                
                // Add self
                const selfEntry = document.createElement('div');
                selfEntry.className = 'player-entry';
                selfEntry.textContent = `${this.playerId} (You)`;
                playerEntries.appendChild(selfEntry);
                
                // Add other players
                this.world.players.forEach((player, id) => {
                    const entry = document.createElement('div');
                    entry.className = 'player-entry';
                    entry.textContent = id;
                    playerEntries.appendChild(entry);
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = Math.min(0.1, this.clock ? this.clock.getDelta() : 0.016);
                if (!this.clock) this.clock = new THREE.Clock();
                
                // Update game state
                this.updatePlayer(delta);
                this.updateCamera();
                this.updateBuildPreview();
                this.updateNPCs(delta);
                this.updateVehicles(delta);
                this.updateMinimap();
                this.updateUI();
                
                // Add resources over time
                this.resources += delta * 5;
                
                // Update FPS
                const fps = 1 / delta;
                document.getElementById('fps').textContent = Math.round(fps);
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start game
        const game = new SandboxMetaverse();
    </script>
</body>
</html>