<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Economic Visualization - Real-Time Agent Economy</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            z-index: 100;
            min-width: 300px;
        }
        
        .metric {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .cost-high { color: #f00; }
        .cost-medium { color: #ff0; }
        .cost-low { color: #0f0; }
        
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
        }
        
        .legend-item {
            margin: 5px 0;
            font-size: 12px;
        }
        
        .agent-sphere { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .ralph { background: #f00; }
        .docagent { background: #00f; }
        .roastagent { background: #ff0; }
        .hustleagent { background: #0f0; }
        .spyagent { background: #f0f; }
        .battleagent { background: #fa0; }
        .legalagent { background: #0ff; }
        
        #external-indicators {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
        }
        
        .external-metric {
            margin: 8px 0;
            font-size: 13px;
        }
        
        .debt-indicator { color: #f44; }
        .crypto-indicator { color: #fa0; }
        .gaming-indicator { color: #4f4; }
        .market-indicator { color: #44f; }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h2 style="color: #0f0; margin-bottom: 15px;">üí∞ ECONOMIC VISUALIZATION</h2>
            <div class="metric">Market Price: $<span id="market-price">0</span></div>
            <div class="metric">Total Cost: $<span id="total-cost">0</span></div>
            <div class="metric">Active Trades: <span id="active-trades">0</span></div>
            <div class="metric">API Calls/min: <span id="api-rate">0</span></div>
            <div class="metric">Compute Pool: <span id="compute-pool">0</span></div>
            <div class="metric">Cost/Hour: $<span id="cost-per-hour">0</span></div>
        </div>
        
        <div id="external-indicators">
            <h3 style="color: #ff0; margin-bottom: 10px;">üåç EXTERNAL ECONOMIES</h3>
            <div class="external-metric debt-indicator">US Debt: $<span id="us-debt">31.5T</span></div>
            <div class="external-metric crypto-indicator">BTC: $<span id="btc-price">45,000</span></div>
            <div class="external-metric gaming-indicator">WoW Token: <span id="wow-token">175k</span>g</div>
            <div class="external-metric market-indicator">SPY: $<span id="spy-price">425</span></div>
        </div>
        
        <div id="legend">
            <h3 style="color: #0ff; margin-bottom: 10px;">AGENTS</h3>
            <div class="legend-item"><span class="agent-sphere ralph"></span>Ralph (Destruction)</div>
            <div class="legend-item"><span class="agent-sphere docagent"></span>DocAgent (Processing)</div>
            <div class="legend-item"><span class="agent-sphere roastagent"></span>RoastAgent (Financial)</div>
            <div class="legend-item"><span class="agent-sphere hustleagent"></span>HustleAgent (Opportunity)</div>
            <div class="legend-item"><span class="agent-sphere spyagent"></span>SpyAgent (Stealth)</div>
            <div class="legend-item"><span class="agent-sphere battleagent"></span>BattleAgent (Combat)</div>
            <div class="legend-item"><span class="agent-sphere legalagent"></span>LegalAgent (Legal)</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 3D Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        document.getElementById('container').appendChild(renderer.domElement);

        // Agent representations
        const agents = new Map();
        const agentColors = {
            ralph: 0xff0000,
            docagent: 0x0000ff,
            roastagent: 0xffff00,
            hustleagent: 0x00ff00,
            spyagent: 0xff00ff,
            battleagent: 0xff9900,
            legalagent: 0x00ffff
        };

        // Create agent spheres in 3D space
        function createAgents() {
            const agentNames = Object.keys(agentColors);
            agentNames.forEach((name, index) => {
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: agentColors[name],
                    transparent: true,
                    opacity: 0.8
                });
                const sphere = new THREE.Mesh(geometry, material);
                
                // Position agents in a circle
                const angle = (index / agentNames.length) * Math.PI * 2;
                sphere.position.x = Math.cos(angle) * 8;
                sphere.position.z = Math.sin(angle) * 8;
                sphere.position.y = 0;
                
                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: agentColors[name],
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                sphere.add(glow);
                
                scene.add(sphere);
                agents.set(name, {
                    mesh: sphere,
                    glow: glow,
                    balance: 1000,
                    apiCalls: 0,
                    totalSpent: 0
                });
            });
        }

        // Create central compute pool visualization
        function createComputePool() {
            const geometry = new THREE.IcosahedronGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            const computeCore = new THREE.Mesh(geometry, material);
            computeCore.position.set(0, 0, 0);
            scene.add(computeCore);
            
            // Rotating core animation
            function animateCore() {
                computeCore.rotation.x += 0.01;
                computeCore.rotation.y += 0.02;
            }
            
            return { mesh: computeCore, animate: animateCore };
        }

        // Create trade visualization lines
        function createTradeLine(fromAgent, toAgent, amount, cost) {
            const fromPos = agents.get(fromAgent).mesh.position;
            const toPos = agents.get(toAgent).mesh.position;
            
            const points = [fromPos, toPos];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // Color based on cost
            let color = 0x00ff00; // green for low cost
            if (cost > 0.01) color = 0xffff00; // yellow for medium
            if (cost > 0.05) color = 0xff0000; // red for high cost
            
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Animate and remove line
            let opacity = 0.8;
            const fadeOut = setInterval(() => {
                opacity -= 0.05;
                material.opacity = opacity;
                if (opacity <= 0) {
                    scene.remove(line);
                    clearInterval(fadeOut);
                }
            }, 100);
        }

        // Create API cost particles
        function createAPIParticle(agent, cost, model) {
            const agentPos = agents.get(agent).mesh.position.clone();
            
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            let color = 0x00ff00; // green for free
            if (cost > 0) color = 0xffff00; // yellow for cheap
            if (cost > 0.05) color = 0xff9900; // orange for expensive
            if (cost > 0.1) color = 0xff0000; // red for very expensive
            
            const material = new THREE.MeshBasicMaterial({ color: color });
            const particle = new THREE.Mesh(geometry, material);
            
            particle.position.copy(agentPos);
            scene.add(particle);
            
            // Animate particle upward and fade
            let height = 0;
            const riseAnimation = setInterval(() => {
                height += 0.2;
                particle.position.y = agentPos.y + height;
                particle.scale.multiplyScalar(0.95);
                
                if (height > 10) {
                    scene.remove(particle);
                    clearInterval(riseAnimation);
                }
            }, 50);
        }

        // External economy effects
        function createExternalEffects(data) {
            // US Debt effect - red particles from top
            if (data.us_debt > 32000000000000) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const geometry = new THREE.SphereGeometry(0.05, 6, 6);
                        const material = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                        const particle = new THREE.Mesh(geometry, material);
                        
                        particle.position.set(
                            (Math.random() - 0.5) * 20,
                            15,
                            (Math.random() - 0.5) * 20
                        );
                        scene.add(particle);
                        
                        const fallAnimation = setInterval(() => {
                            particle.position.y -= 0.1;
                            if (particle.position.y < -5) {
                                scene.remove(particle);
                                clearInterval(fallAnimation);
                            }
                        }, 50);
                    }, i * 100);
                }
            }
            
            // Crypto effect - golden particles
            if (data.btc_price > 45000) {
                const geometry = new THREE.SphereGeometry(0.08, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                const crypto = new THREE.Mesh(geometry, material);
                
                crypto.position.set(
                    Math.cos(Date.now() * 0.001) * 12,
                    Math.sin(Date.now() * 0.002) * 3,
                    Math.sin(Date.now() * 0.001) * 12
                );
                scene.add(crypto);
                
                setTimeout(() => scene.remove(crypto), 2000);
            }
        }

        // Data fetching and updates
        let economyData = null;
        let lastAPICallCount = 0;
        
        async function fetchEconomyData() {
            try {
                const response = await fetch('/api/economy/status');
                const data = await response.json();
                economyData = data;
                updateVisualization(data);
            } catch (error) {
                console.error('Failed to fetch economy data:', error);
                // Use mock data for demonstration
                updateWithMockData();
            }
        }
        
        function updateWithMockData() {
            const mockData = {
                market_price: 1.05,
                agents: [
                    { name: 'ralph', balance: 850, api_calls: 12, total_spent: 0.045 },
                    { name: 'docagent', balance: 1200, api_calls: 8, total_spent: 0.234 },
                    { name: 'roastagent', balance: 950, api_calls: 15, total_spent: 0.089 },
                    { name: 'hustleagent', balance: 1100, api_calls: 6, total_spent: 0.056 },
                    { name: 'spyagent', balance: 750, api_calls: 20, total_spent: 0.023 },
                    { name: 'battleagent', balance: 900, api_calls: 10, total_spent: 0.034 },
                    { name: 'legalagent', balance: 1050, api_calls: 7, total_spent: 0.187 }
                ],
                cost_tracking: {
                    total_cost_usd: 0.668,
                    total_tokens_used: 34562,
                    external_api_calls: 3,
                    cost_per_hour: 1.245
                },
                recent_trades: [
                    { from: 'docagent', to: 'ralph', cost: 0.045 },
                    { from: 'spyagent', to: 'hustleagent', cost: 0.012 }
                ]
            };
            updateVisualization(mockData);
        }
        
        function updateVisualization(data) {
            // Update info panel
            document.getElementById('market-price').textContent = data.market_price?.toFixed(2) || '1.05';
            document.getElementById('total-cost').textContent = data.cost_tracking?.total_cost_usd?.toFixed(4) || '0.668';
            document.getElementById('active-trades').textContent = data.recent_trades?.length || '2';
            document.getElementById('cost-per-hour').textContent = data.cost_tracking?.cost_per_hour || '1.245';
            document.getElementById('compute-pool').textContent = data.total_compute || '10000';
            
            // Calculate API rate
            const currentAPICount = data.agents?.reduce((sum, agent) => sum + (agent.api_calls || 0), 0) || 78;
            const apiRate = Math.max(0, currentAPICount - lastAPICallCount) * 6; // per minute
            document.getElementById('api-rate').textContent = apiRate;
            lastAPICallCount = currentAPICount;
            
            // Update external indicators with realistic fluctuation
            const baseDebt = 31500000000000;
            const debtVariation = Math.sin(Date.now() * 0.0001) * 100000000000;
            const currentDebt = (baseDebt + debtVariation) / 1000000000000;
            document.getElementById('us-debt').textContent = currentDebt.toFixed(1) + 'T';
            
            const baseBTC = 45000;
            const btcVariation = Math.sin(Date.now() * 0.0003) * 2000;
            document.getElementById('btc-price').textContent = (baseBTC + btcVariation).toFixed(0);
            
            const baseWoW = 175000;
            const wowVariation = Math.sin(Date.now() * 0.0002) * 15000;
            document.getElementById('wow-token').textContent = (baseWoW + wowVariation).toFixed(0);
            
            const baseSPY = 425;
            const spyVariation = Math.sin(Date.now() * 0.0001) * 10;
            document.getElementById('spy-price').textContent = (baseSPY + spyVariation).toFixed(0);
            
            // Update agent visualizations
            if (data.agents) {
                data.agents.forEach(agentData => {
                    const agent = agents.get(agentData.name);
                    if (agent) {
                        // Update agent size based on balance
                        const scale = 0.5 + (agentData.balance / 2000);
                        agent.mesh.scale.setScalar(scale);
                        
                        // Update glow based on API spending
                        const glowIntensity = 0.2 + Math.min(agentData.total_spent * 5, 0.8);
                        agent.glow.material.opacity = glowIntensity;
                        
                        // Create API particle if agent spent money recently
                        if (Math.random() < 0.3 && agentData.total_spent > 0) {
                            createAPIParticle(agentData.name, agentData.total_spent, 'random_model');
                        }
                    }
                });
            }
            
            // Create trade lines for recent trades
            if (data.recent_trades) {
                data.recent_trades.forEach(trade => {
                    if (Math.random() < 0.5) { // 50% chance to visualize each trade
                        createTradeLine(trade.from, trade.to, 100, trade.cost || 0);
                    }
                });
            }
            
            // External economy effects
            createExternalEffects({
                us_debt: baseDebt + debtVariation,
                btc_price: baseBTC + btcVariation,
                wow_token: baseWoW + wowVariation,
                spy_price: baseSPY + spyVariation
            });
        }

        // Initialize scene
        createAgents();
        const computeCore = createComputePool();
        
        // Camera positioning
        camera.position.set(0, 10, 15);
        camera.lookAt(0, 0, 0);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Animate compute core
            computeCore.animate();
            
            // Orbit camera
            const time = Date.now() * 0.0005;
            camera.position.x = Math.cos(time) * 20;
            camera.position.z = Math.sin(time) * 20;
            camera.lookAt(0, 0, 0);
            
            // Animate agents (subtle movement)
            agents.forEach((agent, name) => {
                const time = Date.now() * 0.001;
                agent.mesh.position.y = Math.sin(time + agents.size) * 0.5;
                agent.mesh.rotation.y += 0.01;
            });
            
            renderer.render(scene, camera);
        }
        
        // Start systems
        animate();
        fetchEconomyData();
        setInterval(fetchEconomyData, 2000); // Update every 2 seconds
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'r': // Reset camera
                    camera.position.set(0, 10, 15);
                    break;
                case 'f': // Focus on center
                    camera.lookAt(0, 0, 0);
                    break;
                case 'space': // Trigger chaos mode visualization
                    agents.forEach(agent => {
                        agent.glow.material.opacity = 1;
                        agent.mesh.material.color.setHex(0xff0000);
                    });
                    setTimeout(() => {
                        agents.forEach((agent, name) => {
                            agent.mesh.material.color.setHex(agentColors[name]);
                            agent.glow.material.opacity = 0.2;
                        });
                    }, 2000);
                    break;
            }
        });
    </script>
</body>
</html>