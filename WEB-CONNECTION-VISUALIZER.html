<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Connection Visualizer - How Everything Connects</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Info panel */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .info-title {
            font-size: 18px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0ff;
        }

        .connection-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #0ff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connection-item:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateX(-5px);
        }

        .connection-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .connection-details {
            font-size: 11px;
            opacity: 0.7;
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            padding: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #0ff;
        }

        /* Controls */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            padding: 15px;
        }

        .control-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0ff;
            padding: 10px;
            display: none;
            pointer-events: none;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h3 style="margin-bottom: 10px;">VIEW MODES</h3>
        <button class="control-btn" onclick="visualizer.setMode('all')">All Connections</button>
        <button class="control-btn" onclick="visualizer.setMode('ai')">AI Systems</button>
        <button class="control-btn" onclick="visualizer.setMode('data')">Data Flow</button>
        <button class="control-btn" onclick="visualizer.setMode('contracts')">Contracts</button>
        <button class="control-btn" onclick="visualizer.toggleAnimation()">Toggle Animation</button>
    </div>
    
    <div id="info-panel">
        <h2 class="info-title">ACTIVE CONNECTIONS</h2>
        <div id="connection-list"></div>
    </div>
    
    <div id="legend">
        <h3 style="margin-bottom: 10px;">CONNECTION TYPES</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ffff;"></div>
            <span>AI/Reasoning</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff00ff;"></div>
            <span>Data Pipeline</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffff00;"></div>
            <span>Contracts/Handshakes</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>Visual/UI</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6600;"></div>
            <span>Orchestration</span>
        </div>
    </div>
    
    <div id="tooltip"></div>

    <script>
        class WebConnectionVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = new Map();
                this.connections = [];
                this.particles = [];
                this.mode = 'all';
                this.animated = true;
                this.hoveredNode = null;
                
                this.init();
            }
            
            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Mouse events
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.onClick(e));
                
                // Create network structure
                this.createNetworkStructure();
                
                // Start animation
                this.animate();
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createNetworkStructure() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Core systems
                this.addNode('storybook', {
                    x: centerX,
                    y: centerY - 200,
                    type: 'visual',
                    label: 'Laser/Voxel Storybook',
                    description: 'Visual pattern recognition and story generation'
                });
                
                this.addNode('ai-world', {
                    x: centerX - 300,
                    y: centerY - 100,
                    type: 'ai',
                    label: 'AI Game World',
                    description: 'Autonomous AI characters and learning'
                });
                
                this.addNode('cal-mapper', {
                    x: centerX,
                    y: centerY,
                    type: 'orchestration',
                    label: 'CAL Reasoning Mapper',
                    description: 'Central mapping and routing system'
                });
                
                this.addNode('handshake', {
                    x: centerX + 300,
                    y: centerY - 100,
                    type: 'contracts',
                    label: 'Handshake Orchestrator',
                    description: 'Contract verification and agreements'
                });
                
                // Data systems
                this.addNode('qr-embed', {
                    x: centerX - 200,
                    y: centerY + 150,
                    type: 'data',
                    label: 'QR Embedder',
                    description: 'Embeds training data in visual patterns'
                });
                
                this.addNode('jsonl-export', {
                    x: centerX,
                    y: centerY + 200,
                    type: 'data',
                    label: 'JSONL Exporter',
                    description: 'Exports training data for models'
                });
                
                this.addNode('gif-converter', {
                    x: centerX + 200,
                    y: centerY + 150,
                    type: 'data',
                    label: 'GIF/Voxel Converter',
                    description: 'Converts animations to voxel data'
                });
                
                // AI subsystems
                this.addNode('character-designer', {
                    x: centerX - 400,
                    y: centerY,
                    type: 'ai',
                    label: 'AI Character Designer',
                    description: 'Creates unique characters based on personality'
                });
                
                this.addNode('physics-engine', {
                    x: centerX - 300,
                    y: centerY + 100,
                    type: 'ai',
                    label: 'Advanced Physics',
                    description: 'Natural movement and behavior simulation'
                });
                
                // Orchestration subsystems
                this.addNode('switchboard', {
                    x: centerX + 150,
                    y: centerY - 50,
                    type: 'orchestration',
                    label: 'Switchboard Operators',
                    description: 'Routes messages between systems'
                });
                
                this.addNode('training-pipeline', {
                    x: centerX + 150,
                    y: centerY + 50,
                    type: 'orchestration',
                    label: 'Training Pipeline',
                    description: 'Processes and batches training data'
                });
                
                // Contract systems
                this.addNode('morse-verifier', {
                    x: centerX + 400,
                    y: centerY,
                    type: 'contracts',
                    label: 'Morse Code Verifier',
                    description: 'Historical verification system'
                });
                
                this.addNode('contract-viewer', {
                    x: centerX + 300,
                    y: centerY + 100,
                    type: 'contracts',
                    label: 'Contract Viewer',
                    description: 'Safe observation of agreements'
                });
                
                // Create connections
                this.createConnections();
                
                // Update UI
                this.updateConnectionList();
            }
            
            createConnections() {
                // Core connections
                this.addConnection('storybook', 'cal-mapper', 'visual-data');
                this.addConnection('ai-world', 'cal-mapper', 'ai-decisions');
                this.addConnection('cal-mapper', 'handshake', 'verification');
                
                // Data flow
                this.addConnection('storybook', 'qr-embed', 'page-data');
                this.addConnection('qr-embed', 'cal-mapper', 'embedded-training');
                this.addConnection('cal-mapper', 'jsonl-export', 'training-batch');
                this.addConnection('gif-converter', 'cal-mapper', 'voxel-data');
                
                // AI connections
                this.addConnection('ai-world', 'character-designer', 'personality');
                this.addConnection('character-designer', 'physics-engine', 'character-model');
                this.addConnection('physics-engine', 'ai-world', 'movement-data');
                
                // Orchestration
                this.addConnection('cal-mapper', 'switchboard', 'routing-request');
                this.addConnection('switchboard', 'training-pipeline', 'message-queue');
                this.addConnection('training-pipeline', 'jsonl-export', 'processed-data');
                
                // Contracts
                this.addConnection('handshake', 'morse-verifier', 'verification-request');
                this.addConnection('morse-verifier', 'contract-viewer', 'verified-data');
                this.addConnection('contract-viewer', 'cal-mapper', 'contract-status');
            }
            
            addNode(id, properties) {
                this.nodes.set(id, {
                    id,
                    ...properties,
                    radius: 30,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
            
            addConnection(from, to, label) {
                this.connections.push({
                    from,
                    to,
                    label,
                    particles: []
                });
            }
            
            setMode(mode) {
                this.mode = mode;
                this.updateConnectionList();
            }
            
            toggleAnimation() {
                this.animated = !this.animated;
            }
            
            updateConnectionList() {
                const list = document.getElementById('connection-list');
                list.innerHTML = '';
                
                // Filter connections based on mode
                const filtered = this.connections.filter(conn => {
                    if (this.mode === 'all') return true;
                    
                    const fromNode = this.nodes.get(conn.from);
                    const toNode = this.nodes.get(conn.to);
                    
                    if (this.mode === 'ai') {
                        return fromNode.type === 'ai' || toNode.type === 'ai';
                    } else if (this.mode === 'data') {
                        return fromNode.type === 'data' || toNode.type === 'data';
                    } else if (this.mode === 'contracts') {
                        return fromNode.type === 'contracts' || toNode.type === 'contracts';
                    }
                    
                    return false;
                });
                
                // Display filtered connections
                filtered.forEach(conn => {
                    const fromNode = this.nodes.get(conn.from);
                    const toNode = this.nodes.get(conn.to);
                    
                    const item = document.createElement('div');
                    item.className = 'connection-item';
                    item.innerHTML = `
                        <div class="connection-name">${fromNode.label} → ${toNode.label}</div>
                        <div class="connection-details">${conn.label}</div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.highlightConnection(conn);
                    });
                    
                    list.appendChild(item);
                });
            }
            
            highlightConnection(connection) {
                // Add visual highlight effect
                connection.highlighted = true;
                setTimeout(() => {
                    connection.highlighted = false;
                }, 3000);
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Check if hovering over a node
                let hovered = null;
                this.nodes.forEach(node => {
                    const dist = Math.sqrt(
                        Math.pow(x - node.x, 2) + 
                        Math.pow(y - node.y, 2)
                    );
                    
                    if (dist < node.radius) {
                        hovered = node;
                    }
                });
                
                this.hoveredNode = hovered;
                
                // Update tooltip
                const tooltip = document.getElementById('tooltip');
                if (hovered) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 10 + 'px';
                    tooltip.style.top = e.clientY + 10 + 'px';
                    tooltip.innerHTML = `
                        <strong>${hovered.label}</strong><br>
                        ${hovered.description}<br>
                        <em>Type: ${hovered.type}</em>
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            }
            
            onClick(e) {
                if (this.hoveredNode) {
                    console.log('Clicked node:', this.hoveredNode);
                    // Could open detailed view or trigger action
                }
            }
            
            animate() {
                this.ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw connections
                this.connections.forEach(conn => {
                    this.drawConnection(conn);
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    this.drawNode(node);
                });
                
                // Update particles
                if (this.animated) {
                    this.updateParticles();
                }
                
                requestAnimationFrame(() => this.animate());
            }
            
            drawConnection(conn) {
                const fromNode = this.nodes.get(conn.from);
                const toNode = this.nodes.get(conn.to);
                
                if (!fromNode || !toNode) return;
                
                // Skip if not in current mode
                if (this.mode !== 'all') {
                    if (this.mode === 'ai' && fromNode.type !== 'ai' && toNode.type !== 'ai') return;
                    if (this.mode === 'data' && fromNode.type !== 'data' && toNode.type !== 'data') return;
                    if (this.mode === 'contracts' && fromNode.type !== 'contracts' && toNode.type !== 'contracts') return;
                }
                
                this.ctx.beginPath();
                this.ctx.moveTo(fromNode.x, fromNode.y);
                
                // Curved connection
                const cx = (fromNode.x + toNode.x) / 2;
                const cy = (fromNode.y + toNode.y) / 2 - 50;
                
                this.ctx.quadraticCurveTo(cx, cy, toNode.x, toNode.y);
                
                if (conn.highlighted) {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#0ff';
                } else {
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.stroke();
                
                // Draw particles along connection
                if (this.animated && !conn.particles.length) {
                    conn.particles.push({
                        progress: 0,
                        speed: 0.01 + Math.random() * 0.02
                    });
                }
            }
            
            drawNode(node) {
                // Skip if not in current mode
                if (this.mode !== 'all' && 
                    this.mode !== node.type && 
                    !this.connections.some(c => 
                        (c.from === node.id || c.to === node.id) &&
                        (this.nodes.get(c.from).type === this.mode || 
                         this.nodes.get(c.to).type === this.mode)
                    )) {
                    return;
                }
                
                // Pulsing effect
                node.pulsePhase += 0.02;
                const pulse = 1 + Math.sin(node.pulsePhase) * 0.1;
                
                // Node circle
                this.ctx.beginPath();
                this.ctx.arc(node.x, node.y, node.radius * pulse, 0, Math.PI * 2);
                
                // Color based on type
                const colors = {
                    ai: '#00ffff',
                    data: '#ff00ff',
                    contracts: '#ffff00',
                    visual: '#00ff00',
                    orchestration: '#ff6600'
                };
                
                this.ctx.fillStyle = colors[node.type] || '#ffffff';
                this.ctx.globalAlpha = 0.2;
                this.ctx.fill();
                
                this.ctx.strokeStyle = colors[node.type] || '#ffffff';
                this.ctx.globalAlpha = node === this.hoveredNode ? 1 : 0.8;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Icon or symbol
                this.ctx.fillStyle = colors[node.type] || '#ffffff';
                this.ctx.font = '20px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                const icons = {
                    ai: '🤖',
                    data: '📊',
                    contracts: '📜',
                    visual: '👁️',
                    orchestration: '🎭'
                };
                
                this.ctx.fillText(icons[node.type] || '⬤', node.x, node.y);
                
                // Label
                this.ctx.font = '12px Courier New';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillText(node.label, node.x, node.y + node.radius + 15);
                
                this.ctx.globalAlpha = 1;
            }
            
            updateParticles() {
                this.connections.forEach(conn => {
                    const fromNode = this.nodes.get(conn.from);
                    const toNode = this.nodes.get(conn.to);
                    
                    if (!fromNode || !toNode) return;
                    
                    conn.particles = conn.particles.filter(particle => {
                        particle.progress += particle.speed;
                        
                        if (particle.progress >= 1) {
                            return false; // Remove particle
                        }
                        
                        // Calculate position along curve
                        const t = particle.progress;
                        const cx = (fromNode.x + toNode.x) / 2;
                        const cy = (fromNode.y + toNode.y) / 2 - 50;
                        
                        const x = (1 - t) * (1 - t) * fromNode.x + 
                                 2 * (1 - t) * t * cx + 
                                 t * t * toNode.x;
                        const y = (1 - t) * (1 - t) * fromNode.y + 
                                 2 * (1 - t) * t * cy + 
                                 t * t * toNode.y;
                        
                        // Draw particle
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#0ff';
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#0ff';
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                        
                        return true;
                    });
                    
                    // Add new particles
                    if (Math.random() < 0.02 && conn.particles.length < 3) {
                        conn.particles.push({
                            progress: 0,
                            speed: 0.01 + Math.random() * 0.02
                        });
                    }
                });
            }
        }
        
        // Initialize visualizer
        const visualizer = new WebConnectionVisualizer();
        
        console.log('🌐 Web Connection Visualizer initialized');
        console.log('🔗 Showing how all systems connect');
        console.log('✨ Click nodes for details, use controls to filter');
    </script>
</body>
</html>