<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperCam Multiplayer Arena - Record & Share Your Battles!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        /* Main Game Container */
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at center, #0a0a1a 0%, #000 100%);
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        /* HyperCam Style Watermark */
        .hypercam-watermark {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 5px 10px;
            border: 1px solid #00ff00;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            animation: watermarkBlink 2s infinite;
        }

        @keyframes watermarkBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Recording Status */
        .recording-status {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff0000;
        }

        .rec-dot {
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            animation: recordPulse 1s infinite;
        }

        @keyframes recordPulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Game HUD */
        .game-hud {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        .player-info {
            margin-bottom: 10px;
        }

        .player-name {
            color: #00ffff;
            font-weight: bold;
            font-size: 16px;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
            font-size: 12px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
        }

        .stat-value {
            color: #ffff00;
        }

        /* Multiplayer List */
        .player-list {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        .player-list h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .player-entry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 12px;
        }

        .player-entry.you {
            border: 1px solid #00ff00;
        }

        /* Chat System */
        .chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            font-size: 12px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .chat-input {
            display: flex;
            padding: 5px;
            border-top: 1px solid #00ff88;
        }

        .chat-input input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        /* Recording Controls */
        .recording-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 15px;
        }

        .control-btn {
            background: #ff4444;
            color: #fff;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.2s;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.stop {
            background: #666;
        }

        .control-btn.share {
            background: #00ff88;
            color: #000;
        }

        /* Arena Effects */
        .arena-effect {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: effectFade 1s forwards;
        }

        @keyframes effectFade {
            0% { opacity: 1; transform: scale(0); }
            50% { opacity: 0.5; }
            100% { opacity: 0; transform: scale(3); }
        }

        /* Join Screen */
        .join-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            min-width: 400px;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .join-screen h1 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .join-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .join-form input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        .join-form input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .join-btn {
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s;
        }

        .join-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.4);
        }

        /* Notification System */
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            animation: notificationPop 3s forwards;
            pointer-events: none;
            z-index: 2000;
        }

        @keyframes notificationPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            30% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Hidden for steganography */
        .hidden-data {
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Main Game Canvas -->
        <canvas id="game-canvas"></canvas>

        <!-- HyperCam Watermark -->
        <div class="hypercam-watermark" id="watermark" style="display: none;">
            HyperCam Arena - Unregistered
        </div>

        <!-- Recording Status -->
        <div class="recording-status" id="recording-status" style="display: none;">
            <div class="rec-dot"></div>
            <span>REC</span>
            <span id="rec-timer">00:00</span>
        </div>

        <!-- Game HUD -->
        <div class="game-hud" id="game-hud" style="display: none;">
            <div class="player-info">
                <div class="player-name" id="player-name">Player</div>
                <div class="player-stats">
                    <div class="stat-item">
                        <span>Score:</span>
                        <span class="stat-value" id="player-score">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Kills:</span>
                        <span class="stat-value" id="player-kills">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Deaths:</span>
                        <span class="stat-value" id="player-deaths">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Combo:</span>
                        <span class="stat-value" id="player-combo">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Player List -->
        <div class="player-list" id="player-list" style="display: none;">
            <h3>Players Online: <span id="player-count">0</span></h3>
            <div id="player-entries"></div>
        </div>

        <!-- Chat System -->
        <div class="chat-container" id="chat-container" style="display: none;">
            <div class="chat-messages" id="chat-messages"></div>
            <div class="chat-input">
                <input type="text" id="chat-input" placeholder="Type to chat..." maxlength="100">
            </div>
        </div>

        <!-- Recording Controls -->
        <div class="recording-controls" id="recording-controls" style="display: none;">
            <button class="control-btn" id="start-recording">🔴 Start Recording</button>
            <button class="control-btn stop" id="stop-recording" style="display: none;">⏹️ Stop Recording</button>
            <button class="control-btn share" id="share-clip" style="display: none;">🚀 Share Clip</button>
        </div>

        <!-- Join Screen -->
        <div class="join-screen" id="join-screen">
            <h1>🎮 HyperCam Multiplayer Arena 🎮</h1>
            <form class="join-form" id="join-form">
                <input type="text" id="username-input" placeholder="Enter your name" maxlength="20" required>
                <input type="text" id="room-input" placeholder="Room code (optional)" maxlength="10">
                <button type="submit" class="join-btn">Join Arena</button>
            </form>
            <p style="margin-top: 20px; color: #888; font-size: 12px;">
                Record and share your epic battles!<br>
                Built-in HyperCam recording • Real-time multiplayer • Hidden secrets
            </p>
        </div>

        <!-- Hidden data for steganography -->
        <div class="hidden-data" id="hidden-data"></div>
    </div>

    <script>
        // Game State
        const gameState = {
            canvas: null,
            ctx: null,
            player: null,
            players: new Map(),
            projectiles: [],
            effects: [],
            recording: false,
            recordingStartTime: 0,
            recordingChunks: [],
            mediaRecorder: null,
            stream: null,
            socket: null,
            roomId: null,
            connected: false,
            keys: {},
            mouse: { x: 0, y: 0 },
            camera: { x: 0, y: 0 },
            arenaSize: { width: 2000, height: 2000 },
            gameStarted: false
        };

        // Player class
        class Player {
            constructor(id, name, x, y, color) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.color = color;
                this.size = 20;
                this.health = 100;
                this.score = 0;
                this.kills = 0;
                this.deaths = 0;
                this.combo = 0;
                this.lastShot = 0;
                this.trail = [];
            }

            update() {
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Apply friction
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Keep in bounds
                this.x = Math.max(this.size, Math.min(gameState.arenaSize.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(gameState.arenaSize.height - this.size, this.y));

                // Update trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
            }

            draw(ctx, offsetX, offsetY) {
                // Draw trail
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x - offsetX, point.y - offsetY);
                    } else {
                        ctx.lineTo(point.x - offsetX, point.y - offsetY);
                    }
                });
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Draw player
                ctx.save();
                ctx.translate(this.x - offsetX, this.y - offsetY);
                ctx.rotate(this.angle);

                // Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.size + 5, 0);
                ctx.stroke();

                ctx.restore();

                // Draw name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x - offsetX, this.y - offsetY - this.size - 10);

                // Draw health bar
                const barWidth = 40;
                const barHeight = 4;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x - offsetX - barWidth/2, this.y - offsetY + this.size + 5, barWidth, barHeight);
                
                ctx.fillStyle = this.health > 50 ? '#00ff00' : this.health > 25 ? '#ffaa00' : '#ff0000';
                ctx.fillRect(this.x - offsetX - barWidth/2, this.y - offsetY + this.size + 5, (this.health / 100) * barWidth, barHeight);
            }

            shoot(targetX, targetY) {
                const now = Date.now();
                if (now - this.lastShot < 200) return; // Rate limit

                this.lastShot = now;
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                
                return {
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * 15,
                    vy: Math.sin(angle) * 15,
                    owner: this.id,
                    color: this.color,
                    damage: 10
                };
            }
        }

        // Initialize game
        function initGame() {
            gameState.canvas = document.getElementById('game-canvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupEventListeners();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            gameState.canvas.width = window.innerWidth;
            gameState.canvas.height = window.innerHeight;
        }

        function setupEventListeners() {
            // Join form
            document.getElementById('join-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const username = document.getElementById('username-input').value.trim();
                const roomCode = document.getElementById('room-input').value.trim() || 'default';
                
                if (username) {
                    joinGame(username, roomCode);
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key.toLowerCase()] = true;
                
                if (e.key === 'Enter' && gameState.gameStarted) {
                    document.getElementById('chat-input').focus();
                }
            });

            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key.toLowerCase()] = false;
            });

            // Mouse controls
            document.addEventListener('mousemove', (e) => {
                gameState.mouse.x = e.clientX;
                gameState.mouse.y = e.clientY;
            });

            document.addEventListener('click', (e) => {
                if (gameState.gameStarted && gameState.player && e.target.id === 'game-canvas') {
                    shoot();
                }
            });

            // Chat input
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const input = e.target;
                    const message = input.value.trim();
                    
                    if (message && gameState.connected) {
                        sendChatMessage(message);
                        input.value = '';
                    }
                    
                    input.blur();
                }
            });

            // Recording controls
            document.getElementById('start-recording').addEventListener('click', startRecording);
            document.getElementById('stop-recording').addEventListener('click', stopRecording);
            document.getElementById('share-clip').addEventListener('click', shareClip);
        }

        function joinGame(username, roomCode) {
            // Create local player
            const playerId = 'player_' + Date.now();
            const color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            const x = Math.random() * gameState.arenaSize.width;
            const y = Math.random() * gameState.arenaSize.height;
            
            gameState.player = new Player(playerId, username, x, y, color);
            gameState.players.set(playerId, gameState.player);
            gameState.roomId = roomCode;
            
            // Hide join screen, show game UI
            document.getElementById('join-screen').style.display = 'none';
            document.getElementById('game-hud').style.display = 'block';
            document.getElementById('player-list').style.display = 'block';
            document.getElementById('chat-container').style.display = 'block';
            document.getElementById('recording-controls').style.display = 'block';
            
            // Update player info
            document.getElementById('player-name').textContent = username;
            
            // Start game
            gameState.gameStarted = true;
            
            // Simulate connection (in real implementation, connect to WebSocket server)
            simulateMultiplayer();
            
            showNotification(`Welcome to the arena, ${username}!`);
        }

        function simulateMultiplayer() {
            // Simulate other players joining
            setTimeout(() => {
                addBot('NoobMaster69', '#ff4444');
                showNotification('NoobMaster69 joined the game');
            }, 2000);
            
            setTimeout(() => {
                addBot('xXx_Sniper_xXx', '#44ff44');
                showNotification('xXx_Sniper_xXx joined the game');
            }, 4000);
            
            setTimeout(() => {
                addBot('ProGamer2024', '#4444ff');
                showNotification('ProGamer2024 joined the game');
            }, 6000);
            
            gameState.connected = true;
            updatePlayerList();
        }

        function addBot(name, color) {
            const botId = 'bot_' + Date.now() + '_' + name;
            const x = Math.random() * gameState.arenaSize.width;
            const y = Math.random() * gameState.arenaSize.height;
            
            const bot = new Player(botId, name, x, y, color);
            bot.isBot = true;
            gameState.players.set(botId, bot);
        }

        function updatePlayer() {
            if (!gameState.player) return;
            
            // Movement
            const speed = 5;
            if (gameState.keys['w'] || gameState.keys['arrowup']) gameState.player.vy -= speed;
            if (gameState.keys['s'] || gameState.keys['arrowdown']) gameState.player.vy += speed;
            if (gameState.keys['a'] || gameState.keys['arrowleft']) gameState.player.vx -= speed;
            if (gameState.keys['d'] || gameState.keys['arrowright']) gameState.player.vx += speed;
            
            // Update angle based on mouse
            const mouseWorldX = gameState.mouse.x + gameState.camera.x;
            const mouseWorldY = gameState.mouse.y + gameState.camera.y;
            gameState.player.angle = Math.atan2(
                mouseWorldY - gameState.player.y,
                mouseWorldX - gameState.player.x
            );
            
            gameState.player.update();
            
            // Update camera to follow player
            gameState.camera.x = gameState.player.x - gameState.canvas.width / 2;
            gameState.camera.y = gameState.player.y - gameState.canvas.height / 2;
            
            // Keep camera in bounds
            gameState.camera.x = Math.max(0, Math.min(gameState.arenaSize.width - gameState.canvas.width, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(gameState.arenaSize.height - gameState.canvas.height, gameState.camera.y));
        }

        function updateBots() {
            gameState.players.forEach(player => {
                if (player.isBot) {
                    // Simple AI behavior
                    if (Math.random() < 0.02) {
                        player.vx = (Math.random() - 0.5) * 10;
                        player.vy = (Math.random() - 0.5) * 10;
                    }
                    
                    // Random shooting
                    if (Math.random() < 0.01) {
                        const targetPlayer = gameState.player;
                        if (targetPlayer) {
                            const projectile = player.shoot(targetPlayer.x, targetPlayer.y);
                            if (projectile) {
                                gameState.projectiles.push(projectile);
                            }
                        }
                    }
                    
                    player.angle += 0.05;
                    player.update();
                }
            });
        }

        function shoot() {
            const worldX = gameState.mouse.x + gameState.camera.x;
            const worldY = gameState.mouse.y + gameState.camera.y;
            
            const projectile = gameState.player.shoot(worldX, worldY);
            if (projectile) {
                gameState.projectiles.push(projectile);
                
                // Add shooting effect
                addEffect(gameState.player.x, gameState.player.y, gameState.player.color);
            }
        }

        function updateProjectiles() {
            gameState.projectiles = gameState.projectiles.filter(projectile => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                
                // Check bounds
                if (projectile.x < 0 || projectile.x > gameState.arenaSize.width ||
                    projectile.y < 0 || projectile.y > gameState.arenaSize.height) {
                    return false;
                }
                
                // Check collisions
                let hit = false;
                gameState.players.forEach(player => {
                    if (player.id !== projectile.owner) {
                        const dx = player.x - projectile.x;
                        const dy = player.y - projectile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < player.size) {
                            // Hit!
                            player.health -= projectile.damage;
                            addEffect(player.x, player.y, '#ff0000');
                            
                            if (player.health <= 0) {
                                handlePlayerDeath(player, projectile.owner);
                            }
                            
                            hit = true;
                        }
                    }
                });
                
                return !hit;
            });
        }

        function handlePlayerDeath(player, killerId) {
            player.deaths++;
            player.health = 100;
            player.x = Math.random() * gameState.arenaSize.width;
            player.y = Math.random() * gameState.arenaSize.height;
            
            const killer = gameState.players.get(killerId);
            if (killer) {
                killer.kills++;
                killer.score += 100;
                killer.combo++;
                
                showNotification(`${killer.name} eliminated ${player.name}!`);
                
                if (killer.id === gameState.player.id) {
                    updateStats();
                }
            }
            
            if (player.id === gameState.player.id) {
                gameState.player.combo = 0;
                updateStats();
            }
        }

        function updateStats() {
            document.getElementById('player-score').textContent = gameState.player.score;
            document.getElementById('player-kills').textContent = gameState.player.kills;
            document.getElementById('player-deaths').textContent = gameState.player.deaths;
            document.getElementById('player-combo').textContent = gameState.player.combo;
        }

        function updatePlayerList() {
            const playerEntries = document.getElementById('player-entries');
            playerEntries.innerHTML = '';
            
            const playerArray = Array.from(gameState.players.values());
            playerArray.sort((a, b) => b.score - a.score);
            
            playerArray.forEach(player => {
                const entry = document.createElement('div');
                entry.className = 'player-entry';
                if (player.id === gameState.player.id) {
                    entry.className += ' you';
                }
                
                entry.innerHTML = `
                    <span>${player.name}</span>
                    <span>${player.score}</span>
                `;
                
                playerEntries.appendChild(entry);
            });
            
            document.getElementById('player-count').textContent = playerArray.length;
        }

        function addEffect(x, y, color) {
            gameState.effects.push({
                x,
                y,
                color,
                size: 10,
                life: 1,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5
            });
        }

        function updateEffects() {
            gameState.effects = gameState.effects.filter(effect => {
                effect.x += effect.vx;
                effect.y += effect.vy;
                effect.life -= 0.02;
                effect.size += 0.5;
                
                return effect.life > 0;
            });
        }

        function drawBackground(ctx) {
            // Draw grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = -gameState.camera.x % gridSize;
            const startY = -gameState.camera.y % gridSize;
            
            for (let x = startX; x < ctx.canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, ctx.canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < ctx.canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(ctx.canvas.width, y);
                ctx.stroke();
            }
            
            // Draw arena bounds
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 3;
            ctx.strokeRect(-gameState.camera.x, -gameState.camera.y, gameState.arenaSize.width, gameState.arenaSize.height);
        }

        function drawGame() {
            const ctx = gameState.ctx;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (!gameState.gameStarted) return;
            
            // Draw background
            drawBackground(ctx);
            
            // Draw effects
            gameState.effects.forEach(effect => {
                ctx.globalAlpha = effect.life;
                ctx.fillStyle = effect.color;
                ctx.beginPath();
                ctx.arc(effect.x - gameState.camera.x, effect.y - gameState.camera.y, effect.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw projectiles
            gameState.projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x - gameState.camera.x, projectile.y - gameState.camera.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw players
            gameState.players.forEach(player => {
                player.draw(ctx, gameState.camera.x, gameState.camera.y);
            });
            
            // Draw minimap
            drawMinimap(ctx);
        }

        function drawMinimap(ctx) {
            const minimapSize = 150;
            const minimapX = ctx.canvas.width - minimapSize - 10;
            const minimapY = ctx.canvas.height - minimapSize - 10;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(minimapX, minimapY, minimapSize, minimapSize);
            
            // Border
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(minimapX, minimapY, minimapSize, minimapSize);
            
            // Players
            gameState.players.forEach(player => {
                const x = minimapX + (player.x / gameState.arenaSize.width) * minimapSize;
                const y = minimapY + (player.y / gameState.arenaSize.height) * minimapSize;
                
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                if (player.id === gameState.player.id) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
        }

        function gameLoop(timestamp) {
            // Update game state
            updatePlayer();
            updateBots();
            updateProjectiles();
            updateEffects();
            
            // Update UI
            if (gameState.gameStarted && Math.random() < 0.01) {
                updatePlayerList();
            }
            
            // Draw everything
            drawGame();
            
            // Update recording timer
            if (gameState.recording) {
                const elapsed = Date.now() - gameState.recordingStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('rec-timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            requestAnimationFrame(gameLoop);
        }

        function sendChatMessage(message) {
            // Add to local chat
            addChatMessage(gameState.player.name, message, gameState.player.color);
            
            // In real implementation, send to server
            // For demo, simulate bot responses
            if (message.toLowerCase().includes('hello')) {
                setTimeout(() => {
                    const bot = Array.from(gameState.players.values()).find(p => p.isBot);
                    if (bot) {
                        addChatMessage(bot.name, 'hey there!', bot.color);
                    }
                }, 1000);
            }
        }

        function addChatMessage(sender, message, color) {
            const chatMessages = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.innerHTML = `<span style="color: ${color}">${sender}:</span> ${message}`;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Remove old messages
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }

        function showNotification(text) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = text;
            document.getElementById('game-container').appendChild(notification);
            
            setTimeout(() => notification.remove(), 3000);
        }

        // Recording functions
        async function startRecording() {
            try {
                // Request screen capture
                gameState.stream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        mediaSource: 'screen',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                });

                // Create media recorder
                gameState.recordingChunks = [];
                gameState.mediaRecorder = new MediaRecorder(gameState.stream, {
                    mimeType: 'video/webm;codecs=vp8'
                });

                gameState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        gameState.recordingChunks.push(event.data);
                    }
                };

                gameState.mediaRecorder.onstop = processRecording;

                // Start recording
                gameState.mediaRecorder.start(100);
                gameState.recording = true;
                gameState.recordingStartTime = Date.now();

                // Update UI
                document.getElementById('watermark').style.display = 'block';
                document.getElementById('recording-status').style.display = 'flex';
                document.getElementById('start-recording').style.display = 'none';
                document.getElementById('stop-recording').style.display = 'inline-block';

                // Add recording data for steganography
                embedRecordingData();

                showNotification('Recording started!');
            } catch (error) {
                console.error('Error starting recording:', error);
                showNotification('Failed to start recording');
            }
        }

        function stopRecording() {
            if (gameState.mediaRecorder && gameState.recording) {
                gameState.mediaRecorder.stop();
                gameState.stream.getTracks().forEach(track => track.stop());
                gameState.recording = false;

                // Update UI
                document.getElementById('watermark').style.display = 'none';
                document.getElementById('recording-status').style.display = 'none';
                document.getElementById('stop-recording').style.display = 'none';
                document.getElementById('start-recording').style.display = 'inline-block';

                showNotification('Recording stopped!');
            }
        }

        function processRecording() {
            const blob = new Blob(gameState.recordingChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            a.href = url;
            a.download = `hypercam-arena-${Date.now()}.webm`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Show share button
            document.getElementById('share-clip').style.display = 'inline-block';
            gameState.lastRecordingURL = url;
            
            showNotification('Recording saved!');
        }

        function shareClip() {
            if (gameState.lastRecordingURL) {
                // In a real implementation, this would upload to a server
                showNotification('Clip shared! (Demo mode - no actual upload)');
                
                // Add to hidden data
                const hiddenData = document.getElementById('hidden-data');
                hiddenData.innerHTML += `<div>Shared clip: ${gameState.player.name} - Score: ${gameState.player.score}</div>`;
            }
        }

        function embedRecordingData() {
            // Embed game data in canvas for steganography
            const data = {
                player: gameState.player.name,
                roomId: gameState.roomId,
                timestamp: Date.now(),
                stats: {
                    score: gameState.player.score,
                    kills: gameState.player.kills,
                    deaths: gameState.player.deaths
                }
            };
            
            // Convert to binary and hide in canvas pixels (simplified)
            const jsonStr = JSON.stringify(data);
            const hiddenDiv = document.getElementById('hidden-data');
            hiddenDiv.textContent = jsonStr;
        }

        // Initialize the game
        initGame();
    </script>
</body>
</html>