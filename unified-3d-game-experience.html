<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ UNIFIED 3D GAME EXPERIENCE - All Perspectives + AI Copilot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at center, #001122, #000000);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
        }

        .main-container {
            display: grid;
            grid-template-areas: 
                "perspective-panel game-arena ai-panel"
                "controls game-arena chat-panel";
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: 1fr 1fr;
            height: 100vh;
            gap: 5px;
            padding: 5px;
        }

        .perspective-panel {
            grid-area: perspective-panel;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }

        .game-arena {
            grid-area: game-arena;
            background: rgba(0, 10, 20, 0.95);
            border: 3px solid #00ff88;
            border-radius: 15px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-panel {
            grid-area: ai-panel;
            background: rgba(40, 0, 20, 0.9);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }

        .controls {
            grid-area: controls;
            background: rgba(20, 20, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }

        .chat-panel {
            grid-area: chat-panel;
            background: rgba(20, 0, 40, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        #gameCanvas {
            width: 100%;
            height: 70%;
            background: linear-gradient(45deg, #002244, #004488);
            border: 2px solid #00ffff;
            border-radius: 10px;
            cursor: crosshair;
        }

        .hud-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 60px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            font-size: 14px;
        }

        .perspective-btn {
            background: linear-gradient(45deg, #003366, #0066cc);
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 12px;
            margin: 3px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            text-align: left;
            font-family: inherit;
            font-size: 11px;
        }

        .perspective-btn:hover {
            background: linear-gradient(45deg, #0066cc, #0099ff);
            border-color: #00ffff;
            transform: translateX(5px);
        }

        .perspective-btn.active {
            background: linear-gradient(45deg, #006600, #00cc00);
            border-color: #ffff00;
            color: #ffffff;
            font-weight: bold;
        }

        .ai-command-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: inherit;
        }

        .ai-suggestions {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }

        .suggestion-item {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid #ff4444;
            padding: 5px;
            margin: 3px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .suggestion-item:hover {
            background: rgba(255, 68, 68, 0.3);
        }

        .chat-messages {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff00ff;
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            max-height: 200px;
            margin-bottom: 10px;
        }

        .chat-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            padding: 8px;
            border-radius: 5px;
            font-family: inherit;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .control-btn {
            background: linear-gradient(45deg, #664400, #cc8800);
            border: 1px solid #ffff00;
            color: #ffff00;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(45deg, #cc8800, #ffaa00);
            transform: scale(1.05);
        }

        .recording-indicator {
            color: #ff0000;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .status-text {
            font-size: 11px;
            margin: 2px 0;
            opacity: 0.8;
        }

        .room-link {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 5px;
            border-radius: 3px;
            margin: 5px 0;
            word-break: break-all;
            font-size: 10px;
        }

        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 5px;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 1px solid #ffffff;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.7;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #ffffff;
        }

        .crosshair::before {
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            width: 1px;
            height: 100%;
        }

        .crosshair::after {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            height: 1px;
            width: 100%;
        }

        h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 3px;
        }

        .entity-list {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            margin: 5px 0;
        }

        .entity-item {
            font-size: 10px;
            margin: 2px 0;
            padding: 2px 5px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 3D Perspective Panel -->
        <div class="perspective-panel">
            <h3>üé• 3D PERSPECTIVES</h3>
            
            <button class="perspective-btn" onclick="switchPerspective('sonar')" id="btn-sonar">
                üåä SONAR/SUBMARINE
            </button>
            <button class="perspective-btn" onclick="switchPerspective('aerial')" id="btn-aerial">
                üõ∞Ô∏è AERIAL/SATELLITE
            </button>
            <button class="perspective-btn active" onclick="switchPerspective('first-person')" id="btn-first-person">
                üëÅÔ∏è FIRST PERSON
            </button>
            <button class="perspective-btn" onclick="switchPerspective('third-person')" id="btn-third-person">
                üìπ THIRD PERSON
            </button>
            <button class="perspective-btn" onclick="switchPerspective('cinematic')" id="btn-cinematic">
                üé¨ CINEMATIC
            </button>
            <button class="perspective-btn" onclick="switchPerspective('tactical')" id="btn-tactical">
                üìã TACTICAL
            </button>
            <button class="perspective-btn" onclick="switchPerspective('drone')" id="btn-drone">
                üöÅ DRONE
            </button>
            <button class="perspective-btn" onclick="switchPerspective('spectator')" id="btn-spectator">
                üëª SPECTATOR
            </button>
            <button class="perspective-btn" onclick="switchPerspective('vr')" id="btn-vr">
                ü•Ω VR MODE
            </button>
            <button class="perspective-btn" onclick="switchPerspective('microscope')" id="btn-microscope">
                üî¨ MICROSCOPE
            </button>

            <div class="status-text">Current: <span id="current-perspective">FIRST PERSON</span></div>
            <div class="status-text">Transition: <span id="transition-status">Ready</span></div>
            <div class="status-text">Entities: <span id="entity-count">0</span></div>
        </div>

        <!-- Main Game Arena -->
        <div class="game-arena">
            <div class="hud-overlay">
                <div>
                    <span>ROOM: <span id="room-id">Loading...</span></span> | 
                    <span>PLAYERS: <span id="player-count">1</span></span>
                </div>
                <div>
                    <span>FPS: <span id="fps-counter">60</span></span> | 
                    <span>PING: <span id="ping-display">0ms</span></span>
                </div>
                <div>
                    <span id="recording-status">‚ö´ READY</span>
                </div>
            </div>

            <canvas id="gameCanvas"></canvas>
            
            <div class="crosshair"></div>
            <div class="minimap" id="minimap"></div>

            <div style="padding: 10px; background: rgba(0,0,0,0.7); border-top: 1px solid #00ff88;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="room-link">
                        Share Link: <span id="share-link">Generating...</span>
                    </div>
                    <button onclick="copyShareLink()" class="control-btn">üìã COPY</button>
                    <button onclick="inviteFriend()" class="control-btn">üë• INVITE</button>
                </div>
            </div>
        </div>

        <!-- AI Copilot Panel -->
        <div class="ai-panel">
            <h3>ü§ñ AI COPILOT</h3>
            
            <input 
                type="text" 
                class="ai-command-input" 
                id="ai-command" 
                placeholder="Tell AI copilot what to do..."
                onkeydown="handleAICommand(event)"
            >
            
            <button onclick="processAICommand()" class="control-btn" style="width: 100%; margin: 5px 0;">
                üéØ EXECUTE COMMAND
            </button>

            <div class="status-text">AI Mode: <span id="ai-mode">ASSIST</span></div>
            <div class="status-text">Tracking: <span id="tracking-count">0</span> entities</div>
            <div class="status-text">Suggestions: <span id="suggestion-count">0</span></div>

            <div class="ai-suggestions" id="ai-suggestions">
                <div class="suggestion-item" onclick="executeAISuggestion('follow closest entity')">
                    üéØ Follow closest entity
                </div>
                <div class="suggestion-item" onclick="executeAISuggestion('suggest best view')">
                    üëÅÔ∏è Suggest best view
                </div>
                <div class="suggestion-item" onclick="executeAISuggestion('cinematic mode')">
                    üé¨ Enable cinematic mode
                </div>
                <div class="suggestion-item" onclick="executeAISuggestion('strategic overview')">
                    üìã Strategic overview
                </div>
            </div>

            <div class="entity-list" id="entity-list">
                <div class="entity-item">No entities detected</div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls">
            <h3>üéÆ GAME CONTROLS</h3>
            
            <div class="controls-grid">
                <button class="control-btn" onclick="startRecording()">üé• RECORD</button>
                <button class="control-btn" onclick="stopRecording()">‚èπÔ∏è STOP</button>
                <button class="control-btn" onclick="takeScreenshot()">üì∏ SCREENSHOT</button>
                <button class="control-btn" onclick="fullscreen()">üñ•Ô∏è FULLSCREEN</button>
                <button class="control-btn" onclick="resetView()">üîÑ RESET VIEW</button>
                <button class="control-btn" onclick="toggleAI()">ü§ñ TOGGLE AI</button>
                <button class="control-btn" onclick="respawnPlayer()">üí• RESPAWN</button>
                <button class="control-btn" onclick="randomGame()">üé≤ RANDOM</button>
            </div>

            <div class="status-text">Movement: WASD / Arrow Keys</div>
            <div class="status-text">Shoot: Click / Space</div>
            <div class="status-text">Zoom: Mouse Wheel</div>
            <div class="status-text">Special: E / Enter</div>
        </div>

        <!-- Chat Panel -->
        <div class="chat-panel">
            <h3>üí¨ MULTIPLAYER CHAT</h3>
            
            <div class="chat-messages" id="chat-messages">
                <div style="color: #00ff00;">üéÆ Welcome to Unified 3D Game Arena!</div>
                <div style="color: #ffff00;">ü§ñ AI Copilot is ready for commands</div>
                <div style="color: #00ffff;">üé• All perspective systems online</div>
            </div>
            
            <input 
                type="text" 
                class="chat-input" 
                id="chat-input" 
                placeholder="Type message or AI command..."
                onkeydown="handleChatInput(event)"
            >

            <div style="margin-top: 10px;">
                <div class="status-text">Online Players: <span id="online-count">1</span></div>
                <div class="status-text">Messages: <span id="message-count">0</span></div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // UNIFIED 3D GAME EXPERIENCE CONTROLLER
        // ========================================

        class Unified3DGameExperience {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Resize canvas
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Game state
                this.players = new Map();
                this.entities = new Map();
                this.projectiles = [];
                this.particles = [];
                this.gameState = 'playing';
                
                // Current perspective
                this.currentPerspective = 'first-person';
                this.perspectiveTransitioning = false;
                
                // Camera state
                this.camera = {
                    x: 0, y: 0, z: 0,
                    rotation: { x: 0, y: 0, z: 0 },
                    fov: 75,
                    zoom: 1
                };
                
                // AI Copilot
                this.aiCopilot = {
                    enabled: true,
                    mode: 'assist',
                    tracking: new Set(),
                    suggestions: []
                };
                
                // Recording
                this.recording = {
                    active: false,
                    chunks: [],
                    mediaRecorder: null
                };
                
                // Multiplayer
                this.roomId = this.generateRoomId();
                this.playerId = this.generatePlayerId();
                this.localPlayer = null;
                
                // WebSocket connections
                this.gameWS = null;
                this.orchestratorWS = null;
                
                // Initialize all systems
                this.init();
            }
            
            async init() {
                console.log('üéÆ Initializing Unified 3D Game Experience...');
                
                // Setup canvas events
                this.setupCanvasEvents();
                
                // Setup keyboard controls
                this.setupKeyboardControls();
                
                // Connect to orchestrator
                await this.connectToOrchestrator();
                
                // Connect to game systems
                await this.connectToGameSystems();
                
                // Create local player
                this.createLocalPlayer();
                
                // Start game loops
                this.startGameLoops();
                
                // Update UI
                this.updateUI();
                
                console.log('‚úÖ Unified 3D Game Experience ready!');
                console.log(`üéØ Room ID: ${this.roomId}`);
                console.log(`üë§ Player ID: ${this.playerId}`);
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            setupCanvasEvents() {
                // Mouse controls
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('wheel', (e) => this.handleMouseWheel(e));
                
                // Touch controls for mobile
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
            }
            
            setupKeyboardControls() {
                // Movement keys
                this.keys = new Set();
                
                document.addEventListener('keydown', (e) => {
                    this.keys.add(e.code);
                    this.handleKeyDown(e);
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys.delete(e.code);
                });
            }
            
            async connectToOrchestrator() {
                try {
                    this.orchestratorWS = new WebSocket('ws://localhost:47010');
                    
                    this.orchestratorWS.onopen = () => {
                        console.log('‚úÖ Connected to 3D Perspective Orchestrator');
                        this.updateStatus('orchestrator', 'Connected');
                    };
                    
                    this.orchestratorWS.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleOrchestratorMessage(data);
                    };
                    
                    this.orchestratorWS.onerror = () => {
                        console.log('‚ö†Ô∏è Orchestrator connection failed - running standalone');
                        this.updateStatus('orchestrator', 'Standalone');
                    };
                } catch (error) {
                    console.log('Running without orchestrator');
                }
            }
            
            async connectToGameSystems() {
                try {
                    this.gameWS = new WebSocket('ws://localhost:47005');
                    
                    this.gameWS.onopen = () => {
                        console.log('‚úÖ Connected to game systems');
                        
                        // Join room
                        this.sendGameMessage({
                            type: 'join-room',
                            roomId: this.roomId,
                            playerId: this.playerId
                        });
                    };
                    
                    this.gameWS.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleGameMessage(data);
                    };
                    
                    this.gameWS.onerror = () => {
                        console.log('‚ö†Ô∏è Game connection failed - local mode');
                    };
                } catch (error) {
                    console.log('Running in local mode');
                }
            }
            
            createLocalPlayer() {
                this.localPlayer = {
                    id: this.playerId,
                    x: Math.random() * 400 + 200,
                    y: Math.random() * 300 + 150,
                    z: 0,
                    rotation: 0,
                    health: 100,
                    score: 0,
                    color: this.generatePlayerColor(),
                    velocity: { x: 0, y: 0, z: 0 }
                };
                
                this.players.set(this.playerId, this.localPlayer);
                
                // Update camera to follow player
                this.updateCameraForPerspective();
            }
            
            startGameLoops() {
                // Main game loop (60 FPS)
                setInterval(() => this.update(), 16);
                
                // Render loop
                setInterval(() => this.render(), 16);
                
                // Network sync (20 FPS)
                setInterval(() => this.syncNetwork(), 50);
                
                // UI updates (10 FPS)
                setInterval(() => this.updateUI(), 100);
                
                // AI analysis (2 FPS)
                setInterval(() => this.updateAI(), 500);
            }
            
            update() {
                // Update local player
                this.updateLocalPlayer();
                
                // Update entities
                this.updateEntities();
                
                // Update projectiles
                this.updateProjectiles();
                
                // Update particles
                this.updateParticles();
                
                // Update camera
                this.updateCamera();
                
                // Update AI tracking
                this.updateAITracking();
            }
            
            updateLocalPlayer() {
                if (!this.localPlayer) return;
                
                const speed = 5;
                let moved = false;
                
                // Handle movement based on current perspective
                if (this.keys.has('KeyW') || this.keys.has('ArrowUp')) {
                    this.movePlayerForward(speed);
                    moved = true;
                }
                if (this.keys.has('KeyS') || this.keys.has('ArrowDown')) {
                    this.movePlayerForward(-speed);
                    moved = true;
                }
                if (this.keys.has('KeyA') || this.keys.has('ArrowLeft')) {
                    this.movePlayerStrafe(-speed);
                    moved = true;
                }
                if (this.keys.has('KeyD') || this.keys.has('ArrowRight')) {
                    this.movePlayerStrafe(speed);
                    moved = true;
                }
                
                // Bounds checking
                this.localPlayer.x = Math.max(0, Math.min(this.canvas.width, this.localPlayer.x));
                this.localPlayer.y = Math.max(0, Math.min(this.canvas.height, this.localPlayer.y));
                
                if (moved) {
                    this.broadcastPlayerUpdate();
                }
            }
            
            movePlayerForward(speed) {
                const angle = this.camera.rotation.y;
                this.localPlayer.x += Math.sin(angle) * speed;
                this.localPlayer.z += Math.cos(angle) * speed;
            }
            
            movePlayerStrafe(speed) {
                const angle = this.camera.rotation.y + Math.PI / 2;
                this.localPlayer.x += Math.sin(angle) * speed;
                this.localPlayer.z += Math.cos(angle) * speed;
            }
            
            updateEntities() {
                // Update all entities
                this.entities.forEach((entity, id) => {
                    if (entity.velocity) {
                        entity.x += entity.velocity.x;
                        entity.y += entity.velocity.y;
                        entity.z += entity.velocity.z;
                    }
                    
                    // Add some random movement for demo
                    if (Math.random() < 0.01) {
                        entity.velocity = {
                            x: (Math.random() - 0.5) * 2,
                            y: (Math.random() - 0.5) * 2,
                            z: (Math.random() - 0.5) * 2
                        };
                    }
                });
            }
            
            updateProjectiles() {
                this.projectiles = this.projectiles.filter(projectile => {
                    projectile.x += projectile.velocity.x;
                    projectile.y += projectile.velocity.y;
                    projectile.z += projectile.velocity.z;
                    
                    projectile.life--;
                    return projectile.life > 0;
                });
            }
            
            updateParticles() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.velocity.x;
                    particle.y += particle.velocity.y;
                    particle.z += particle.velocity.z;
                    
                    particle.velocity.y += 0.1; // Gravity
                    particle.life--;
                    particle.alpha = particle.life / particle.maxLife;
                    
                    return particle.life > 0;
                });
            }
            
            updateCamera() {
                if (!this.localPlayer) return;
                
                // Update camera based on current perspective
                switch (this.currentPerspective) {
                    case 'first-person':
                        this.camera.x = this.localPlayer.x;
                        this.camera.y = this.localPlayer.y - 30; // Eye height
                        this.camera.z = this.localPlayer.z;
                        break;
                        
                    case 'third-person':
                        const followDistance = 50;
                        const followHeight = 30;
                        const angle = this.camera.rotation.y;
                        
                        this.camera.x = this.localPlayer.x - Math.sin(angle) * followDistance;
                        this.camera.y = this.localPlayer.y - followHeight;
                        this.camera.z = this.localPlayer.z - Math.cos(angle) * followDistance;
                        break;
                        
                    case 'aerial':
                        this.camera.x = this.localPlayer.x;
                        this.camera.y = this.localPlayer.y - 200; // High above
                        this.camera.z = this.localPlayer.z;
                        this.camera.rotation.x = -Math.PI / 2; // Look down
                        break;
                        
                    case 'cinematic':
                        // Smooth orbital movement
                        const time = Date.now() * 0.001;
                        const radius = 80;
                        this.camera.x = this.localPlayer.x + Math.sin(time) * radius;
                        this.camera.y = this.localPlayer.y - 40;
                        this.camera.z = this.localPlayer.z + Math.cos(time) * radius;
                        break;
                        
                    case 'sonar':
                        // Underwater perspective with drift
                        this.camera.x = this.localPlayer.x + Math.sin(Date.now() * 0.0001) * 2;
                        this.camera.y = this.localPlayer.y + 20; // Below water level
                        this.camera.z = this.localPlayer.z + Math.cos(Date.now() * 0.0001) * 2;
                        break;
                }
            }
            
            updateAITracking() {
                if (!this.aiCopilot.enabled) return;
                
                // Update tracking count
                document.getElementById('tracking-count').textContent = this.aiCopilot.tracking.size;
                
                // Send tracking data to orchestrator
                if (this.orchestratorWS && this.orchestratorWS.readyState === WebSocket.OPEN) {
                    this.orchestratorWS.send(JSON.stringify({
                        type: 'update-entity',
                        entity: {
                            id: this.playerId,
                            type: 'player',
                            position: {
                                x: this.localPlayer.x,
                                y: this.localPlayer.y,
                                z: this.localPlayer.z
                            },
                            velocity: this.localPlayer.velocity,
                            health: this.localPlayer.health
                        }
                    }));
                }
            }
            
            updateAI() {
                // Generate AI suggestions based on game state
                if (this.aiCopilot.enabled) {
                    this.generateAISuggestions();
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = this.getPerspectiveBackground();
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render based on current perspective
                switch (this.currentPerspective) {
                    case 'sonar':
                        this.renderSonarView();
                        break;
                    case 'aerial':
                        this.renderAerialView();
                        break;
                    case 'microscope':
                        this.renderMicroscopeView();
                        break;
                    default:
                        this.renderStandardView();
                }
                
                // Render UI elements
                this.renderUIElements();
            }
            
            getPerspectiveBackground() {
                switch (this.currentPerspective) {
                    case 'sonar':
                        return 'radial-gradient(circle, #001133, #000011)';
                    case 'aerial':
                        return 'linear-gradient(to bottom, #87CEEB, #98FB98)';
                    case 'microscope':
                        return 'radial-gradient(circle, #000000, #333333)';
                    case 'vr':
                        return 'linear-gradient(45deg, #FF00FF, #00FFFF)';
                    default:
                        return 'linear-gradient(45deg, #002244, #004488)';
                }
            }
            
            renderSonarView() {
                // Sonar-style rendering
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 1;
                
                // Draw sonar circles
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const time = Date.now();
                
                for (let i = 1; i <= 5; i++) {
                    const radius = ((time * 0.1) % 300) + (i * 60);
                    const alpha = 1 - (radius / 300);
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                this.ctx.globalAlpha = 1;
                
                // Draw entities as sonar blips
                this.players.forEach(player => {
                    if (player.id !== this.playerId) {
                        this.renderSonarBlip(player.x, player.y, '#ffff00');
                    }
                });
                
                this.entities.forEach(entity => {
                    this.renderSonarBlip(entity.x, entity.y, '#ff4444');
                });
            }
            
            renderSonarBlip(x, y, color) {
                const screenX = (x / 10) + this.canvas.width / 2;
                const screenY = (y / 10) + this.canvas.height / 2;
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add pulsing effect
                this.ctx.strokeStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, 5 + Math.sin(Date.now() * 0.01) * 2, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            renderAerialView() {
                // Top-down aerial view
                const scale = 0.5; // Zoomed out view
                const offsetX = this.canvas.width / 2 - this.camera.x * scale;
                const offsetY = this.canvas.height / 2 - this.camera.z * scale;
                
                // Draw grid
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.lineWidth = 1;
                
                for (let x = -1000; x <= 1000; x += 100) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX + x * scale, 0);
                    this.ctx.lineTo(offsetX + x * scale, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = -1000; y <= 1000; y += 100) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, offsetY + y * scale);
                    this.ctx.lineTo(this.canvas.width, offsetY + y * scale);
                    this.ctx.stroke();
                }
                
                // Draw players and entities
                this.players.forEach(player => {
                    const x = offsetX + player.x * scale;
                    const y = offsetY + player.z * scale;
                    
                    this.ctx.fillStyle = player.id === this.playerId ? '#00ff00' : player.color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw direction indicator
                    this.ctx.strokeStyle = this.ctx.fillStyle;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y);
                    this.ctx.lineTo(
                        x + Math.sin(player.rotation) * 10,
                        y + Math.cos(player.rotation) * 10
                    );
                    this.ctx.stroke();
                });
            }
            
            renderMicroscopeView() {
                // Extreme close-up view with chromatic aberration
                const zoom = 5;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Draw chromatic aberration effect
                this.ctx.globalAlpha = 0.3;
                
                // Red channel
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(centerX - 50 * zoom, centerY - 50 * zoom, 100 * zoom, 100 * zoom);
                
                // Green channel (offset)
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(centerX - 48 * zoom, centerY - 48 * zoom, 100 * zoom, 100 * zoom);
                
                // Blue channel (offset)
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(centerX - 52 * zoom, centerY - 52 * zoom, 100 * zoom, 100 * zoom);
                
                this.ctx.globalAlpha = 1;
                
                // Draw microscope reticle
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Crosshairs
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - 100, centerY);
                this.ctx.lineTo(centerX + 100, centerY);
                this.ctx.moveTo(centerX, centerY - 100);
                this.ctx.lineTo(centerX, centerY + 100);
                this.ctx.stroke();
            }
            
            renderStandardView() {
                // Standard 3D-style rendering
                const perspective = this.calculatePerspective();
                
                // Draw ground/floor
                this.renderGround(perspective);
                
                // Draw players
                this.players.forEach(player => {
                    if (player.id !== this.playerId || this.currentPerspective === 'third-person') {
                        this.renderPlayer3D(player, perspective);
                    }
                });
                
                // Draw entities
                this.entities.forEach(entity => {
                    this.renderEntity3D(entity, perspective);
                });
                
                // Draw projectiles
                this.projectiles.forEach(projectile => {
                    this.renderProjectile3D(projectile, perspective);
                });
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.renderParticle3D(particle, perspective);
                });
            }
            
            calculatePerspective() {
                return {
                    cameraX: this.camera.x,
                    cameraY: this.camera.y,
                    cameraZ: this.camera.z,
                    rotationX: this.camera.rotation.x,
                    rotationY: this.camera.rotation.y,
                    fov: this.camera.fov,
                    zoom: this.camera.zoom
                };
            }
            
            renderGround(perspective) {
                // Simple grid-based ground
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                const range = 500;
                
                for (let x = -range; x <= range; x += gridSize) {
                    const screenStart = this.project3D(x, 0, -range, perspective);
                    const screenEnd = this.project3D(x, 0, range, perspective);
                    
                    if (screenStart && screenEnd) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenStart.x, screenStart.y);
                        this.ctx.lineTo(screenEnd.x, screenEnd.y);
                        this.ctx.stroke();
                    }
                }
                
                for (let z = -range; z <= range; z += gridSize) {
                    const screenStart = this.project3D(-range, 0, z, perspective);
                    const screenEnd = this.project3D(range, 0, z, perspective);
                    
                    if (screenStart && screenEnd) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenStart.x, screenStart.y);
                        this.ctx.lineTo(screenEnd.x, screenEnd.y);
                        this.ctx.stroke();
                    }
                }
            }
            
            project3D(x, y, z, perspective) {
                // Simple 3D to 2D projection
                const dx = x - perspective.cameraX;
                const dy = y - perspective.cameraY;
                const dz = z - perspective.cameraZ;
                
                // Rotate by camera rotation
                const rotatedX = dx * Math.cos(perspective.rotationY) - dz * Math.sin(perspective.rotationY);
                const rotatedZ = dx * Math.sin(perspective.rotationY) + dz * Math.cos(perspective.rotationY);
                const rotatedY = dy * Math.cos(perspective.rotationX) - rotatedZ * Math.sin(perspective.rotationX);
                const finalZ = dy * Math.sin(perspective.rotationX) + rotatedZ * Math.cos(perspective.rotationX);
                
                if (finalZ <= 0) return null; // Behind camera
                
                const screenX = (rotatedX / finalZ) * perspective.fov * perspective.zoom + this.canvas.width / 2;
                const screenY = (rotatedY / finalZ) * perspective.fov * perspective.zoom + this.canvas.height / 2;
                
                return { x: screenX, y: screenY, z: finalZ };
            }
            
            renderPlayer3D(player, perspective) {
                const screen = this.project3D(player.x, player.y, player.z, perspective);
                if (!screen) return;
                
                const size = Math.max(5, 50 / screen.z);
                
                this.ctx.fillStyle = player.color;
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw health bar
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(screen.x - size, screen.y - size - 10, size * 2, 3);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(screen.x - size, screen.y - size - 10, size * 2 * (player.health / 100), 3);
            }
            
            renderEntity3D(entity, perspective) {
                const screen = this.project3D(entity.x, entity.y, entity.z, perspective);
                if (!screen) return;
                
                const size = Math.max(3, 30 / screen.z);
                
                this.ctx.fillStyle = entity.color || '#ff4444';
                this.ctx.fillRect(screen.x - size/2, screen.y - size/2, size, size);
            }
            
            renderProjectile3D(projectile, perspective) {
                const screen = this.project3D(projectile.x, projectile.y, projectile.z, perspective);
                if (!screen) return;
                
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            renderParticle3D(particle, perspective) {
                const screen = this.project3D(particle.x, particle.y, particle.z, perspective);
                if (!screen) return;
                
                this.ctx.globalAlpha = particle.alpha;
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, 1, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1;
            }
            
            renderUIElements() {
                // Render minimap
                this.renderMinimap();
                
                // Render crosshair for first person
                if (this.currentPerspective === 'first-person') {
                    this.renderCrosshair();
                }
                
                // Render perspective effects
                this.renderPerspectiveEffects();
            }
            
            renderMinimap() {
                const minimap = document.getElementById('minimap');
                const minimapCtx = minimap.getContext ? minimap.getContext('2d') : null;
                
                if (!minimapCtx) {
                    // Create minimap canvas if needed
                    const canvas = document.createElement('canvas');
                    canvas.width = 150;
                    canvas.height = 100;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    minimap.innerHTML = '';
                    minimap.appendChild(canvas);
                    return;
                }
                
                // Clear minimap
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                minimapCtx.fillRect(0, 0, 150, 100);
                
                // Draw players on minimap
                const scale = 0.1;
                const centerX = 75;
                const centerY = 50;
                
                this.players.forEach(player => {
                    const x = centerX + (player.x - this.camera.x) * scale;
                    const y = centerY + (player.z - this.camera.z) * scale;
                    
                    minimapCtx.fillStyle = player.id === this.playerId ? '#00ff00' : player.color;
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                });
            }
            
            renderCrosshair() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 1;
                
                // Crosshair lines
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - 10, centerY);
                this.ctx.lineTo(centerX + 10, centerY);
                this.ctx.moveTo(centerX, centerY - 10);
                this.ctx.lineTo(centerX, centerY + 10);
                this.ctx.stroke();
                
                // Center dot
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 1, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            renderPerspectiveEffects() {
                switch (this.currentPerspective) {
                    case 'sonar':
                        // Add sonar sweep effect
                        this.renderSonarSweep();
                        break;
                        
                    case 'vr':
                        // Add VR barrel distortion
                        this.renderVRDistortion();
                        break;
                        
                    case 'microscope':
                        // Add microscope vignette
                        this.renderMicroscopeVignette();
                        break;
                }
            }
            
            renderSonarSweep() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const angle = (Date.now() * 0.002) % (Math.PI * 2);
                
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(
                    centerX + Math.cos(angle) * 200,
                    centerY + Math.sin(angle) * 200
                );
                this.ctx.stroke();
            }
            
            renderVRDistortion() {
                // Simple barrel distortion effect
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                for (let r = 50; r <= 300; r += 50) {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            renderMicroscopeVignette() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                const gradient = this.ctx.createRadialGradient(
                    centerX, centerY, 100,
                    centerX, centerY, 200
                );
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            // ========================================
            // EVENT HANDLERS
            // ========================================
            
            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Shoot projectile
                this.shootProjectile(x, y);
                
                // Create impact particles
                this.createParticles(x, y);
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Update camera rotation for first person
                if (this.currentPerspective === 'first-person') {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.camera.rotation.y += (x - centerX) * 0.001;
                    this.camera.rotation.x += (y - centerY) * 0.001;
                    
                    // Clamp vertical rotation
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            }
            
            handleMouseWheel(e) {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                this.camera.zoom = Math.max(0.1, Math.min(5, this.camera.zoom * zoomFactor));
                
                this.updateCameraDisplay();
            }
            
            handleKeyDown(e) {
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        this.shootProjectile();
                        break;
                        
                    case 'KeyR':
                        this.respawnPlayer();
                        break;
                        
                    case 'KeyF':
                        this.toggleFullscreen();
                        break;
                        
                    case 'Tab':
                        e.preventDefault();
                        this.cyclePerspective();
                        break;
                        
                    case 'Enter':
                        document.getElementById('chat-input').focus();
                        break;
                }
            }
            
            handleTouchStart(e) {
                // Touch controls for mobile
                const touch = e.touches[0];
                this.handleCanvasClick(touch);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                this.handleMouseMove(touch);
            }
            
            // ========================================
            // PERSPECTIVE SWITCHING
            // ========================================
            
            switchPerspective(perspective) {
                if (this.perspectiveTransitioning) return;
                
                console.log(`üé• Switching to ${perspective} perspective`);
                
                // Update UI
                document.querySelectorAll('.perspective-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`btn-${perspective}`).classList.add('active');
                
                // Set transition status
                this.perspectiveTransitioning = true;
                document.getElementById('transition-status').textContent = 'Transitioning...';
                
                // Store previous perspective
                const previousPerspective = this.currentPerspective;
                this.currentPerspective = perspective;
                
                // Update camera for new perspective
                this.updateCameraForPerspective();
                
                // Send to orchestrator
                if (this.orchestratorWS && this.orchestratorWS.readyState === WebSocket.OPEN) {
                    this.orchestratorWS.send(JSON.stringify({
                        type: 'switch-view',
                        view: perspective,
                        transition: 'smooth'
                    }));
                }
                
                // Simulate transition delay
                setTimeout(() => {
                    this.perspectiveTransitioning = false;
                    document.getElementById('transition-status').textContent = 'Ready';
                    document.getElementById('current-perspective').textContent = perspective.toUpperCase();
                    
                    console.log(`‚úÖ Switched to ${perspective} perspective`);
                }, 1000);
                
                // Log perspective change
                this.addChatMessage(`üé• Switched to ${perspective} view`, '#00ffff');
            }
            
            updateCameraForPerspective() {
                // Reset camera settings based on perspective
                switch (this.currentPerspective) {
                    case 'first-person':
                        this.camera.fov = 75;
                        this.camera.zoom = 1;
                        break;
                        
                    case 'third-person':
                        this.camera.fov = 60;
                        this.camera.zoom = 1;
                        break;
                        
                    case 'aerial':
                        this.camera.fov = 90;
                        this.camera.zoom = 0.5;
                        break;
                        
                    case 'cinematic':
                        this.camera.fov = 35;
                        this.camera.zoom = 1.2;
                        break;
                        
                    case 'sonar':
                        this.camera.fov = 120;
                        this.camera.zoom = 1;
                        break;
                        
                    case 'microscope':
                        this.camera.fov = 30;
                        this.camera.zoom = 5;
                        break;
                        
                    default:
                        this.camera.fov = 60;
                        this.camera.zoom = 1;
                }
            }
            
            cyclePerspective() {
                const perspectives = [
                    'first-person', 'third-person', 'aerial', 'sonar', 
                    'cinematic', 'tactical', 'drone', 'spectator'
                ];
                
                const currentIndex = perspectives.indexOf(this.currentPerspective);
                const nextIndex = (currentIndex + 1) % perspectives.length;
                
                this.switchPerspective(perspectives[nextIndex]);
            }
            
            // ========================================
            // AI COPILOT FUNCTIONS
            // ========================================
            
            async processAICommand() {
                const input = document.getElementById('ai-command');
                const command = input.value.trim();
                
                if (!command) return;
                
                console.log(`ü§ñ Processing AI command: ${command}`);
                
                // Clear input
                input.value = '';
                
                // Add to chat
                this.addChatMessage(`ü§ñ AI Command: ${command}`, '#ff4444');
                
                // Send to orchestrator
                if (this.orchestratorWS && this.orchestratorWS.readyState === WebSocket.OPEN) {
                    this.orchestratorWS.send(JSON.stringify({
                        type: 'ai-command',
                        command
                    }));
                } else {
                    // Process locally
                    const result = await this.processLocalAICommand(command);
                    this.addChatMessage(`ü§ñ ${result.message}`, '#ff8844');
                }
            }
            
            async processLocalAICommand(command) {
                const lowerCommand = command.toLowerCase();
                
                if (lowerCommand.includes('follow')) {
                    // Find closest player/entity to follow
                    const target = this.findClosestEntity();
                    if (target) {
                        this.aiCopilot.tracking.add(target.id);
                        return { success: true, message: `Now following ${target.id}` };
                    }
                    return { success: false, message: 'No entities to follow' };
                }
                
                if (lowerCommand.includes('suggest') || lowerCommand.includes('best view')) {
                    const suggestion = this.suggestBestPerspective();
                    this.switchPerspective(suggestion.perspective);
                    return { success: true, message: `Suggested ${suggestion.perspective}: ${suggestion.reason}` };
                }
                
                if (lowerCommand.includes('cinematic')) {
                    this.switchPerspective('cinematic');
                    this.aiCopilot.mode = 'auto';
                    return { success: true, message: 'Cinematic mode activated' };
                }
                
                if (lowerCommand.includes('overview') || lowerCommand.includes('tactical')) {
                    this.switchPerspective('tactical');
                    return { success: true, message: 'Tactical overview activated' };
                }
                
                if (lowerCommand.includes('reset')) {
                    this.resetView();
                    return { success: true, message: 'View reset to default' };
                }
                
                return { success: false, message: 'Command not recognized. Try: follow, suggest view, cinematic, overview, reset' };
            }
            
            findClosestEntity() {
                if (!this.localPlayer) return null;
                
                let closest = null;
                let minDistance = Infinity;
                
                // Check other players
                this.players.forEach(player => {
                    if (player.id !== this.playerId) {
                        const distance = this.calculateDistance(this.localPlayer, player);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closest = player;
                        }
                    }
                });
                
                // Check entities
                this.entities.forEach(entity => {
                    const distance = this.calculateDistance(this.localPlayer, entity);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = entity;
                    }
                });
                
                return closest;
            }
            
            suggestBestPerspective() {
                const playerCount = this.players.size;
                const entityCount = this.entities.size;
                const totalObjects = playerCount + entityCount;
                
                if (totalObjects === 0) {
                    return { perspective: 'first-person', reason: 'No other objects in scene' };
                }
                
                if (totalObjects > 10) {
                    return { perspective: 'aerial', reason: 'Many objects - aerial view recommended' };
                }
                
                if (totalObjects > 5) {
                    return { perspective: 'tactical', reason: 'Multiple objects - tactical overview recommended' };
                }
                
                if (this.hasUnderwaterEntities()) {
                    return { perspective: 'sonar', reason: 'Underwater activity detected' };
                }
                
                return { perspective: 'third-person', reason: 'Balanced view for current activity' };
            }
            
            hasUnderwaterEntities() {
                // Check if any entities are below water level (y > 0)
                let underwater = false;
                
                this.players.forEach(player => {
                    if (player.y > 0) underwater = true;
                });
                
                this.entities.forEach(entity => {
                    if (entity.y > 0) underwater = true;
                });
                
                return underwater;
            }
            
            generateAISuggestions() {
                const suggestions = [];
                const scene = this.analyzeScene();
                
                // Context-aware suggestions
                if (scene.playerCount > 3 && this.currentPerspective !== 'aerial') {
                    suggestions.push({
                        command: 'switch to aerial view',
                        reason: 'Multiple players detected',
                        confidence: 0.9
                    });
                }
                
                if (scene.fastMoving > 0 && this.currentPerspective !== 'cinematic') {
                    suggestions.push({
                        command: 'enable cinematic mode',
                        reason: 'Fast movement detected',
                        confidence: 0.8
                    });
                }
                
                if (scene.clustered && this.currentPerspective !== 'tactical') {
                    suggestions.push({
                        command: 'tactical overview',
                        reason: 'Entities are clustered',
                        confidence: 0.7
                    });
                }
                
                // Update suggestions in UI
                if (suggestions.length > 0) {
                    this.updateAISuggestions(suggestions);
                }
            }
            
            analyzeScene() {
                const analysis = {
                    playerCount: this.players.size,
                    entityCount: this.entities.size,
                    fastMoving: 0,
                    clustered: false,
                    spread: 0
                };
                
                // Analyze movement
                this.players.forEach(player => {
                    if (player.velocity) {
                        const speed = Math.sqrt(
                            player.velocity.x ** 2 + 
                            player.velocity.y ** 2 + 
                            player.velocity.z ** 2
                        );
                        if (speed > 5) analysis.fastMoving++;
                    }
                });
                
                // Analyze clustering
                if (analysis.playerCount > 2) {
                    const distances = [];
                    const players = Array.from(this.players.values());
                    
                    for (let i = 0; i < players.length; i++) {
                        for (let j = i + 1; j < players.length; j++) {
                            distances.push(this.calculateDistance(players[i], players[j]));
                        }
                    }
                    
                    const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
                    analysis.clustered = avgDistance < 100;
                    analysis.spread = Math.max(...distances) - Math.min(...distances);
                }
                
                return analysis;
            }
            
            updateAISuggestions(suggestions) {
                const container = document.getElementById('ai-suggestions');
                
                // Add new suggestions
                suggestions.forEach(suggestion => {
                    const item = document.createElement('div');
                    item.className = 'suggestion-item';
                    item.textContent = `üéØ ${suggestion.command} (${Math.round(suggestion.confidence * 100)}%)`;
                    item.onclick = () => this.executeAISuggestion(suggestion.command);
                    
                    container.appendChild(item);
                });
                
                // Keep only recent suggestions
                while (container.children.length > 8) {
                    container.removeChild(container.firstChild);
                }
                
                // Update suggestion count
                document.getElementById('suggestion-count').textContent = container.children.length;
            }
            
            executeAISuggestion(command) {
                document.getElementById('ai-command').value = command;
                this.processAICommand();
            }
            
            handleAICommand(event) {
                if (event.key === 'Enter') {
                    this.processAICommand();
                }
            }
            
            // ========================================
            // MULTIPLAYER FUNCTIONS
            // ========================================
            
            sendGameMessage(message) {
                if (this.gameWS && this.gameWS.readyState === WebSocket.OPEN) {
                    this.gameWS.send(JSON.stringify(message));
                }
            }
            
            broadcastPlayerUpdate() {
                if (!this.localPlayer) return;
                
                this.sendGameMessage({
                    type: 'player-update',
                    playerId: this.playerId,
                    player: {
                        x: this.localPlayer.x,
                        y: this.localPlayer.y,
                        z: this.localPlayer.z,
                        rotation: this.localPlayer.rotation,
                        health: this.localPlayer.health,
                        velocity: this.localPlayer.velocity
                    }
                });
            }
            
            handleGameMessage(data) {
                switch (data.type) {
                    case 'player-joined':
                        this.addPlayer(data.player);
                        this.addChatMessage(`üë§ ${data.player.id} joined`, '#00ff00');
                        break;
                        
                    case 'player-left':
                        this.removePlayer(data.playerId);
                        this.addChatMessage(`üë§ ${data.playerId} left`, '#ff4444');
                        break;
                        
                    case 'player-update':
                        this.updatePlayer(data.playerId, data.player);
                        break;
                        
                    case 'chat-message':
                        this.addChatMessage(`${data.playerId}: ${data.message}`, '#ff00ff');
                        break;
                        
                    case 'room-info':
                        document.getElementById('player-count').textContent = data.playerCount;
                        break;
                        
                    case 'entity-spawn':
                        this.spawnEntity(data.entity);
                        break;
                }
            }
            
            addPlayer(player) {
                this.players.set(player.id, {
                    ...player,
                    color: this.generatePlayerColor()
                });
                
                this.updatePlayerCount();
            }
            
            removePlayer(playerId) {
                this.players.delete(playerId);
                this.updatePlayerCount();
            }
            
            updatePlayer(playerId, playerData) {
                const player = this.players.get(playerId);
                if (player) {
                    Object.assign(player, playerData);
                }
            }
            
            updatePlayerCount() {
                document.getElementById('player-count').textContent = this.players.size;
                document.getElementById('online-count').textContent = this.players.size;
            }
            
            // ========================================
            // CHAT FUNCTIONS
            // ========================================
            
            handleChatInput(event) {
                if (event.key === 'Enter') {
                    const input = event.target;
                    const message = input.value.trim();
                    
                    if (!message) return;
                    
                    // Check if it's an AI command
                    if (message.startsWith('/ai ')) {
                        document.getElementById('ai-command').value = message.substring(4);
                        this.processAICommand();
                    } else {
                        // Send chat message
                        this.sendChatMessage(message);
                        this.addChatMessage(`You: ${message}`, '#00ff00');
                    }
                    
                    input.value = '';
                }
            }
            
            sendChatMessage(message) {
                this.sendGameMessage({
                    type: 'chat-message',
                    playerId: this.playerId,
                    message
                });
            }
            
            addChatMessage(message, color = '#ffffff') {
                const container = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.style.color = color;
                messageDiv.style.fontSize = '11px';
                messageDiv.style.margin = '2px 0';
                messageDiv.textContent = message;
                
                container.appendChild(messageDiv);
                container.scrollTop = container.scrollHeight;
                
                // Keep only last 50 messages
                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
                
                // Update message count
                document.getElementById('message-count').textContent = container.children.length;
            }
            
            // ========================================
            // RECORDING FUNCTIONS
            // ========================================
            
            startRecording() {
                if (this.recording.active) return;
                
                console.log('üé• Starting HyperCam-style recording...');
                
                try {
                    const stream = this.canvas.captureStream(30);
                    this.recording.mediaRecorder = new MediaRecorder(stream);
                    this.recording.chunks = [];
                    
                    this.recording.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recording.chunks.push(event.data);
                        }
                    };
                    
                    this.recording.mediaRecorder.onstop = () => {
                        this.saveRecording();
                    };
                    
                    this.recording.mediaRecorder.start();
                    this.recording.active = true;
                    
                    document.getElementById('recording-status').innerHTML = '<span class="recording-indicator">üî¥ RECORDING</span>';
                    this.addChatMessage('üé• Recording started', '#ff0000');
                    
                } catch (error) {
                    console.error('Recording failed:', error);
                    this.addChatMessage('‚ùå Recording failed', '#ff4444');
                }
            }
            
            stopRecording() {
                if (!this.recording.active) return;
                
                console.log('‚èπÔ∏è Stopping recording...');
                
                this.recording.mediaRecorder.stop();
                this.recording.active = false;
                
                document.getElementById('recording-status').textContent = '‚ö´ READY';
                this.addChatMessage('‚èπÔ∏è Recording stopped', '#ffff00');
            }
            
            saveRecording() {
                const blob = new Blob(this.recording.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `3d-game-recording-${Date.now()}.webm`;
                a.click();
                
                URL.revokeObjectURL(url);
                this.addChatMessage('üíæ Recording saved', '#00ff00');
            }
            
            takeScreenshot() {
                const link = document.createElement('a');
                link.download = `3d-game-screenshot-${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
                
                this.addChatMessage('üì∏ Screenshot saved', '#00ff00');
            }
            
            // ========================================
            // CONTROL FUNCTIONS
            // ========================================
            
            resetView() {
                this.camera.rotation = { x: 0, y: 0, z: 0 };
                this.camera.zoom = 1;
                this.updateCameraForPerspective();
                
                this.addChatMessage('üîÑ View reset', '#00ffff');
            }
            
            toggleAI() {
                this.aiCopilot.enabled = !this.aiCopilot.enabled;
                
                const status = this.aiCopilot.enabled ? 'ENABLED' : 'DISABLED';
                document.getElementById('ai-mode').textContent = status;
                
                this.addChatMessage(`ü§ñ AI Copilot ${status}`, '#ff8844');
            }
            
            respawnPlayer() {
                if (this.localPlayer) {
                    this.localPlayer.x = Math.random() * 400 + 200;
                    this.localPlayer.y = Math.random() * 300 + 150;
                    this.localPlayer.z = 0;
                    this.localPlayer.health = 100;
                    this.localPlayer.velocity = { x: 0, y: 0, z: 0 };
                    
                    this.addChatMessage('üí• Respawned', '#ffff00');
                }
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
            
            copyShareLink() {
                const link = document.getElementById('share-link').textContent;
                navigator.clipboard.writeText(link).then(() => {
                    this.addChatMessage('üìã Link copied to clipboard', '#00ff00');
                });
            }
            
            inviteFriend() {
                const link = document.getElementById('share-link').textContent;
                
                if (navigator.share) {
                    navigator.share({
                        title: 'üéÆ Join my 3D Game',
                        text: 'Join me in the Unified 3D Game Experience!',
                        url: link
                    });
                } else {
                    this.copyShareLink();
                }
            }
            
            // ========================================
            // GAME MECHANICS
            // ========================================
            
            shootProjectile(targetX, targetY) {
                if (!this.localPlayer) return;
                
                const projectile = {
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    z: this.localPlayer.z,
                    velocity: {
                        x: targetX ? (targetX - this.canvas.width/2) * 0.1 : Math.sin(this.camera.rotation.y) * 10,
                        y: targetY ? (targetY - this.canvas.height/2) * 0.1 : 0,
                        z: targetX ? 0 : Math.cos(this.camera.rotation.y) * 10
                    },
                    life: 120,
                    owner: this.playerId
                };
                
                this.projectiles.push(projectile);
                
                // Send to other players
                this.sendGameMessage({
                    type: 'projectile-fired',
                    projectile
                });
            }
            
            createParticles(x, y) {
                for (let i = 0; i < 10; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 10,
                        y: y + (Math.random() - 0.5) * 10,
                        z: (Math.random() - 0.5) * 10,
                        velocity: {
                            x: (Math.random() - 0.5) * 5,
                            y: (Math.random() - 0.5) * 5,
                            z: (Math.random() - 0.5) * 5
                        },
                        life: 60,
                        maxLife: 60,
                        alpha: 1,
                        color: `hsl(${Math.random() * 60 + 20}, 100%, 50%)`
                    };
                    
                    this.particles.push(particle);
                }
            }
            
            spawnEntity(entityData) {
                this.entities.set(entityData.id, {
                    ...entityData,
                    velocity: entityData.velocity || { x: 0, y: 0, z: 0 }
                });
                
                document.getElementById('entity-count').textContent = this.entities.size;
            }
            
            // ========================================
            // NETWORK FUNCTIONS
            // ========================================
            
            syncNetwork() {
                // Send periodic updates
                if (this.gameWS && this.gameWS.readyState === WebSocket.OPEN) {
                    this.broadcastPlayerUpdate();
                }
                
                // Update ping display
                document.getElementById('ping-display').textContent = '15ms'; // Simulated
            }
            
            handleOrchestratorMessage(data) {
                switch (data.type) {
                    case 'init':
                        console.log('üé¨ Orchestrator initialized:', data);
                        break;
                        
                    case 'view-changed':
                        console.log(`üé• Orchestrator view changed: ${data.from} ‚Üí ${data.to}`);
                        break;
                        
                    case 'ai-response':
                        this.addChatMessage(`ü§ñ ${data.result.message}`, '#ff8844');
                        break;
                        
                    case 'ai-suggestions':
                        this.updateAISuggestions(data.suggestions);
                        break;
                        
                    case 'state-update':
                        this.handleOrchestratorStateUpdate(data);
                        break;
                }
            }
            
            handleOrchestratorStateUpdate(data) {
                // Update FPS counter
                document.getElementById('fps-counter').textContent = data.performance?.fps || '60';
                
                // Update AI mode
                if (data.aiMode) {
                    document.getElementById('ai-mode').textContent = data.aiMode.toUpperCase();
                }
                
                // Update entity count
                if (data.entities !== undefined) {
                    document.getElementById('entity-count').textContent = data.entities;
                }
            }
            
            updateUI() {
                // Update share link
                document.getElementById('share-link').textContent = 
                    `${window.location.origin}${window.location.pathname}?room=${this.roomId}`;
                
                // Update room ID
                document.getElementById('room-id').textContent = this.roomId;
                
                // Update various counters
                this.updateDisplayCounters();
            }
            
            updateDisplayCounters() {
                // FPS simulation
                const fps = 58 + Math.random() * 4; // 58-62 FPS
                document.getElementById('fps-counter').textContent = Math.round(fps);
            }
            
            updateCameraDisplay() {
                // Update any camera-related UI elements
                // This could show FOV, zoom level, etc.
            }
            
            updateStatus(system, status) {
                console.log(`üìä ${system}: ${status}`);
            }
            
            // ========================================
            // UTILITY FUNCTIONS
            // ========================================
            
            calculateDistance(entity1, entity2) {
                const dx = entity1.x - entity2.x;
                const dy = entity1.y - entity2.y;
                const dz = (entity1.z || 0) - (entity2.z || 0);
                
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
            
            generateRoomId() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            generatePlayerId() {
                return `player_${Math.random().toString(36).substring(2, 9)}`;
            }
            
            generatePlayerColor() {
                const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
        }
        
        // ========================================
        // GLOBAL FUNCTIONS FOR BUTTONS
        // ========================================
        
        let gameExperience;
        
        function switchPerspective(perspective) {
            gameExperience.switchPerspective(perspective);
        }
        
        function processAICommand() {
            gameExperience.processAICommand();
        }
        
        function executeAISuggestion(command) {
            gameExperience.executeAISuggestion(command);
        }
        
        function handleAICommand(event) {
            gameExperience.handleAICommand(event);
        }
        
        function handleChatInput(event) {
            gameExperience.handleChatInput(event);
        }
        
        function startRecording() {
            gameExperience.startRecording();
        }
        
        function stopRecording() {
            gameExperience.stopRecording();
        }
        
        function takeScreenshot() {
            gameExperience.takeScreenshot();
        }
        
        function fullscreen() {
            gameExperience.toggleFullscreen();
        }
        
        function resetView() {
            gameExperience.resetView();
        }
        
        function toggleAI() {
            gameExperience.toggleAI();
        }
        
        function respawnPlayer() {
            gameExperience.respawnPlayer();
        }
        
        function randomGame() {
            window.open('/random', '_blank');
        }
        
        function copyShareLink() {
            gameExperience.copyShareLink();
        }
        
        function inviteFriend() {
            gameExperience.inviteFriend();
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        window.addEventListener('load', () => {
            console.log('üéÆ Initializing Unified 3D Game Experience...');
            
            gameExperience = new Unified3DGameExperience();
            
            // Add some demo entities
            setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                    gameExperience.spawnEntity({
                        id: `entity_${i}`,
                        type: 'demo',
                        x: Math.random() * 800,
                        y: Math.random() * 600,
                        z: Math.random() * 200,
                        color: '#ff4444',
                        velocity: {
                            x: (Math.random() - 0.5) * 2,
                            y: (Math.random() - 0.5) * 2,
                            z: (Math.random() - 0.5) * 2
                        }
                    });
                }
            }, 2000);
            
            console.log('‚úÖ Unified 3D Game Experience ready!');
        });
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (gameExperience) {
                if (gameExperience.gameWS) {
                    gameExperience.gameWS.close();
                }
                if (gameExperience.orchestratorWS) {
                    gameExperience.orchestratorWS.close();
                }
            }
        });
    </script>
</body>
</html>