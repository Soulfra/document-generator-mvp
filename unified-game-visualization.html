<!DOCTYPE html>
<html>
<head>
    <title>üéÆ AI Trust - Unified Game Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(circle at center, #001122, #000000);
            color: #00ff88;
            overflow: hidden;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background: transparent;
            cursor: crosshair;
        }
        
        .hud {
            position: absolute;
            z-index: 100;
            font-size: 12px;
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }
        
        .hud-top-left {
            top: 20px;
            left: 20px;
        }
        
        .hud-top-right {
            top: 20px;
            right: 20px;
            text-align: right;
        }
        
        .hud-bottom-left {
            bottom: 20px;
            left: 20px;
        }
        
        .hud-bottom-right {
            bottom: 20px;
            right: 20px;
            text-align: right;
        }
        
        .reasoning-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .reasoning-title {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .reasoning-thread {
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            font-size: 11px;
            line-height: 1.4;
        }
        
        .thought {
            color: #88ffaa;
            margin: 2px 0;
        }
        
        .conclusion {
            color: #ffffff;
            font-weight: bold;
            margin: 2px 0;
        }
        
        .bot-swarm-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
        }
        
        .swarm-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .bot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            height: 80px;
            overflow-y: auto;
        }
        
        .bot-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 5px;
            font-size: 10px;
        }
        
        .bot-symbol {
            font-size: 16px;
            display: inline-block;
            margin-right: 5px;
        }
        
        .bot-type {
            color: #ffffff;
            font-weight: bold;
        }
        
        .bot-task {
            color: #88ffff;
            font-size: 9px;
            margin-top: 2px;
        }
        
        .bot-state {
            color: #ffff88;
            font-size: 9px;
        }
        
        .controls {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff8800;
            border-radius: 10px;
            padding: 15px;
        }
        
        .controls-title {
            color: #ff8800;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .control-button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: linear-gradient(45deg, #ff8800, #ffaa00);
            color: #000;
            border: none;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-button:hover {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
            transform: translateY(-2px);
        }
        
        .trust-network-info {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .network-metric {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        
        .metric-label {
            color: #88ff88;
        }
        
        .metric-value {
            color: #ffffff;
            font-weight: bold;
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particleFloat 2s linear infinite;
        }
        
        @keyframes particleFloat {
            0% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        
        .connection-status {
            position: absolute;
            top: 50px;
            right: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 8px;
            font-size: 12px;
        }
        
        .status-connected {
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .status-connecting {
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .status-disconnected {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .minimap {
            position: absolute;
            bottom: 160px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #888;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        .legend {
            position: absolute;
            bottom: 320px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            font-size: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD Elements -->
        <div class="hud hud-top-left">
            <div>üéÆ AI Trust Game Engine</div>
            <div>FPS: <span id="fpsCounter">60</span></div>
            <div>Entities: <span id="entityCount">0</span></div>
        </div>
        
        <div class="hud hud-top-right">
            <div>Trust Nodes: <span id="trustNodeCount">0</span></div>
            <div>Active Bots: <span id="botCount">0</span></div>
            <div>Reasoning Threads: <span id="reasoningCount">0</span></div>
        </div>
        
        <div class="hud hud-bottom-left">
            <div>Network Health: <span id="networkHealth">Excellent</span></div>
            <div>Avg Trust: <span id="avgTrust">0.000</span></div>
            <div>Connections: <span id="connectionCount">0</span></div>
        </div>
        
        <!-- Connection Status -->
        <div id="connectionStatus" class="connection-status status-disconnected">
            üì° Disconnected from Mapping Engine
        </div>
        
        <!-- Reasoning Panel -->
        <div class="reasoning-panel" id="reasoningPanel">
            <div class="reasoning-title">üß† AI Reasoning Stream</div>
            <div id="reasoningContent">
                <div class="reasoning-thread">
                    <div class="thought">Initializing reasoning engine...</div>
                    <div class="conclusion">Ready to process trust relationships</div>
                </div>
            </div>
        </div>
        
        <!-- Bot Swarm Panel -->
        <div class="bot-swarm-panel">
            <div class="swarm-title">ü§ñ Bot Swarm Status</div>
            <div class="bot-grid" id="botGrid">
                <!-- Bot cards will be populated here -->
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="controls-title">üéÆ Controls</div>
            <button class="control-button" onclick="resetView()">üîÑ Reset View</button>
            <button class="control-button" onclick="spawnVerificationBot()">ü§ñ Spawn Bot</button>
            <button class="control-button" onclick="triggerHandshake()">ü§ù New Handshake</button>
            <button class="control-button" onclick="showFullMap()">üó∫Ô∏è Full Map</button>
            <button class="control-button" onclick="exportSnapshot()">üì∏ Snapshot</button>
            
            <div class="trust-network-info">
                <div class="network-metric">
                    <span class="metric-label">Density:</span>
                    <span class="metric-value" id="trustDensity">0.0</span>
                </div>
                <div class="network-metric">
                    <span class="metric-label">Security:</span>
                    <span class="metric-value" id="securityLevel">High</span>
                </div>
                <div class="network-metric">
                    <span class="metric-label">Integrity:</span>
                    <span class="metric-value" id="integrityLevel">100%</span>
                </div>
            </div>
        </div>
        
        <!-- Minimap -->
        <div class="minimap">
            <canvas id="minimapCanvas" class="minimap-canvas"></canvas>
        </div>
        
        <!-- Legend -->
        <div class="legend">
            <div style="color: #ffffff; font-weight: bold; margin-bottom: 5px;">Legend</div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff88;"></div>
                <span>Trust Nodes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ffff;"></div>
                <span>Verification Bots</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff00ff;"></div>
                <span>Reasoning Nodes</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffff00;"></div>
                <span>Active Connections</span>
            </div>
        </div>
    </div>
    
    <script>
        // Game engine variables
        let canvas, ctx, minimap, minimapCtx;
        let ws = null;
        let worldState = {
            entities: new Map(),
            trustNodes: new Map(),
            bots: new Map(),
            reasoningThreads: new Map(),
            verificationPaths: new Map(),
            camera: { x: 0, y: 0, z: 100, zoom: 1 }
        };
        
        let gameMetrics = {
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: Date.now()
        };
        
        // Initialize game engine
        function initGame() {
            console.log('üéÆ Initializing AI Trust Game Engine...');
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            minimap = document.getElementById('minimapCanvas');
            minimapCtx = minimap.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Mouse controls
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('wheel', handleMouseWheel);
            
            // Keyboard controls
            window.addEventListener('keydown', handleKeyDown);
            
            // Start game loop
            gameLoop();
            
            // Connect to mapping engine
            connectToMappingEngine();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimap.width = 200;
            minimap.height = 150;
        }
        
        function connectToMappingEngine() {
            updateConnectionStatus('connecting');
            
            try {
                ws = new WebSocket('ws://localhost:7777');
                
                ws.onopen = () => {
                    console.log('üåê Connected to Mapping Engine');
                    updateConnectionStatus('connected');
                };
                
                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleMappingEngineMessage(message);
                    } catch (err) {
                        console.error('Error parsing message:', err);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected');
                };
                
                ws.onclose = () => {
                    console.log('üîå Disconnected from Mapping Engine');
                    updateConnectionStatus('disconnected');
                    
                    // Attempt reconnection
                    setTimeout(connectToMappingEngine, 5000);
                };
            } catch (error) {
                console.error('Failed to connect to Mapping Engine:', error);
                updateConnectionStatus('disconnected');
                setTimeout(connectToMappingEngine, 5000);
            }
        }
        
        function handleMappingEngineMessage(message) {
            switch (message.type) {
                case 'world_init':
                    updateWorldState(message.data);
                    break;
                    
                case 'world_update':
                    processWorldUpdate(message.update);
                    break;
                    
                case 'reasoning_stream':
                    updateReasoningPanel(message.entityId, message.reasoning);
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type);
            }
        }
        
        function updateWorldState(data) {
            console.log('üåç Updating world state:', data);
            
            // Update trust nodes
            if (data.trustNodes) {
                data.trustNodes.forEach(node => {
                    worldState.trustNodes.set(node.id, node);
                });
            }
            
            // Update bots
            if (data.swarmBots) {
                data.swarmBots.forEach(bot => {
                    worldState.bots.set(bot.id, bot);
                });
            }
            
            // Update reasoning threads
            if (data.reasoning) {
                data.reasoning.forEach(thread => {
                    worldState.reasoningThreads.set(thread.id, thread);
                });
            }
            
            // Update verification paths
            if (data.verificationPaths) {
                data.verificationPaths.forEach(path => {
                    worldState.verificationPaths.set(path.id, path);
                });
            }
            
            // Update UI
            updateHUD(data);
            updateBotSwarmPanel();
        }
        
        function processWorldUpdate(update) {
            switch (update.type) {
                case 'trust_mapped':
                    worldState.trustNodes.set(update.entity.id, update.entity);
                    addReasoningThread(update.entity.id, 'Trust node established');
                    break;
            }
        }
        
        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `connection-status status-${status}`;
            
            switch (status) {
                case 'connected':
                    statusEl.textContent = 'üì° Connected to Mapping Engine';
                    break;
                case 'connecting':
                    statusEl.textContent = 'üì° Connecting to Mapping Engine...';
                    break;
                case 'disconnected':
                    statusEl.textContent = 'üì° Disconnected from Mapping Engine';
                    break;
            }
        }
        
        function updateHUD(data) {
            document.getElementById('entityCount').textContent = 
                (data.entities?.length || 0) + (worldState.trustNodes.size || 0);
            document.getElementById('trustNodeCount').textContent = worldState.trustNodes.size;
            document.getElementById('botCount').textContent = worldState.bots.size;
            document.getElementById('reasoningCount').textContent = worldState.reasoningThreads.size;
            
            // Calculate network metrics
            const avgTrust = calculateAverageTrust();
            document.getElementById('avgTrust').textContent = avgTrust.toFixed(3);
            
            const connectionCount = calculateConnections();
            document.getElementById('connectionCount').textContent = connectionCount;
            
            const networkHealth = avgTrust > 0.8 ? 'Excellent' : avgTrust > 0.6 ? 'Good' : 'Needs Improvement';
            document.getElementById('networkHealth').textContent = networkHealth;
            
            // Update detailed metrics
            document.getElementById('trustDensity').textContent = (avgTrust * connectionCount / 10).toFixed(1);
            document.getElementById('securityLevel').textContent = avgTrust > 0.8 ? 'High' : 'Medium';
            document.getElementById('integrityLevel').textContent = Math.floor(avgTrust * 100) + '%';
        }
        
        function updateBotSwarmPanel() {
            const botGrid = document.getElementById('botGrid');
            botGrid.innerHTML = '';
            
            worldState.bots.forEach(bot => {
                const botCard = document.createElement('div');
                botCard.className = 'bot-card';
                botCard.innerHTML = `
                    <div>
                        <span class="bot-symbol">${bot.symbol}</span>
                        <span class="bot-type">${bot.type}</span>
                    </div>
                    <div class="bot-task">${bot.task}</div>
                    <div class="bot-state">Status: ${bot.state}</div>
                `;
                botGrid.appendChild(botCard);
            });
        }
        
        function addReasoningThread(entityId, content) {
            const thread = {
                id: `${entityId}-${Date.now()}`,
                entityId: entityId,
                timestamp: Date.now(),
                content: content
            };
            
            worldState.reasoningThreads.set(thread.id, thread);
            updateReasoningPanel(entityId, thread);
        }
        
        function updateReasoningPanel(entityId, reasoning) {
            const panel = document.getElementById('reasoningContent');
            
            const threadEl = document.createElement('div');
            threadEl.className = 'reasoning-thread';
            
            if (reasoning.thoughts) {
                reasoning.thoughts.forEach(thought => {
                    const thoughtEl = document.createElement('div');
                    thoughtEl.className = 'thought';
                    thoughtEl.textContent = thought;
                    threadEl.appendChild(thoughtEl);
                });
            }
            
            if (reasoning.conclusions) {
                reasoning.conclusions.forEach(conclusion => {
                    const conclusionEl = document.createElement('div');
                    conclusionEl.className = 'conclusion';
                    conclusionEl.textContent = `‚Üí ${conclusion}`;
                    threadEl.appendChild(conclusionEl);
                });
            }
            
            if (typeof reasoning === 'string') {
                const thoughtEl = document.createElement('div');
                thoughtEl.className = 'thought';
                thoughtEl.textContent = reasoning;
                threadEl.appendChild(thoughtEl);
            }
            
            panel.appendChild(threadEl);
            
            // Keep only last 10 threads
            while (panel.children.length > 10) {
                panel.removeChild(panel.firstChild);
            }
            
            // Scroll to bottom
            panel.scrollTop = panel.scrollHeight;
        }
        
        function calculateAverageTrust() {
            if (worldState.trustNodes.size === 0) return 0;
            
            let totalTrust = 0;
            worldState.trustNodes.forEach(node => {
                totalTrust += node.data?.trustLevel || 0;
            });
            
            return totalTrust / worldState.trustNodes.size;
        }
        
        function calculateConnections() {
            let connections = 0;
            worldState.trustNodes.forEach(node => {
                connections += node.connections?.length || 0;
            });
            return connections;
        }
        
        // Game loop
        function gameLoop() {
            // Update FPS
            gameMetrics.frameCount++;
            const now = Date.now();
            if (now - gameMetrics.lastFpsUpdate > 1000) {
                gameMetrics.fps = gameMetrics.frameCount;
                gameMetrics.frameCount = 0;
                gameMetrics.lastFpsUpdate = now;
                document.getElementById('fpsCounter').textContent = gameMetrics.fps;
            }
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 17, 34, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw world
            drawWorld();
            
            // Draw minimap
            drawMinimap();
            
            requestAnimationFrame(gameLoop);
        }
        
        function drawWorld() {
            ctx.save();
            
            // Apply camera transform
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(worldState.camera.zoom, worldState.camera.zoom);
            ctx.translate(-worldState.camera.x, -worldState.camera.y);
            
            // Draw verification paths
            drawVerificationPaths();
            
            // Draw trust nodes
            drawTrustNodes();
            
            // Draw bots
            drawBots();
            
            // Draw particles
            drawParticles();
            
            ctx.restore();
        }
        
        function drawTrustNodes() {
            worldState.trustNodes.forEach(node => {
                const pos = worldToScreen(node.position);
                
                // Draw node
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, node.visual.size, 0, Math.PI * 2);
                ctx.fillStyle = node.visual.color;
                ctx.fill();
                
                if (node.visual.glow) {
                    ctx.shadowColor = node.visual.color;
                    ctx.shadowBlur = 20;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Draw connections
                if (node.connections) {
                    node.connections.forEach(connectionId => {
                        const connectedBot = worldState.bots.get(connectionId);
                        if (connectedBot) {
                            const botPos = worldToScreen(connectedBot.position);
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                            ctx.lineTo(botPos.x, botPos.y);
                            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                }
                
                // Draw trust level text
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(
                    (node.data.trustLevel || 0).toFixed(2),
                    pos.x,
                    pos.y + node.visual.size + 15
                );
            });
        }
        
        function drawBots() {
            worldState.bots.forEach(bot => {
                const pos = worldToScreen(bot.position);
                
                // Draw bot
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, bot.visual.size, 0, Math.PI * 2);
                ctx.fillStyle = bot.visual.color;
                ctx.fill();
                
                // Draw symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(bot.symbol, pos.x, pos.y + 5);
                
                // Draw trail if bot is moving
                if (bot.visual.trail && bot.velocity) {
                    const speed = Math.sqrt(bot.velocity.x ** 2 + bot.velocity.y ** 2);
                    if (speed > 0.1) {
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(
                            pos.x - bot.velocity.x * 20,
                            pos.y - bot.velocity.y * 20
                        );
                        ctx.strokeStyle = bot.visual.color + '80';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }
            });
        }
        
        function drawVerificationPaths() {
            worldState.verificationPaths.forEach(path => {
                if (path.particles) {
                    path.particles.forEach(particle => {
                        const startPos = worldToScreen(path.start);
                        const endPos = worldToScreen(path.end);
                        
                        const x = startPos.x + (endPos.x - startPos.x) * particle.position;
                        const y = startPos.y + (endPos.y - startPos.y) * particle.position;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fillStyle = particle.color;
                        ctx.fill();
                        
                        // Update particle position
                        particle.position += particle.speed;
                        if (particle.position > 1) {
                            particle.position = 0;
                        }
                    });
                }
            });
        }
        
        function drawParticles() {
            // Draw ambient particles for atmosphere
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                const x = (Math.sin(Date.now() * 0.001 + i) * 500) + worldState.camera.x;
                const y = (Math.cos(Date.now() * 0.0007 + i) * 300) + worldState.camera.y;
                const pos = worldToScreen({ x, y });
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 1, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                ctx.fill();
            }
        }
        
        function drawMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);
            
            // Draw trust nodes on minimap
            worldState.trustNodes.forEach(node => {
                const x = (node.position.x + 1000) / 2000 * minimap.width;
                const y = (node.position.y + 1000) / 2000 * minimap.height;
                
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, 3, 0, Math.PI * 2);
                minimapCtx.fillStyle = node.visual.color;
                minimapCtx.fill();
            });
            
            // Draw camera position
            const camX = (worldState.camera.x + 1000) / 2000 * minimap.width;
            const camY = (worldState.camera.y + 1000) / 2000 * minimap.height;
            
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.strokeRect(camX - 10, camY - 10, 20, 20);
        }
        
        function worldToScreen(worldPos) {
            return {
                x: worldPos.x,
                y: worldPos.y
            };
        }
        
        // Event handlers
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        
        function handleMouseDown(e) {
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
        }
        
        function handleMouseMove(e) {
            if (isDragging) {
                const dx = e.clientX - lastMousePos.x;
                const dy = e.clientY - lastMousePos.y;
                
                worldState.camera.x -= dx / worldState.camera.zoom;
                worldState.camera.y -= dy / worldState.camera.zoom;
                
                lastMousePos = { x: e.clientX, y: e.clientY };
            }
        }
        
        function handleMouseWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            worldState.camera.zoom = Math.max(0.1, Math.min(5, worldState.camera.zoom * zoomFactor));
        }
        
        function handleKeyDown(e) {
            const speed = 50 / worldState.camera.zoom;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    worldState.camera.y -= speed;
                    break;
                case 'ArrowDown':
                case 's':
                    worldState.camera.y += speed;
                    break;
                case 'ArrowLeft':
                case 'a':
                    worldState.camera.x -= speed;
                    break;
                case 'ArrowRight':
                case 'd':
                    worldState.camera.x += speed;
                    break;
                case ' ':
                    e.preventDefault();
                    triggerHandshake();
                    break;
            }
        }
        
        window.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Control functions
        function resetView() {
            worldState.camera = { x: 0, y: 0, z: 100, zoom: 1 };
        }
        
        function spawnVerificationBot() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'spawn_verification',
                    data: { type: 'manual_spawn' }
                }));
            }
            
            addReasoningThread('system', 'Manual verification bot spawned by user');
        }
        
        function triggerHandshake() {
            // Trigger a new handshake in the trust system
            fetch('http://localhost:6666/initiate-handshake', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                addReasoningThread('system', 
                    `New handshake initiated - Trust Level: ${data.trustLevel || 'Unknown'}`);
            })
            .catch(err => {
                addReasoningThread('system', 'Failed to initiate handshake - Trust system may be offline');
            });
        }
        
        function showFullMap() {
            // Calculate bounds of all entities
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            worldState.trustNodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                maxX = Math.max(maxX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxY = Math.max(maxY, node.position.y);
            });
            
            if (minX !== Infinity) {
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const rangeX = maxX - minX;
                const rangeY = maxY - minY;
                
                worldState.camera.x = centerX;
                worldState.camera.y = centerY;
                worldState.camera.zoom = Math.min(
                    canvas.width / (rangeX + 200),
                    canvas.height / (rangeY + 200)
                );
            }
        }
        
        function exportSnapshot() {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `trust-network-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            addReasoningThread('system', 'Network snapshot exported');
        }
        
        // Initialize game when page loads
        window.onload = initGame;
    </script>
</body>
</html>