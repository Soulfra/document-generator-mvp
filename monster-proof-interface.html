<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ‘¾ Monster Proof Interface - Visual Verification System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-bottom: 2px solid #00ff88;
            text-align: center;
        }
        
        .header h1 {
            color: #00ff88;
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff88;
        }
        
        .proof-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
        }
        
        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #00ff88;
        }
        
        .monster-arena {
            position: relative;
            width: 100%;
            height: 80vh;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 255, 198, 0.3) 0%, transparent 50%);
            border: 2px solid #333;
            overflow: hidden;
        }
        
        .monster-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .narrative-monster {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }
        
        .narrative-monster:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ff6b6b;
            transform: scale(1.05);
            z-index: 1000;
        }
        
        .monster-sprite {
            position: relative;
            margin-bottom: 10px;
        }
        
        .monster-canvas {
            border: 1px solid #666;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .monster-info h3 {
            color: #ff6b6b;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .monster-info p {
            font-size: 0.8em;
            color: #ccc;
            margin-bottom: 8px;
        }
        
        .monster-stats {
            display: flex;
            gap: 10px;
            font-size: 0.7em;
        }
        
        .difficulty {
            background: #4CAF50;
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
        }
        
        .difficulty.medium {
            background: #FF9800;
        }
        
        .difficulty.hard {
            background: #F44336;
        }
        
        .spawn-time {
            color: #00ff88;
        }
        
        .visual-proof {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }
        
        .visual-proof small {
            color: #888;
            font-family: monospace;
        }
        
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            z-index: 2000;
        }
        
        .control-panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }
        
        .control-panel button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            background: #1a1a2e;
            color: #00ff88;
            border: 1px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }
        
        .control-panel button:hover {
            background: #00ff88;
            color: #1a1a2e;
        }
        
        .proof-log {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            overflow-y: auto;
            z-index: 2000;
        }
        
        .proof-log h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        .log-entry {
            font-size: 0.8em;
            margin-bottom: 5px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .log-entry.spawn {
            border-left: 3px solid #4CAF50;
        }
        
        .log-entry.error {
            border-left: 3px solid #F44336;
        }
        
        .floating-ui {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            z-index: 1500;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px #00ff88; }
            50% { box-shadow: 0 0 20px #00ff88, 0 0 30px #00ff88; }
        }
        
        .glowing {
            animation: pulse-glow 2s infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .monster-sprite {
            animation: float 3s infinite ease-in-out;
        }
        
        @keyframes spawn-effect {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(180deg);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.2) rotate(90deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }
        
        .monster-spawning {
            animation: spawn-effect 1s ease-out;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ‘¾ Monster Proof Interface</h1>
        <p>Visual Verification: Errors â†’ Narrative Monsters â†’ Displayable Pixels</p>
        <div class="proof-stats">
            <div class="stat">
                <strong>Active Monsters:</strong> <span id="monster-count">0</span>
            </div>
            <div class="stat">
                <strong>Pixels Rendered:</strong> <span id="pixel-count">0</span>
            </div>
            <div class="stat">
                <strong>Proof Hash:</strong> <span id="proof-hash">N/A</span>
            </div>
            <div class="stat">
                <strong>Integrity:</strong> <span id="integrity">100%</span>
            </div>
        </div>
    </div>
    
    <div class="monster-arena" id="monster-arena">
        <div class="monster-container" id="monster-container">
            <!-- Monsters will be spawned here -->
        </div>
    </div>
    
    <div class="control-panel">
        <h3>ðŸŽ® Control Panel</h3>
        <button onclick="spawnRandomMonster()">Spawn Random Monster</button>
        <button onclick="spawnVampire()">Spawn Vampire</button>
        <button onclick="spawn404()">Spawn 404 Error</button>
        <button onclick="spawn500()">Spawn 500 Error</button>
        <button onclick="clearAllMonsters()">Clear All Monsters</button>
        <button onclick="exportProofs()">Export Proofs</button>
        <button onclick="validateIntegrity()">Validate Integrity</button>
    </div>
    
    <div class="proof-log">
        <h3>ðŸ“‹ Proof Log</h3>
        <div id="log-entries">
            <div class="log-entry">System initialized - Ready for monster spawning</div>
        </div>
    </div>
    
    <div class="floating-ui">
        <h3>ðŸ“Š Live Stats</h3>
        <div>Vampires: <span id="vampire-count">0</span></div>
        <div>Error Spirits: <span id="error-count">0</span></div>
        <div>Boss Monsters: <span id="boss-count">0</span></div>
        <div>Total Proof Size: <span id="proof-size">0 KB</span></div>
    </div>
    
    <script>
        // Monster Proof System
        class MonsterProofSystem {
            constructor() {
                this.monsters = new Map();
                this.proofs = new Map();
                this.pixelCount = 0;
                this.nextMonsterId = 1;
                
                // Monster templates
                this.templates = {
                    vampire: {
                        name: 'Vampire Packet Corruptor',
                        size: { width: 64, height: 96 },
                        colors: ['#8B0000', '#DC143C', '#FF6B6B'],
                        pattern: 'vampire'
                    },
                    lost_spirit: {
                        name: 'Lost Spirit (404)',
                        size: { width: 48, height: 72 },
                        colors: ['#808080', '#A9A9A9', '#D3D3D3'],
                        pattern: 'ghost'
                    },
                    chaos_demon: {
                        name: 'Chaos Demon (500)',
                        size: { width: 80, height: 120 },
                        colors: ['#4B0082', '#8A2BE2', '#9932CC'],
                        pattern: 'chaos'
                    },
                    guardian_golem: {
                        name: 'Guardian Golem (403)',
                        size: { width: 72, height: 108 },
                        colors: ['#696969', '#808080', '#A9A9A9'],
                        pattern: 'block'
                    }
                };
                
                this.updateStats();
                this.startProofValidation();
            }
            
            spawnMonster(type, position = null) {
                const template = this.templates[type];
                if (!template) {
                    console.error('Unknown monster type:', type);
                    return null;
                }
                
                const monsterId = `monster_${this.nextMonsterId++}`;
                const pos = position || {
                    x: Math.random() * (window.innerWidth - 300),
                    y: Math.random() * (window.innerHeight - 200) + 100
                };
                
                const monster = {
                    id: monsterId,
                    type: type,
                    template: template,
                    position: pos,
                    spawnTime: Date.now(),
                    pixelData: this.generatePixelArt(template),
                    proofHash: this.generateProofHash(monsterId, template)
                };
                
                // Create HTML element
                const element = this.createMonsterElement(monster);
                document.getElementById('monster-container').appendChild(element);
                
                // Render pixel art
                this.renderPixelArt(monsterId, monster.pixelData);
                
                // Store monster and proof
                this.monsters.set(monsterId, monster);
                this.proofs.set(monsterId, {
                    hash: monster.proofHash,
                    pixelCount: monster.pixelData.pixelCount,
                    timestamp: monster.spawnTime,
                    verified: true
                });
                
                // Update stats
                this.updateStats();
                this.logEvent(`Monster spawned: ${template.name}`, 'spawn');
                
                return monster;
            }
            
            generatePixelArt(template) {
                const { width, height } = template.size;
                const matrix = [];
                let pixelCount = 0;
                
                for (let y = 0; y < height; y++) {
                    matrix[y] = [];
                    for (let x = 0; x < width; x++) {
                        const pixel = this.generatePixel(x, y, width, height, template);
                        matrix[y][x] = pixel;
                        if (pixel !== 'transparent') pixelCount++;
                    }
                }
                
                return {
                    matrix: matrix,
                    width: width,
                    height: height,
                    pixelCount: pixelCount,
                    colors: template.colors
                };
            }
            
            generatePixel(x, y, width, height, template) {
                const centerX = width / 2;
                const centerY = height / 2;
                const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                const maxDistance = Math.min(width, height) / 2;
                const ratio = distance / maxDistance;
                
                // Generate pattern based on template type
                switch (template.pattern) {
                    case 'vampire':
                        if (ratio < 0.3 && y > height * 0.2) {
                            return template.colors[0]; // Primary
                        } else if (ratio < 0.5 && y > height * 0.15) {
                            return template.colors[1]; // Secondary
                        } else if (ratio < 0.7 && y > height * 0.1) {
                            return template.colors[2]; // Accent
                        }
                        break;
                        
                    case 'ghost':
                        if (ratio < 0.4 && Math.random() > 0.4) {
                            const colorIndex = Math.floor(Math.random() * template.colors.length);
                            return template.colors[colorIndex];
                        }
                        break;
                        
                    case 'chaos':
                        if (ratio < 0.6 && Math.random() > 0.2) {
                            const colorIndex = Math.floor(Math.random() * template.colors.length);
                            return template.colors[colorIndex];
                        }
                        break;
                        
                    case 'block':
                        if (x > width * 0.2 && x < width * 0.8 && 
                            y > height * 0.2 && y < height * 0.8) {
                            const colorIndex = Math.floor((x + y) / 10) % template.colors.length;
                            return template.colors[colorIndex];
                        }
                        break;
                }
                
                return 'transparent';
            }
            
            createMonsterElement(monster) {
                const element = document.createElement('div');
                element.className = 'narrative-monster monster-spawning';
                element.setAttribute('data-id', monster.id);
                element.setAttribute('data-type', monster.type);
                element.style.left = monster.position.x + 'px';
                element.style.top = monster.position.y + 'px';
                
                element.innerHTML = `
                    <div class="monster-sprite">
                        <canvas width="${monster.template.size.width}" height="${monster.template.size.height}" 
                                class="monster-canvas" id="canvas_${monster.id}"></canvas>
                    </div>
                    <div class="monster-info">
                        <h3>${monster.template.name}</h3>
                        <p>Spawned from narrative error system</p>
                        <div class="monster-stats">
                            <span class="difficulty">${this.getDifficulty(monster.type)}</span>
                            <span class="spawn-time">${new Date(monster.spawnTime).toLocaleTimeString()}</span>
                        </div>
                    </div>
                    <div class="visual-proof">
                        <small>Proof: ${monster.proofHash}</small>
                    </div>
                `;
                
                // Add click handler
                element.addEventListener('click', () => {
                    this.inspectMonster(monster.id);
                });
                
                return element;
            }
            
            renderPixelArt(monsterId, pixelData) {
                const canvas = document.getElementById(`canvas_${monsterId}`);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const pixelSize = 1; // 1:1 pixel ratio
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Render pixels
                for (let y = 0; y < pixelData.matrix.length; y++) {
                    for (let x = 0; x < pixelData.matrix[y].length; x++) {
                        const color = pixelData.matrix[y][x];
                        if (color !== 'transparent') {
                            ctx.fillStyle = color;
                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        }
                    }
                }
                
                this.pixelCount += pixelData.pixelCount;
            }
            
            getDifficulty(type) {
                const difficulties = {
                    vampire: 'medium',
                    lost_spirit: 'easy',
                    chaos_demon: 'hard',
                    guardian_golem: 'medium'
                };
                return difficulties[type] || 'unknown';
            }
            
            generateProofHash(monsterId, template) {
                const data = `${monsterId}_${template.name}_${Date.now()}`;
                return this.simpleHash(data).slice(0, 12);
            }
            
            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16);
            }
            
            updateStats() {
                document.getElementById('monster-count').textContent = this.monsters.size;
                document.getElementById('pixel-count').textContent = this.pixelCount.toLocaleString();
                document.getElementById('proof-hash').textContent = this.generateSystemHash();
                
                // Count by type
                const counts = { vampire: 0, error: 0, boss: 0 };
                for (const monster of this.monsters.values()) {
                    if (monster.type === 'vampire') counts.vampire++;
                    else if (monster.type === 'chaos_demon') counts.boss++;
                    else counts.error++;
                }
                
                document.getElementById('vampire-count').textContent = counts.vampire;
                document.getElementById('error-count').textContent = counts.error;
                document.getElementById('boss-count').textContent = counts.boss;
                document.getElementById('proof-size').textContent = Math.floor(this.pixelCount * 4 / 1024) + ' KB';
            }
            
            generateSystemHash() {
                const hashes = Array.from(this.proofs.values()).map(p => p.hash);
                return this.simpleHash(hashes.join('_')).slice(0, 8);
            }
            
            logEvent(message, type = 'info') {
                const logContainer = document.getElementById('log-entries');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                
                logContainer.insertBefore(entry, logContainer.firstChild);
                
                // Keep only last 10 entries
                while (logContainer.children.length > 10) {
                    logContainer.removeChild(logContainer.lastChild);
                }
            }
            
            inspectMonster(monsterId) {
                const monster = this.monsters.get(monsterId);
                const proof = this.proofs.get(monsterId);
                
                if (monster && proof) {
                    alert(`Monster Inspection:
Name: ${monster.template.name}
Type: ${monster.type}
Proof Hash: ${proof.hash}
Pixels: ${proof.pixelCount}
Verified: ${proof.verified ? 'YES' : 'NO'}
Spawn Time: ${new Date(monster.spawnTime).toLocaleString()}`);
                }
            }
            
            clearAllMonsters() {
                document.getElementById('monster-container').innerHTML = '';
                this.monsters.clear();
                this.proofs.clear();
                this.pixelCount = 0;
                this.updateStats();
                this.logEvent('All monsters cleared', 'info');
            }
            
            exportProofs() {
                const proofs = {
                    timestamp: Date.now(),
                    monsters: Array.from(this.monsters.values()),
                    proofs: Array.from(this.proofs.values()),
                    systemHash: this.generateSystemHash(),
                    pixelCount: this.pixelCount
                };
                
                console.log('ðŸ“¸ Visual Proofs Exported:', proofs);
                this.logEvent(`Exported ${this.monsters.size} monster proofs`, 'info');
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(proofs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `monster_proofs_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            validateIntegrity() {
                let valid = 0;
                for (const [id, proof] of this.proofs) {
                    if (this.monsters.has(id) && proof.verified) {
                        valid++;
                    }
                }
                
                const percentage = Math.floor((valid / this.proofs.size) * 100);
                document.getElementById('integrity').textContent = percentage + '%';
                
                this.logEvent(`Integrity check: ${valid}/${this.proofs.size} valid (${percentage}%)`, 
                             percentage === 100 ? 'spawn' : 'error');
            }
            
            startProofValidation() {
                // Continuous validation every 5 seconds
                setInterval(() => {
                    this.validateIntegrity();
                }, 5000);
            }
        }
        
        // Global monster system
        const monsterSystem = new MonsterProofSystem();
        
        // Control functions
        function spawnRandomMonster() {
            const types = ['vampire', 'lost_spirit', 'chaos_demon', 'guardian_golem'];
            const randomType = types[Math.floor(Math.random() * types.length)];
            monsterSystem.spawnMonster(randomType);
        }
        
        function spawnVampire() {
            monsterSystem.spawnMonster('vampire');
        }
        
        function spawn404() {
            monsterSystem.spawnMonster('lost_spirit');
        }
        
        function spawn500() {
            monsterSystem.spawnMonster('chaos_demon');
        }
        
        function clearAllMonsters() {
            monsterSystem.clearAllMonsters();
        }
        
        function exportProofs() {
            monsterSystem.exportProofs();
        }
        
        function validateIntegrity() {
            monsterSystem.validateIntegrity();
        }
        
        // Auto-spawn some monsters on load
        setTimeout(() => {
            spawnVampire();
            setTimeout(() => spawn404(), 1000);
            setTimeout(() => spawn500(), 2000);
        }, 1000);
        
        // Simulate errors spawning monsters
        window.addEventListener('error', () => {
            console.log('ðŸŽ¯ Real error detected - spawning monster!');
            spawnRandomMonster();
        });
    </script>
</body>
</html>