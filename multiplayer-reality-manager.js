#!/usr/bin/env node

/**
 * MULTIPLAYER REALITY MANAGER
 * Handles us â†” database, us â†” players, us â†” NPCs reality interactions
 * Manages multiple reality streams and synchronization
 * 
 * This creates the different types of reality sharing and interaction
 */

const EventEmitter = require('events');
const WebSocket = require('ws');

class MultiplayerRealityManager extends EventEmitter {
    constructor(realityBridge, contextManager) {
        super();
        
        this.realityBridge = realityBridge;
        this.contextManager = contextManager;
        
        // Participant management
        this.participants = new Map();
        this.realityStreams = new Map();
        this.connections = new Map();
        
        // Reality stream types
        this.streamTypes = {
            'us-database': {
                name: 'Database Learning',
                description: 'Learning and building from database interactions',
                lagSettings: { 
                    baseDelay: 1200, 
                    oscillationRange: 300,
                    learningRhythm: true,
                    knowledgeAccumulation: true
                },
                participants: ['user', 'database'],
                syncMode: 'asynchronous',
                persistence: 'high'
            },
            
            'us-players': {
                name: 'Player Collaboration',
                description: 'Shared reality with other human players',
                lagSettings: { 
                    baseDelay: 600, 
                    oscillationRange: 150,
                    synchronized: true,
                    conflictResolution: true
                },
                participants: ['user', 'players'],
                syncMode: 'synchronized',
                persistence: 'medium'
            },
            
            'us-npcs': {
                name: 'NPC Interaction',
                description: 'AI-driven non-player character interactions',
                lagSettings: { 
                    baseDelay: 400, 
                    oscillationRange: 100,
                    aiDriven: true,
                    responsiveDelay: true
                },
                participants: ['user', 'npcs'],
                syncMode: 'responsive',
                persistence: 'low'
            },
            
            'database-players': {
                name: 'Shared Database Learning',
                description: 'Multiple participants learning from shared database',
                lagSettings: { 
                    baseDelay: 800, 
                    oscillationRange: 200,
                    collaborative: true,
                    knowledgeSharing: true
                },
                participants: ['database', 'players'],
                syncMode: 'collaborative',
                persistence: 'high'
            },
            
            'mixed-reality': {
                name: 'Mixed Reality Stream',
                description: 'All participant types in unified reality',
                lagSettings: { 
                    baseDelay: 750, 
                    oscillationRange: 250,
                    adaptive: true,
                    contextSensitive: true
                },
                participants: ['user', 'players', 'npcs', 'database'],
                syncMode: 'adaptive',\n                persistence: 'variable'\n            }\n        };\n        \n        // Participant types and their characteristics\n        this.participantTypes = {\n            user: {\n                type: 'human',\n                realtime: true,\n                authority: 'high',\n                lagTolerance: 'medium',\n                interactionModes: ['direct', 'voice', 'gesture', 'thought']\n            },\n            \n            database: {\n                type: 'system',\n                realtime: false,\n                authority: 'knowledge',\n                lagTolerance: 'high',\n                interactionModes: ['query', 'search', 'learn', 'store']\n            },\n            \n            players: {\n                type: 'human',\n                realtime: true,\n                authority: 'peer',\n                lagTolerance: 'low',\n                interactionModes: ['chat', 'collaborate', 'compete', 'share']\n            },\n            \n            npcs: {\n                type: 'ai',\n                realtime: 'simulated',\n                authority: 'contextual',\n                lagTolerance: 'adaptive',\n                interactionModes: ['dialogue', 'assist', 'challenge', 'guide']\n            }\n        };\n        \n        // Reality synchronization modes\n        this.syncModes = {\n            synchronous: {\n                description: 'All participants see exact same reality at same time',\n                conflictResolution: 'consensus',\n                lagBehavior: 'uniform',\n                updateFrequency: 'high'\n            },\n            \n            asynchronous: {\n                description: 'Participants can be at different points in reality timeline',\n                conflictResolution: 'temporal',\n                lagBehavior: 'individual',\n                updateFrequency: 'medium'\n            },\n            \n            responsive: {\n                description: 'Reality adapts to participant responses and interactions',\n                conflictResolution: 'adaptive',\n                lagBehavior: 'responsive',\n                updateFrequency: 'variable'\n            },\n            \n            collaborative: {\n                description: 'Participants contribute to shared reality construction',\n                conflictResolution: 'contribution',\n                lagBehavior: 'collaborative',\n                updateFrequency: 'high'\n            },\n            \n            adaptive: {\n                description: 'Sync mode changes based on context and participants',\n                conflictResolution: 'contextual',\n                lagBehavior: 'contextual',\n                updateFrequency: 'adaptive'\n            }\n        };\n        \n        // Active reality streams\n        this.activeStreams = new Map();\n        \n        // WebSocket server for multiplayer connections\n        this.wss = null;\n        \n        this.init();\n    }\n    \n    async init() {\n        console.log('ðŸ‘¥ MULTIPLAYER REALITY MANAGER INITIALIZING...');\n        \n        // Start WebSocket server for multiplayer connections\n        this.startMultiplayerServer();\n        \n        // Initialize database connection stream\n        await this.initializeDatabaseStream();\n        \n        // Initialize NPC system\n        await this.initializeNPCSystem();\n        \n        // Listen for context changes\n        this.contextManager.on('context-changed', (data) => {\n            this.handleContextChange(data);\n        });\n        \n        // Start reality synchronization\n        this.startRealitySynchronization();\n        \n        console.log('âœ… Multiplayer Reality Manager online - all participant types supported!');\n    }\n    \n    startMultiplayerServer() {\n        this.wss = new WebSocket.Server({ port: 9103 });\n        \n        this.wss.on('connection', (ws, req) => {\n            const participantId = this.generateParticipantId();\n            const clientIP = req.socket.remoteAddress;\n            \n            console.log(`ðŸ”Œ New participant connected: ${participantId} from ${clientIP}`);\n            \n            // Register participant\n            this.registerParticipant(participantId, {\n                type: 'user', // Default, can be upgraded\n                connection: ws,\n                ip: clientIP,\n                joinTime: Date.now(),\n                realityStreams: new Set()\n            });\n            \n            // Send initial reality state\n            this.sendInitialRealityState(ws, participantId);\n            \n            ws.on('message', (message) => {\n                this.handleParticipantMessage(participantId, message);\n            });\n            \n            ws.on('close', () => {\n                console.log(`ðŸ”Œ Participant disconnected: ${participantId}`);\n                this.unregisterParticipant(participantId);\n            });\n            \n            ws.on('error', (error) => {\n                console.error(`WebSocket error for ${participantId}:`, error);\n            });\n        });\n        \n        console.log('ðŸŒ Multiplayer server listening on port 9103');\n    }\n    \n    async initializeDatabaseStream() {\n        const databaseParticipant = {\n            id: 'database_primary',\n            type: 'database',\n            connection: null, // Direct connection, not WebSocket\n            capabilities: ['query', 'learn', 'store', 'analyze'],\n            knowledgeBase: new Map(),\n            learningRate: 0.8,\n            responseTime: 'variable'\n        };\n        \n        this.participants.set('database_primary', databaseParticipant);\n        \n        // Create us-database reality stream\n        const databaseStream = this.createRealityStream('us-database', {\n            participants: ['user_primary', 'database_primary'],\n            purpose: 'learning_and_building',\n            persistence: 'high'\n        });\n        \n        this.activeStreams.set('us-database', databaseStream);\n        \n        console.log('ðŸ“š Database reality stream initialized');\n    }\n    \n    async initializeNPCSystem() {\n        // Create some sample NPCs\n        const npcs = [\n            {\n                id: 'npc_guide',\n                name: 'Reality Guide',\n                personality: 'helpful',\n                capabilities: ['explain', 'guide', 'assist'],\n                knowledgeDomains: ['reality_mechanics', 'context_switching', 'ui_navigation'],\n                responseStyle: 'conversational'\n            },\n            {\n                id: 'npc_challenger',\n                name: 'System Challenger',\n                personality: 'challenging',\n                capabilities: ['question', 'test', 'verify'],\n                knowledgeDomains: ['security', 'validation', 'edge_cases'],\n                responseStyle: 'analytical'\n            },\n            {\n                id: 'npc_observer',\n                name: 'Silent Observer',\n                personality: 'observant',\n                capabilities: ['monitor', 'record', 'analyze'],\n                knowledgeDomains: ['patterns', 'behavior', 'optimization'],\n                responseStyle: 'minimal'\n            }\n        ];\n        \n        npcs.forEach(npc => {\n            this.participants.set(npc.id, {\n                ...npc,\n                type: 'npcs',\n                connection: null, // AI-driven, not WebSocket\n                lastInteraction: Date.now(),\n                interactionHistory: []\n            });\n        });\n        \n        console.log(`ðŸ¤– Initialized ${npcs.length} NPCs`);\n    }\n    \n    createRealityStream(streamType, options = {}) {\n        const template = this.streamTypes[streamType];\n        if (!template) {\n            throw new Error(`Unknown stream type: ${streamType}`);\n        }\n        \n        const stream = {\n            id: this.generateStreamId(),\n            type: streamType,\n            name: template.name,\n            description: template.description,\n            lagSettings: { ...template.lagSettings, ...options.lagSettings },\n            participants: new Set(options.participants || []),\n            syncMode: options.syncMode || template.syncMode,\n            persistence: options.persistence || template.persistence,\n            \n            // Reality state\n            realityState: {\n                entities: new Map(),\n                interactions: [],\n                knowledgeGraph: new Map(),\n                sharedContext: {},\n                timestamp: Date.now()\n            },\n            \n            // Stream metadata\n            createdAt: Date.now(),\n            lastUpdate: Date.now(),\n            updateCount: 0,\n            conflictCount: 0,\n            \n            // Stream configuration\n            config: {\n                maxParticipants: options.maxParticipants || 10,\n                conflictResolution: this.syncModes[template.syncMode]?.conflictResolution || 'consensus',\n                updateFrequency: this.syncModes[template.syncMode]?.updateFrequency || 'medium',\n                persistenceLevel: template.persistence\n            }\n        };\n        \n        // Initialize reality bridge integration\n        if (this.realityBridge) {\n            this.integrateWithRealityBridge(stream);\n        }\n        \n        console.log(`ðŸŒŠ Created reality stream: ${stream.name} (${stream.id})`);\n        \n        return stream;\n    }\n    \n    integrateWithRealityBridge(stream) {\n        // Connect stream to reality bridge for lag processing\n        stream.realityBridgeIntegration = {\n            enabled: true,\n            lagProcessor: (data) => {\n                return this.processStreamLag(stream, data);\n            },\n            entitySync: (entities) => {\n                return this.syncStreamEntities(stream, entities);\n            }\n        };\n    }\n    \n    processStreamLag(stream, data) {\n        const { lagSettings } = stream;\n        const now = Date.now();\n        \n        // Apply stream-specific lag processing\n        switch (stream.syncMode) {\n            case 'synchronous':\n                // All participants get same lag\n                return this.applySynchronousLag(stream, data, now);\n                \n            case 'asynchronous':\n                // Each participant can have different lag\n                return this.applyAsynchronousLag(stream, data, now);\n                \n            case 'responsive':\n                // Lag adapts to participant responses\n                return this.applyResponsiveLag(stream, data, now);\n                \n            case 'collaborative':\n                // Lag optimized for collaboration\n                return this.applyCollaborativeLag(stream, data, now);\n                \n            case 'adaptive':\n                // Lag mode changes based on context\n                return this.applyAdaptiveLag(stream, data, now);\n                \n            default:\n                return this.applyDefaultLag(stream, data, now);\n        }\n    }\n    \n    applySynchronousLag(stream, data, now) {\n        const lag = stream.lagSettings.baseDelay + \n                   Math.sin(now * 0.001) * stream.lagSettings.oscillationRange;\n        \n        // All participants get exactly the same lag\n        const processedData = {\n            ...data,\n            lagAmount: lag,\n            syncTimestamp: now,\n            participants: Array.from(stream.participants)\n        };\n        \n        return processedData;\n    }\n    \n    applyAsynchronousLag(stream, data, now) {\n        // Each participant can be at different points in reality\n        const processedData = { ...data, participantLags: {} };\n        \n        stream.participants.forEach(participantId => {\n            const participant = this.participants.get(participantId);\n            if (participant) {\n                const participantLag = this.calculateParticipantLag(participant, stream, now);\n                processedData.participantLags[participantId] = participantLag;\n            }\n        });\n        \n        return processedData;\n    }\n    \n    applyResponsiveLag(stream, data, now) {\n        // Lag adapts to how quickly participants respond\n        const avgResponseTime = this.calculateAverageResponseTime(stream);\n        const adaptiveLag = Math.max(\n            stream.lagSettings.baseDelay * 0.5,\n            Math.min(stream.lagSettings.baseDelay * 2, avgResponseTime * 1.2)\n        );\n        \n        return {\n            ...data,\n            lagAmount: adaptiveLag,\n            responsiveness: avgResponseTime,\n            adaptation: 'responsive'\n        };\n    }\n    \n    applyCollaborativeLag(stream, data, now) {\n        // Lag optimized for collaborative work\n        const collaborationFactor = this.calculateCollaborationFactor(stream);\n        const collaborativeLag = stream.lagSettings.baseDelay * (1 + collaborationFactor * 0.3);\n        \n        return {\n            ...data,\n            lagAmount: collaborativeLag,\n            collaborationFactor,\n            sharedKnowledge: this.getSharedKnowledge(stream)\n        };\n    }\n    \n    applyAdaptiveLag(stream, data, now) {\n        // Lag mode changes based on current context\n        const context = this.contextManager.getCurrentContext();\n        const contextLag = context.definition.lagSettings;\n        \n        const adaptedLag = {\n            baseDelay: (stream.lagSettings.baseDelay + contextLag.baseDelay) / 2,\n            oscillationRange: Math.max(stream.lagSettings.oscillationRange, contextLag.oscillationRange),\n            contextInfluence: 0.7\n        };\n        \n        return {\n            ...data,\n            lagAmount: adaptedLag.baseDelay + Math.sin(now * 0.001) * adaptedLag.oscillationRange,\n            contextInfluence: adaptedLag.contextInfluence,\n            adaptiveMode: true\n        };\n    }\n    \n    calculateParticipantLag(participant, stream, now) {\n        const baseDelay = stream.lagSettings.baseDelay;\n        const participantType = this.participantTypes[participant.type];\n        \n        // Adjust lag based on participant type\n        let typeMultiplier = 1.0;\n        switch (participant.type) {\n            case 'user':\n                typeMultiplier = 1.0; // Normal human lag\n                break;\n            case 'database':\n                typeMultiplier = 2.0; // Database queries take longer\n                break;\n            case 'players':\n                typeMultiplier = 0.8; // Slightly faster for collaboration\n                break;\n            case 'npcs':\n                typeMultiplier = 0.6; // AI can respond faster\n                break;\n        }\n        \n        return baseDelay * typeMultiplier;\n    }\n    \n    calculateAverageResponseTime(stream) {\n        // Calculate average response time for participants in this stream\n        let totalTime = 0;\n        let responseCount = 0;\n        \n        stream.participants.forEach(participantId => {\n            const participant = this.participants.get(participantId);\n            if (participant && participant.interactionHistory) {\n                const recentInteractions = participant.interactionHistory.slice(-10);\n                recentInteractions.forEach(interaction => {\n                    if (interaction.responseTime) {\n                        totalTime += interaction.responseTime;\n                        responseCount++;\n                    }\n                });\n            }\n        });\n        \n        return responseCount > 0 ? totalTime / responseCount : stream.lagSettings.baseDelay;\n    }\n    \n    calculateCollaborationFactor(stream) {\n        // Calculate how much collaboration is happening\n        const interactions = stream.realityState.interactions;\n        const recentInteractions = interactions.filter(i => \n            Date.now() - i.timestamp < 60000 // Last minute\n        );\n        \n        const collaborativeInteractions = recentInteractions.filter(i => \n            i.type === 'collaborative' || i.participants.length > 1\n        );\n        \n        return recentInteractions.length > 0 ? \n               collaborativeInteractions.length / recentInteractions.length : 0;\n    }\n    \n    getSharedKnowledge(stream) {\n        // Extract knowledge that's been shared across participants\n        const sharedKnowledge = {};\n        \n        stream.realityState.knowledgeGraph.forEach((knowledge, key) => {\n            if (knowledge.sharedBy && knowledge.sharedBy.length > 1) {\n                sharedKnowledge[key] = {\n                    content: knowledge.content,\n                    contributors: knowledge.sharedBy,\n                    confidence: knowledge.confidence || 0.5\n                };\n            }\n        });\n        \n        return sharedKnowledge;\n    }\n    \n    registerParticipant(participantId, participantData) {\n        this.participants.set(participantId, {\n            id: participantId,\n            ...participantData,\n            registeredAt: Date.now(),\n            interactionHistory: [],\n            realityStreams: new Set()\n        });\n        \n        // Add to connections map if WebSocket\n        if (participantData.connection) {\n            this.connections.set(participantId, participantData.connection);\n        }\n        \n        this.emit('participant-registered', {\n            participantId,\n            type: participantData.type,\n            timestamp: Date.now()\n        });\n        \n        console.log(`ðŸ‘¤ Registered participant: ${participantId} (${participantData.type})`);\n    }\n    \n    unregisterParticipant(participantId) {\n        const participant = this.participants.get(participantId);\n        \n        if (participant) {\n            // Remove from all reality streams\n            participant.realityStreams.forEach(streamId => {\n                const stream = this.activeStreams.get(streamId);\n                if (stream) {\n                    stream.participants.delete(participantId);\n                }\n            });\n            \n            // Remove from connections\n            this.connections.delete(participantId);\n            \n            // Remove participant\n            this.participants.delete(participantId);\n            \n            this.emit('participant-unregistered', {\n                participantId,\n                type: participant.type,\n                timestamp: Date.now()\n            });\n            \n            console.log(`ðŸ‘¤ Unregistered participant: ${participantId}`);\n        }\n    }\n    \n    addParticipantToStream(participantId, streamId) {\n        const participant = this.participants.get(participantId);\n        const stream = this.activeStreams.get(streamId);\n        \n        if (!participant) {\n            throw new Error(`Participant not found: ${participantId}`);\n        }\n        \n        if (!stream) {\n            throw new Error(`Stream not found: ${streamId}`);\n        }\n        \n        // Check if stream has room\n        if (stream.participants.size >= stream.config.maxParticipants) {\n            throw new Error(`Stream is full: ${streamId}`);\n        }\n        \n        // Add participant to stream\n        stream.participants.add(participantId);\n        participant.realityStreams.add(streamId);\n        \n        // Send stream state to participant\n        this.sendStreamState(participantId, stream);\n        \n        this.emit('participant-joined-stream', {\n            participantId,\n            streamId,\n            streamType: stream.type,\n            participantCount: stream.participants.size\n        });\n        \n        console.log(`ðŸ‘¤ ${participantId} joined stream: ${stream.name}`);\n    }\n    \n    removeParticipantFromStream(participantId, streamId) {\n        const participant = this.participants.get(participantId);\n        const stream = this.activeStreams.get(streamId);\n        \n        if (participant && stream) {\n            stream.participants.delete(participantId);\n            participant.realityStreams.delete(streamId);\n            \n            this.emit('participant-left-stream', {\n                participantId,\n                streamId,\n                participantCount: stream.participants.size\n            });\n            \n            console.log(`ðŸ‘¤ ${participantId} left stream: ${stream.name}`);\n        }\n    }\n    \n    handleParticipantMessage(participantId, message) {\n        try {\n            const data = JSON.parse(message);\n            const participant = this.participants.get(participantId);\n            \n            if (!participant) {\n                console.warn(`Message from unknown participant: ${participantId}`);\n                return;\n            }\n            \n            // Record interaction\n            participant.interactionHistory.push({\n                type: data.type,\n                content: data.content,\n                timestamp: Date.now(),\n                responseTime: data.responseTime\n            });\n            \n            // Process message based on type\n            switch (data.type) {\n                case 'join-stream':\n                    this.addParticipantToStream(participantId, data.streamId);\n                    break;\n                    \n                case 'leave-stream':\n                    this.removeParticipantFromStream(participantId, data.streamId);\n                    break;\n                    \n                case 'reality-update':\n                    this.handleRealityUpdate(participantId, data);\n                    break;\n                    \n                case 'knowledge-share':\n                    this.handleKnowledgeShare(participantId, data);\n                    break;\n                    \n                case 'interaction':\n                    this.handleParticipantInteraction(participantId, data);\n                    break;\n                    \n                case 'context-hint':\n                    this.contextManager.addContextHint({\n                        type: 'participant',\n                        data: data.hint,\n                        source: participantId\n                    });\n                    break;\n                    \n                default:\n                    console.warn(`Unknown message type: ${data.type}`);\n            }\n            \n        } catch (error) {\n            console.error(`Error processing message from ${participantId}:`, error);\n        }\n    }\n    \n    handleRealityUpdate(participantId, data) {\n        const { streamId, entityId, position, velocity, state } = data;\n        const stream = this.activeStreams.get(streamId);\n        \n        if (!stream || !stream.participants.has(participantId)) {\n            console.warn(`Invalid reality update from ${participantId}`);\n            return;\n        }\n        \n        // Update entity in stream reality state\n        stream.realityState.entities.set(entityId, {\n            id: entityId,\n            position,\n            velocity,\n            state,\n            lastUpdatedBy: participantId,\n            timestamp: Date.now()\n        });\n        \n        // Broadcast update to other participants\n        this.broadcastToStream(streamId, {\n            type: 'entity-update',\n            entityId,\n            position,\n            velocity,\n            state,\n            updatedBy: participantId\n        }, participantId); // Exclude sender\n        \n        stream.lastUpdate = Date.now();\n        stream.updateCount++;\n    }\n    \n    handleKnowledgeShare(participantId, data) {\n        const { streamId, knowledge, confidence } = data;\n        const stream = this.activeStreams.get(streamId);\n        \n        if (!stream || !stream.participants.has(participantId)) {\n            console.warn(`Invalid knowledge share from ${participantId}`);\n            return;\n        }\n        \n        // Add knowledge to stream knowledge graph\n        const knowledgeId = this.generateKnowledgeId();\n        stream.realityState.knowledgeGraph.set(knowledgeId, {\n            id: knowledgeId,\n            content: knowledge,\n            confidence: confidence || 0.5,\n            sharedBy: [participantId],\n            timestamp: Date.now(),\n            verifications: 0\n        });\n        \n        // Notify other participants\n        this.broadcastToStream(streamId, {\n            type: 'knowledge-shared',\n            knowledgeId,\n            knowledge,\n            sharedBy: participantId,\n            confidence\n        }, participantId);\n        \n        console.log(`ðŸ“š Knowledge shared in ${stream.name} by ${participantId}`);\n    }\n    \n    handleParticipantInteraction(participantId, data) {\n        const { streamId, targetParticipant, interactionType, content } = data;\n        const stream = this.activeStreams.get(streamId);\n        \n        if (!stream || !stream.participants.has(participantId)) {\n            console.warn(`Invalid interaction from ${participantId}`);\n            return;\n        }\n        \n        // Record interaction in stream\n        stream.realityState.interactions.push({\n            id: this.generateInteractionId(),\n            from: participantId,\n            to: targetParticipant,\n            type: interactionType,\n            content,\n            timestamp: Date.now(),\n            streamId\n        });\n        \n        // Handle different interaction types\n        switch (interactionType) {\n            case 'database-query':\n                this.handleDatabaseQuery(participantId, content, streamId);\n                break;\n                \n            case 'npc-dialogue':\n                this.handleNPCDialogue(participantId, targetParticipant, content, streamId);\n                break;\n                \n            case 'player-message':\n                this.handlePlayerMessage(participantId, targetParticipant, content, streamId);\n                break;\n                \n            default:\n                console.log(`ðŸ“§ ${interactionType} interaction: ${participantId} â†’ ${targetParticipant}`);\n        }\n    }\n    \n    async handleDatabaseQuery(participantId, query, streamId) {\n        // Simulate database interaction with learning\n        const response = {\n            query,\n            results: this.simulateDatabaseQuery(query),\n            learningInsights: this.generateLearningInsights(query),\n            timestamp: Date.now()\n        };\n        \n        // Send response with appropriate lag\n        setTimeout(() => {\n            this.sendToParticipant(participantId, {\n                type: 'database-response',\n                streamId,\n                response\n            });\n        }, 800 + Math.random() * 400); // Database lag simulation\n    }\n    \n    async handleNPCDialogue(participantId, npcId, message, streamId) {\n        const npc = this.participants.get(npcId);\n        \n        if (!npc || npc.type !== 'npcs') {\n            console.warn(`Invalid NPC dialogue target: ${npcId}`);\n            return;\n        }\n        \n        // Generate NPC response based on personality and knowledge\n        const response = this.generateNPCResponse(npc, message, participantId);\n        \n        // Send response with NPC-appropriate lag\n        setTimeout(() => {\n            this.sendToParticipant(participantId, {\n                type: 'npc-response',\n                streamId,\n                npcId,\n                response\n            });\n            \n            // Also broadcast to stream so others can see NPC interactions\n            this.broadcastToStream(streamId, {\n                type: 'npc-interaction',\n                participantId,\n                npcId,\n                message,\n                response\n            });\n            \n        }, 200 + Math.random() * 300); // NPC response lag\n    }\n    \n    handlePlayerMessage(participantId, targetPlayerId, message, streamId) {\n        // Direct player-to-player communication\n        this.sendToParticipant(targetPlayerId, {\n            type: 'player-message',\n            streamId,\n            from: participantId,\n            message,\n            timestamp: Date.now()\n        });\n    }\n    \n    simulateDatabaseQuery(query) {\n        // Simulate database query results\n        return {\n            success: true,\n            rows: Math.floor(Math.random() * 100) + 1,\n            executionTime: Math.random() * 500 + 50,\n            sample: {\n                id: Math.floor(Math.random() * 1000),\n                name: `Sample Data ${Math.floor(Math.random() * 100)}`,\n                value: Math.random() * 100\n            }\n        };\n    }\n    \n    generateLearningInsights(query) {\n        // Generate learning insights from query\n        const insights = [\n            'Query pattern suggests exploration of data relationships',\n            'This type of query often leads to additional related queries',\n            'Consider indexing these columns for better performance',\n            'Pattern indicates learning about data structure'\n        ];\n        \n        return insights[Math.floor(Math.random() * insights.length)];\n    }\n    \n    generateNPCResponse(npc, message, participantId) {\n        // Generate contextual NPC response\n        const responses = {\n            helpful: [\n                \"I'd be happy to help you with that!\",\n                \"Let me guide you through this process.\",\n                \"That's a great question! Here's what I know...\",\n                \"I can show you a better way to approach this.\"\n            ],\n            challenging: [\n                \"Are you sure that's the right approach?\",\n                \"Have you considered the security implications?\",\n                \"What evidence do you have for that assumption?\",\n                \"That might work, but what about edge cases?\"\n            ],\n            observant: [\n                \"Interesting pattern in your interactions.\",\n                \"I've noticed you prefer this method.\",\n                \"Your approach has been evolving.\",\n                \"*observes silently*\"\n            ]\n        };\n        \n        const personalityResponses = responses[npc.personality] || responses.helpful;\n        return personalityResponses[Math.floor(Math.random() * personalityResponses.length)];\n    }\n    \n    broadcastToStream(streamId, message, excludeParticipant = null) {\n        const stream = this.activeStreams.get(streamId);\n        if (!stream) return;\n        \n        stream.participants.forEach(participantId => {\n            if (participantId !== excludeParticipant) {\n                this.sendToParticipant(participantId, message);\n            }\n        });\n    }\n    \n    sendToParticipant(participantId, message) {\n        const connection = this.connections.get(participantId);\n        \n        if (connection && connection.readyState === WebSocket.OPEN) {\n            connection.send(JSON.stringify(message));\n        } else {\n            // Handle non-WebSocket participants (database, NPCs)\n            this.handleNonWebSocketMessage(participantId, message);\n        }\n    }\n    \n    handleNonWebSocketMessage(participantId, message) {\n        const participant = this.participants.get(participantId);\n        \n        if (!participant) return;\n        \n        switch (participant.type) {\n            case 'database':\n                // Handle database messages\n                console.log(`ðŸ“š Database message: ${message.type}`);\n                break;\n                \n            case 'npcs':\n                // Handle NPC messages\n                console.log(`ðŸ¤– NPC message to ${participant.name}: ${message.type}`);\n                break;\n        }\n    }\n    \n    sendInitialRealityState(ws, participantId) {\n        const initialState = {\n            type: 'initial-state',\n            participantId,\n            activeStreams: Array.from(this.activeStreams.values()).map(stream => ({\n                id: stream.id,\n                type: stream.type,\n                name: stream.name,\n                description: stream.description,\n                participantCount: stream.participants.size,\n                syncMode: stream.syncMode\n            })),\n            participants: Array.from(this.participants.values()).map(p => ({\n                id: p.id,\n                type: p.type,\n                name: p.name || p.id\n            })),\n            contextManager: this.contextManager.getCurrentContext()\n        };\n        \n        ws.send(JSON.stringify(initialState));\n    }\n    \n    sendStreamState(participantId, stream) {\n        const streamState = {\n            type: 'stream-state',\n            stream: {\n                id: stream.id,\n                type: stream.type,\n                name: stream.name,\n                participants: Array.from(stream.participants),\n                entities: Array.from(stream.realityState.entities.values()),\n                sharedContext: stream.realityState.sharedContext,\n                knowledgeCount: stream.realityState.knowledgeGraph.size\n            }\n        };\n        \n        this.sendToParticipant(participantId, streamState);\n    }\n    \n    handleContextChange(contextData) {\n        // Adapt reality streams to new context\n        const newContext = contextData.context;\n        const contextDef = contextData.definition;\n        \n        console.log(`ðŸ”„ Adapting reality streams for context: ${contextDef.name}`);\n        \n        // Check if we need to create a context-specific stream\n        const contextStreamType = this.mapContextToStreamType(newContext);\n        \n        if (contextStreamType && !this.activeStreams.has(contextStreamType)) {\n            const contextStream = this.createRealityStream(contextStreamType, {\n                participants: ['user_primary'],\n                purpose: `context_${newContext}`,\n                persistence: 'medium'\n            });\n            \n            this.activeStreams.set(contextStreamType, contextStream);\n        }\n        \n        // Update lag settings for all streams\n        this.activeStreams.forEach(stream => {\n            if (stream.config.adaptToContext !== false) {\n                this.adaptStreamToContext(stream, contextDef);\n            }\n        });\n    }\n    \n    mapContextToStreamType(context) {\n        const mapping = {\n            database: 'us-database',\n            multiplayer: 'us-players',\n            games: 'us-players',\n            centipede: 'us-npcs',\n            ships: 'us-database',\n            economics: 'us-database'\n        };\n        \n        return mapping[context] || null;\n    }\n    \n    adaptStreamToContext(stream, contextDefinition) {\n        // Adapt stream lag settings to match context\n        const contextLag = contextDefinition.lagSettings;\n        \n        stream.lagSettings = {\n            ...stream.lagSettings,\n            baseDelay: (stream.lagSettings.baseDelay + contextLag.baseDelay) / 2,\n            oscillationRange: Math.max(stream.lagSettings.oscillationRange, contextLag.oscillationRange || 100),\n            contextAdapted: true\n        };\n        \n        console.log(`ðŸŽ›ï¸ Adapted stream ${stream.name} for context: ${contextDefinition.name}`);\n    }\n    \n    startRealitySynchronization() {\n        // Synchronize reality streams every 50ms\n        setInterval(() => {\n            this.activeStreams.forEach(stream => {\n                this.synchronizeStream(stream);\n            });\n        }, 50);\n        \n        // Deep synchronization every 5 seconds\n        setInterval(() => {\n            this.performDeepSynchronization();\n        }, 5000);\n    }\n    \n    synchronizeStream(stream) {\n        // Update stream based on sync mode\n        switch (stream.syncMode) {\n            case 'synchronous':\n                this.performSynchronousSync(stream);\n                break;\n                \n            case 'asynchronous':\n                this.performAsynchronousSync(stream);\n                break;\n                \n            case 'responsive':\n                this.performResponsiveSync(stream);\n                break;\n                \n            case 'collaborative':\n                this.performCollaborativeSync(stream);\n                break;\n                \n            case 'adaptive':\n                this.performAdaptiveSync(stream);\n                break;\n        }\n    }\n    \n    performSynchronousSync(stream) {\n        // Ensure all participants see the same reality state\n        const syncMessage = {\n            type: 'sync-update',\n            streamId: stream.id,\n            timestamp: Date.now(),\n            entities: Array.from(stream.realityState.entities.values()),\n            syncMode: 'synchronous'\n        };\n        \n        this.broadcastToStream(stream.id, syncMessage);\n    }\n    \n    performAsynchronousSync(stream) {\n        // Allow participants to be at different points\n        stream.participants.forEach(participantId => {\n            const participant = this.participants.get(participantId);\n            if (participant) {\n                const personalizedSync = this.createPersonalizedSync(stream, participant);\n                this.sendToParticipant(participantId, personalizedSync);\n            }\n        });\n    }\n    \n    performResponsiveSync(stream) {\n        // Sync based on participant responsiveness\n        const avgResponseTime = this.calculateAverageResponseTime(stream);\n        \n        if (avgResponseTime < 500) {\n            // Fast responders - increase sync frequency\n            this.performSynchronousSync(stream);\n        } else {\n            // Slower responders - reduce sync frequency\n            if (Math.random() < 0.3) {\n                this.performSynchronousSync(stream);\n            }\n        }\n    }\n    \n    performCollaborativeSync(stream) {\n        // Sync optimized for collaboration\n        const collaborativeUpdate = {\n            type: 'collaborative-sync',\n            streamId: stream.id,\n            sharedKnowledge: this.getSharedKnowledge(stream),\n            collaborationFactor: this.calculateCollaborationFactor(stream),\n            timestamp: Date.now()\n        };\n        \n        this.broadcastToStream(stream.id, collaborativeUpdate);\n    }\n    \n    performAdaptiveSync(stream) {\n        // Sync mode adapts to current conditions\n        const context = this.contextManager.getCurrentContext();\n        const participantCount = stream.participants.size;\n        const activity = stream.realityState.interactions.length;\n        \n        let adaptedSyncMode = 'synchronous';\n        \n        if (context.context === 'database') {\n            adaptedSyncMode = 'asynchronous';\n        } else if (participantCount > 3) {\n            adaptedSyncMode = 'collaborative';\n        } else if (activity > 10) {\n            adaptedSyncMode = 'responsive';\n        }\n        \n        // Temporarily change sync mode\n        const originalSyncMode = stream.syncMode;\n        stream.syncMode = adaptedSyncMode;\n        this.synchronizeStream(stream);\n        stream.syncMode = originalSyncMode;\n    }\n    \n    createPersonalizedSync(stream, participant) {\n        return {\n            type: 'personalized-sync',\n            streamId: stream.id,\n            participantId: participant.id,\n            personalizedLag: this.calculateParticipantLag(participant, stream, Date.now()),\n            relevantEntities: this.getRelevantEntities(stream, participant),\n            timestamp: Date.now()\n        };\n    }\n    \n    getRelevantEntities(stream, participant) {\n        // Get entities relevant to this specific participant\n        return Array.from(stream.realityState.entities.values()).filter(entity => {\n            // Simple relevance: entities updated by this participant or recently\n            return entity.lastUpdatedBy === participant.id || \n                   Date.now() - entity.timestamp < 5000;\n        });\n    }\n    \n    performDeepSynchronization() {\n        // Perform deep analysis and synchronization\n        console.log(`ðŸ”„ Deep sync: ${this.activeStreams.size} streams, ${this.participants.size} participants`);\n        \n        // Clean up old interactions\n        this.activeStreams.forEach(stream => {\n            const oneMinuteAgo = Date.now() - 60000;\n            stream.realityState.interactions = stream.realityState.interactions.filter(\n                interaction => interaction.timestamp > oneMinuteAgo\n            );\n        });\n    }\n    \n    // === UTILITY METHODS ===\n    \n    generateParticipantId() {\n        return `participant_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    generateStreamId() {\n        return `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    generateKnowledgeId() {\n        return `knowledge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    generateInteractionId() {\n        return `interaction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    // === PUBLIC API ===\n    \n    getActiveStreams() {\n        return Array.from(this.activeStreams.values());\n    }\n    \n    getParticipants() {\n        return Array.from(this.participants.values());\n    }\n    \n    getStreamById(streamId) {\n        return this.activeStreams.get(streamId);\n    }\n    \n    getParticipantById(participantId) {\n        return this.participants.get(participantId);\n    }\n    \n    createCustomStream(streamType, options) {\n        const stream = this.createRealityStream(streamType, options);\n        this.activeStreams.set(stream.id, stream);\n        return stream;\n    }\n    \n    getMultiplayerStats() {\n        return {\n            totalParticipants: this.participants.size,\n            activeStreams: this.activeStreams.size,\n            totalConnections: this.connections.size,\n            participantTypes: this.getParticipantTypeBreakdown(),\n            streamTypes: this.getStreamTypeBreakdown(),\n            avgResponseTime: this.calculateGlobalAverageResponseTime()\n        };\n    }\n    \n    getParticipantTypeBreakdown() {\n        const breakdown = {};\n        this.participants.forEach(participant => {\n            breakdown[participant.type] = (breakdown[participant.type] || 0) + 1;\n        });\n        return breakdown;\n    }\n    \n    getStreamTypeBreakdown() {\n        const breakdown = {};\n        this.activeStreams.forEach(stream => {\n            breakdown[stream.type] = (breakdown[stream.type] || 0) + 1;\n        });\n        return breakdown;\n    }\n    \n    calculateGlobalAverageResponseTime() {\n        let totalTime = 0;\n        let responseCount = 0;\n        \n        this.participants.forEach(participant => {\n            if (participant.interactionHistory) {\n                participant.interactionHistory.forEach(interaction => {\n                    if (interaction.responseTime) {\n                        totalTime += interaction.responseTime;\n                        responseCount++;\n                    }\n                });\n            }\n        });\n        \n        return responseCount > 0 ? totalTime / responseCount : 0;\n    }\n}\n\nmodule.exports = MultiplayerRealityManager;\n\n// CLI interface (if run directly)\nif (require.main === module) {\n    const UniversalContextManager = require('./universal-context-manager');\n    const RealityBridgeConnector = require('./reality-bridge-connector');\n    \n    const contextManager = new UniversalContextManager();\n    const realityBridge = new RealityBridgeConnector();\n    const multiplayerManager = new MultiplayerRealityManager(realityBridge, contextManager);\n    \n    // Listen for multiplayer events\n    multiplayerManager.on('participant-registered', (data) => {\n        console.log(`\\nðŸ‘¤ New participant: ${data.participantId} (${data.type})`);\n    });\n    \n    multiplayerManager.on('participant-joined-stream', (data) => {\n        console.log(`\\nðŸŒŠ ${data.participantId} joined ${data.streamType} (${data.participantCount} total)`);\n    });\n    \n    // Show stats every 10 seconds\n    setInterval(() => {\n        const stats = multiplayerManager.getMultiplayerStats();\n        console.log(`\\nðŸ“Š Multiplayer Stats:`);\n        console.log(`   Participants: ${stats.totalParticipants}`);\n        console.log(`   Active Streams: ${stats.activeStreams}`);\n        console.log(`   Connections: ${stats.totalConnections}`);\n        console.log(`   Avg Response: ${Math.round(stats.avgResponseTime)}ms`);\n    }, 10000);\n    \n    // Test creating streams\n    setTimeout(() => {\n        console.log('\\nðŸ§ª Testing multiplayer streams...');\n        \n        // Create test streams\n        const playerStream = multiplayerManager.createCustomStream('us-players', {\n            maxParticipants: 5,\n            purpose: 'testing'\n        });\n        \n        const npcStream = multiplayerManager.createCustomStream('us-npcs', {\n            maxParticipants: 3,\n            purpose: 'testing'\n        });\n        \n        console.log(`\\nðŸŒŠ Created test streams:`);\n        console.log(`   Player Stream: ${playerStream.id}`);\n        console.log(`   NPC Stream: ${npcStream.id}`);\n        \n    }, 3000);\n    \n    // Graceful shutdown\n    process.on('SIGINT', () => {\n        console.log('\\nðŸ›‘ Shutting down Multiplayer Reality Manager...');\n        const stats = multiplayerManager.getMultiplayerStats();\n        console.log('ðŸ“ˆ Final Stats:', stats);\n        process.exit(0);\n    });\n};