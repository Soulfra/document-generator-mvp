<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üååüß¨ Visual Reasoning Universe - Genome to Cosmos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #000011;
            color: #00ff88;
            overflow: hidden;
            position: relative;
        }
        
        .universe-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at center, #000033 0%, #000011 70%, #000000 100%);
        }
        
        .zoom-level-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        
        .ai-command-interface {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
        }
        
        .command-input {
            width: 100%;
            background: transparent;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 5px;
            outline: none;
        }
        
        .ai-response {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.05);
            border-left: 3px solid #00ff88;
            min-height: 40px;
            border-radius: 3px;
        }
        
        .reasoning-display {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff88;
            border-radius: 5px;
            padding: 15px;
            z-index: 1000;
        }
        
        .swarm-agent {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .swarm-agent.builder {
            background: #ff6600;
            box-shadow: 0 0 8px #ff6600;
        }
        
        .swarm-agent.designer {
            background: #0066ff;
            box-shadow: 0 0 8px #0066ff;
        }
        
        .swarm-agent.analyst {
            background: #ff0066;
            box-shadow: 0 0 8px #ff0066;
        }
        
        .swarm-agent.manager {
            background: #66ff00;
            box-shadow: 0 0 8px #66ff00;
        }
        
        .construction-element {
            position: absolute;
            border: 1px solid #00ff88;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 3px;
            transition: all 0.5s ease;
            cursor: pointer;
        }
        
        .construction-element:hover {
            background: rgba(0, 255, 136, 0.3);
            transform: scale(1.05);
        }
        
        .zoom-controls {
            position: fixed;
            top: 120px;
            left: 20px;
            z-index: 1000;
        }
        
        .zoom-btn {
            display: block;
            margin: 5px 0;
            padding: 8px 12px;
            background: transparent;
            border: 1px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
            transition: all 0.3s ease;
        }
        
        .zoom-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }
        
        .connection-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, rgba(0, 255, 136, 0.5), rgba(0, 255, 136, 0.1));
            transform-origin: left center;
            pointer-events: none;
            z-index: 1;
        }
        
        .reasoning-thought {
            margin: 5px 0;
            padding: 5px;
            background: rgba(0, 255, 136, 0.05);
            border-left: 2px solid #00ff88;
            font-size: 11px;
            border-radius: 2px;
            animation: fadeInThought 0.5s ease;
        }
        
        @keyframes fadeInThought {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .zoom-genome { background: linear-gradient(45deg, #ff0066, #ff6600); }
        .zoom-cell { background: linear-gradient(45deg, #00ff88, #0066ff); }
        .zoom-organism { background: linear-gradient(45deg, #66ff00, #ff0066); }
        .zoom-ecosystem { background: linear-gradient(45deg, #0066ff, #66ff00); }
        .zoom-planet { background: linear-gradient(45deg, #ff6600, #00ff88); }
        .zoom-solar { background: linear-gradient(45deg, #ff0066, #0066ff); }
        .zoom-galaxy { background: linear-gradient(45deg, #66ff00, #ff6600); }
        .zoom-universe { background: linear-gradient(45deg, #00ff88, #ff0066); }
        
        .speaking-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 50%;
            width: 100px;
            height: 100px;
            display: none;
            animation: pulse 1s infinite;
            z-index: 2000;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
        }
        
        .voice-command-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            color: #00ff88;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .voice-command-btn:hover {
            background: rgba(0, 255, 136, 0.3);
            transform: scale(1.1);
        }
        
        .voice-command-btn.listening {
            background: rgba(255, 102, 0, 0.3);
            border-color: #ff6600;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="universe-container" id="universe">
        <!-- Zoom Level Indicator -->
        <div class="zoom-level-indicator">
            <div><strong>üîç Current Scale:</strong> <span id="current-scale">Organism</span></div>
            <div><strong>üìê Zoom Level:</strong> <span id="zoom-level">4</span>/8</div>
            <div><strong>üéØ Focus:</strong> <span id="focus-target">AI Swarm Colony</span></div>
        </div>
        
        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomTo(1)">üß¨ Genome</button>
            <button class="zoom-btn" onclick="zoomTo(2)">üî¨ Cell</button>
            <button class="zoom-btn" onclick="zoomTo(3)">ü¶† Organism</button>
            <button class="zoom-btn" onclick="zoomTo(4)">üå± Ecosystem</button>
            <button class="zoom-btn" onclick="zoomTo(5)">üåç Planet</button>
            <button class="zoom-btn" onclick="zoomTo(6)">‚òÄÔ∏è Solar</button>
            <button class="zoom-btn" onclick="zoomTo(7)">üåå Galaxy</button>
            <button class="zoom-btn" onclick="zoomTo(8)">‚ôæÔ∏è Universe</button>
        </div>
        
        <!-- AI Command Interface -->
        <div class="ai-command-interface">
            <input type="text" 
                   class="command-input" 
                   id="command-input" 
                   placeholder="Tell your AI what to build... (e.g., 'Create a solar system with habitable planets')"
                   onkeypress="handleCommand(event)">
            <div class="ai-response" id="ai-response">
                ü§ñ <strong>AI Ready:</strong> I'm listening and ready to build whatever you envision. My swarms are standing by.
            </div>
        </div>
        
        <!-- Voice Command Button -->
        <div class="voice-command-btn" id="voice-btn" onclick="toggleVoiceCommand()">
            üé§
        </div>
        
        <!-- Speaking Indicator -->
        <div class="speaking-indicator" id="speaking-indicator">
            <div style="text-align: center; margin-top: 35px; font-size: 12px;">üó£Ô∏è Speaking...</div>
        </div>
        
        <!-- Reasoning Display -->
        <div class="reasoning-display">
            <h4>üß† AI Reasoning Process</h4>
            <div id="reasoning-log">
                <div class="reasoning-thought">üéØ Initializing AI reasoning systems...</div>
                <div class="reasoning-thought">ü§ñ Activating swarm intelligence networks...</div>
                <div class="reasoning-thought">üèóÔ∏è Construction protocols online...</div>
                <div class="reasoning-thought">üí° Ready to receive and execute commands...</div>
            </div>
        </div>
    </div>

    <script>
        // Visual Reasoning Universe System
        class VisualReasoningUniverse {
            constructor() {
                this.currentZoom = 4; // Start at ecosystem level
                this.universe = document.getElementById('universe');
                this.swarmAgents = [];
                this.constructions = [];
                this.reasoningLog = document.getElementById('reasoning-log');
                this.isListening = false;
                this.recognition = null;
                
                // AI Personality
                this.aiPersonality = {
                    name: "Commander Nexus",
                    company: "Nexus Dynamics Corp",
                    swarmTypes: {
                        builders: { count: 12, color: '#ff6600', task: 'construction' },
                        designers: { count: 8, color: '#0066ff', task: 'design' },
                        analysts: { count: 6, color: '#ff0066', task: 'analysis' },
                        managers: { count: 4, color: '#66ff00', task: 'coordination' }
                    }
                };
                
                this.init();
            }
            
            init() {
                this.setupVoiceRecognition();
                this.createInitialSwarms();
                this.startReasoningCycle();
                this.updateZoomDisplay();
                
                // Add mouse controls for panning/zooming
                this.setupMouseControls();
                
                console.log('üåå Visual Reasoning Universe initialized');
                this.addReasoningThought('üåå Universe simulation online - ready for commands');
            }
            
            setupVoiceRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    
                    this.recognition.onresult = (event) => {
                        const command = event.results[0][0].transcript;
                        document.getElementById('command-input').value = command;
                        this.executeCommand(command);
                    };
                    
                    this.recognition.onend = () => {
                        this.setListeningState(false);
                    };
                    
                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        this.setListeningState(false);
                    };
                }
            }
            
            toggleVoiceCommand() {
                if (!this.recognition) {
                    this.addReasoningThought('‚ö†Ô∏è Voice recognition not supported in this browser');
                    return;
                }
                
                if (this.isListening) {
                    this.recognition.stop();
                    this.setListeningState(false);
                } else {
                    this.recognition.start();
                    this.setListeningState(true);
                    this.addReasoningThought('üé§ Listening for voice command...');
                }
            }
            
            setListeningState(listening) {
                this.isListening = listening;
                const btn = document.getElementById('voice-btn');
                const indicator = document.getElementById('speaking-indicator');
                
                if (listening) {
                    btn.className = 'voice-command-btn listening';
                    btn.innerHTML = 'üî¥';
                    indicator.style.display = 'block';
                } else {
                    btn.className = 'voice-command-btn';
                    btn.innerHTML = 'üé§';
                    indicator.style.display = 'none';
                }
            }
            
            createInitialSwarms() {
                this.addReasoningThought('ü§ñ Deploying AI swarms across the universe...');
                
                Object.entries(this.aiPersonality.swarmTypes).forEach(([type, config]) => {
                    for (let i = 0; i < config.count; i++) {
                        this.createSwarmAgent(type, config);
                    }
                });
                
                this.addReasoningThought(`‚úÖ ${this.swarmAgents.length} agents deployed and ready`);
            }
            
            createSwarmAgent(type, config) {
                const agent = {
                    id: `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    type: type,
                    task: config.task,
                    color: config.color,
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    energy: 100,
                    busy: false,
                    currentTask: null
                };
                
                const element = document.createElement('div');
                element.className = `swarm-agent ${type}`;
                element.style.left = agent.x + 'px';
                element.style.top = agent.y + 'px';
                element.title = `${type} Agent - ${config.task}`;
                element.onclick = () => this.inspectAgent(agent);
                
                this.universe.appendChild(element);
                agent.element = element;
                this.swarmAgents.push(agent);
                
                return agent;
            }
            
            executeCommand(command) {
                this.addReasoningThought(`üì• Received command: "${command}"`);
                this.updateAIResponse(`ü§ñ **Commander Nexus:** Processing your request...`);
                
                // Analyze command and determine response
                setTimeout(() => {
                    const response = this.analyzeAndRespond(command);
                    this.updateAIResponse(response.message);
                    this.executeConstruction(response.action, command);
                }, 1000);
            }
            
            analyzeAndRespond(command) {
                const cmd = command.toLowerCase();
                
                // Pattern matching for different types of requests
                if (cmd.includes('solar system') || cmd.includes('planets')) {
                    return {
                        message: `ü§ñ **Commander Nexus:** Excellent! I'll deploy my orbital construction swarms to create a solar system. Watch as my teams design planetary orbits, atmospheric compositions, and gravitational dynamics.`,
                        action: 'create_solar_system'
                    };
                } else if (cmd.includes('city') || cmd.includes('building') || cmd.includes('structure')) {
                    return {
                        message: `ü§ñ **Commander Nexus:** Perfect! My construction swarms will design and build urban structures. I'm coordinating builders, architects, and logistics teams to manifest your vision.`,
                        action: 'create_city'
                    };
                } else if (cmd.includes('galaxy') || cmd.includes('stars')) {
                    return {
                        message: `ü§ñ **Commander Nexus:** Magnificent scope! I'm scaling up to galactic construction. My swarms will coordinate stellar formation, spiral arm design, and cosmic structure engineering.`,
                        action: 'create_galaxy'
                    };
                } else if (cmd.includes('organism') || cmd.includes('life') || cmd.includes('biology')) {
                    return {
                        message: `ü§ñ **Commander Nexus:** Fascinating biological engineering challenge! My bio-design specialists will create organism patterns, genetic structures, and evolutionary pathways.`,
                        action: 'create_organism'
                    };
                } else if (cmd.includes('network') || cmd.includes('connection') || cmd.includes('web')) {
                    return {
                        message: `ü§ñ **Commander Nexus:** Network architecture engagement! My swarms will establish connection protocols, data flow patterns, and distributed intelligence networks.`,
                        action: 'create_network'
                    };
                } else {
                    return {
                        message: `ü§ñ **Commander Nexus:** Intriguing concept! I'm analyzing the best approach with my specialist teams. Watch as we break down your idea into actionable construction phases.`,
                        action: 'create_custom'
                    };
                }
            }
            
            executeConstruction(action, originalCommand) {
                this.addReasoningThought(`üèóÔ∏è Initiating construction protocol: ${action}`);
                this.addReasoningThought(`üë• Coordinating ${this.swarmAgents.length} agents for task execution`);
                
                // Assign agents to different aspects of the construction
                const builders = this.swarmAgents.filter(a => a.type === 'builders');
                const designers = this.swarmAgents.filter(a => a.type === 'designers');
                const analysts = this.swarmAgents.filter(a => a.type === 'analysts');
                const managers = this.swarmAgents.filter(a => a.type === 'managers');
                
                // Show coordination between agent types
                this.showSwarmCoordination(builders, designers, analysts, managers);
                
                // Execute the specific construction based on action
                switch (action) {
                    case 'create_solar_system':
                        this.constructSolarSystem();
                        break;
                    case 'create_city':
                        this.constructCity();
                        break;
                    case 'create_galaxy':
                        this.constructGalaxy();
                        break;
                    case 'create_organism':
                        this.constructOrganism();
                        break;
                    case 'create_network':
                        this.constructNetwork();
                        break;
                    default:
                        this.constructCustom(originalCommand);
                }
            }
            
            showSwarmCoordination(builders, designers, analysts, managers) {
                this.addReasoningThought(`üéØ Managers coordinating overall strategy...`);
                this.addReasoningThought(`üé® Designers creating blueprints and specifications...`);
                this.addReasoningThought(`üìä Analysts calculating optimal parameters...`);
                this.addReasoningThought(`üî® Builders preparing for physical construction...`);
                
                // Animate agents moving to coordination positions
                managers.forEach(agent => this.moveAgentToTask(agent, 'coordinating'));
                designers.forEach(agent => this.moveAgentToTask(agent, 'designing'));
                analysts.forEach(agent => this.moveAgentToTask(agent, 'analyzing'));
                builders.forEach(agent => this.moveAgentToTask(agent, 'building'));
            }
            
            moveAgentToTask(agent, taskType) {
                agent.busy = true;
                agent.currentTask = taskType;
                
                // Create task-specific movement patterns
                const patterns = {
                    coordinating: { centerX: window.innerWidth * 0.2, centerY: window.innerHeight * 0.2 },
                    designing: { centerX: window.innerWidth * 0.8, centerY: window.innerHeight * 0.2 },
                    analyzing: { centerX: window.innerWidth * 0.2, centerY: window.innerHeight * 0.8 },
                    building: { centerX: window.innerWidth * 0.8, centerY: window.innerHeight * 0.8 }
                };
                
                const pattern = patterns[taskType];
                const targetX = pattern.centerX + (Math.random() - 0.5) * 200;
                const targetY = pattern.centerY + (Math.random() - 0.5) * 200;
                
                // Animate movement
                agent.element.style.transition = 'all 2s ease';
                agent.element.style.left = targetX + 'px';
                agent.element.style.top = targetY + 'px';
                agent.element.style.transform = 'scale(1.5)';
                
                agent.x = targetX;
                agent.y = targetY;
                
                // Reset after task
                setTimeout(() => {
                    agent.busy = false;
                    agent.currentTask = null;
                    agent.element.style.transform = 'scale(1)';
                }, 3000);
            }
            
            constructSolarSystem() {
                this.addReasoningThought(`üåü Beginning solar system construction...`);
                zoomTo(6); // Solar system scale
                
                setTimeout(() => {
                    // Create central star
                    this.createConstructionElement('star', window.innerWidth/2, window.innerHeight/2, 40, 40, '#ffff00');
                    this.addReasoningThought(`‚≠ê Central star established with fusion core active`);
                    
                    // Create orbiting planets
                    const planets = [
                        { name: 'Inner', distance: 80, size: 15, color: '#ff6600' },
                        { name: 'Habitable', distance: 120, size: 20, color: '#0066ff' },
                        { name: 'Gas Giant', distance: 180, size: 35, color: '#ff0066' },
                        { name: 'Outer', distance: 240, size: 12, color: '#666666' }
                    ];
                    
                    planets.forEach((planet, index) => {
                        setTimeout(() => {
                            const angle = (index * 90) * Math.PI / 180;
                            const x = window.innerWidth/2 + Math.cos(angle) * planet.distance;
                            const y = window.innerHeight/2 + Math.sin(angle) * planet.distance;
                            
                            this.createConstructionElement(
                                `planet-${planet.name.toLowerCase()}`, 
                                x, y, planet.size, planet.size, planet.color
                            );
                            
                            this.addReasoningThought(`ü™ê ${planet.name} planet constructed with ${planet.color} atmosphere`);
                            
                            // Create orbital path
                            this.createOrbitalPath(window.innerWidth/2, window.innerHeight/2, planet.distance);
                            
                        }, index * 1000);
                    });
                    
                    this.addReasoningThought(`‚úÖ Solar system construction complete - 4 planets orbiting stable star`);
                }, 1000);
            }
            
            constructCity() {
                this.addReasoningThought(`üèôÔ∏è Beginning urban construction project...`);
                zoomTo(3); // Organism/city scale
                
                setTimeout(() => {
                    // Create grid-based city layout
                    const gridSize = 60;
                    const buildingTypes = [
                        { type: 'residential', color: '#00ff88', probability: 0.4 },
                        { type: 'commercial', color: '#0066ff', probability: 0.3 },
                        { type: 'industrial', color: '#ff6600', probability: 0.2 },
                        { type: 'park', color: '#66ff00', probability: 0.1 }
                    ];
                    
                    for (let x = 100; x < window.innerWidth - 100; x += gridSize) {
                        for (let y = 100; y < window.innerHeight - 100; y += gridSize) {
                            if (Math.random() > 0.3) { // 70% chance of building
                                const buildingType = this.selectRandomBuilding(buildingTypes);
                                const height = Math.random() * 40 + 20;
                                const width = Math.random() * 40 + 30;
                                
                                this.createConstructionElement(
                                    `building-${x}-${y}`,
                                    x, y, width, height, buildingType.color
                                );
                            }
                        }
                    }
                    
                    this.addReasoningThought(`üèóÔ∏è City construction complete - mixed-use urban development established`);
                }, 1000);
            }
            
            constructGalaxy() {
                this.addReasoningThought(`üåå Initiating galactic-scale construction...`);
                zoomTo(7); // Galaxy scale
                
                setTimeout(() => {
                    // Create spiral galaxy structure
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const arms = 4;
                    const starsPerArm = 30;
                    
                    for (let arm = 0; arm < arms; arm++) {
                        for (let i = 0; i < starsPerArm; i++) {
                            setTimeout(() => {
                                const armAngle = (arm * 2 * Math.PI / arms);
                                const distance = (i / starsPerArm) * 300 + 50;
                                const spiralAngle = armAngle + (i / starsPerArm) * Math.PI * 2;
                                
                                const x = centerX + Math.cos(spiralAngle) * distance;
                                const y = centerY + Math.sin(spiralAngle) * distance;
                                
                                const starSize = Math.random() * 6 + 2;
                                const starColor = this.getStarColor();
                                
                                this.createConstructionElement(
                                    `star-${arm}-${i}`,
                                    x, y, starSize, starSize, starColor
                                );
                                
                            }, (arm * starsPerArm + i) * 50);
                        }
                    }
                    
                    this.addReasoningThought(`üåå Spiral galaxy construction complete - 4 arms with ${arms * starsPerArm} stellar systems`);
                }, 1000);
            }
            
            constructOrganism() {
                this.addReasoningThought(`üß¨ Beginning biological organism construction...`);
                zoomTo(2); // Cell scale
                
                setTimeout(() => {
                    // Create cellular structure
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Cell nucleus
                    this.createConstructionElement('nucleus', centerX, centerY, 60, 60, '#ff0066');
                    this.addReasoningThought(`üß¨ Cell nucleus established - genetic control center active`);
                    
                    // Organelles
                    const organelles = [
                        { name: 'mitochondria', count: 8, color: '#ff6600', size: 15 },
                        { name: 'ribosomes', count: 12, color: '#0066ff', size: 8 },
                        { name: 'endoplasmic-reticulum', count: 4, color: '#66ff00', size: 25 }
                    ];
                    
                    organelles.forEach(organelle => {
                        for (let i = 0; i < organelle.count; i++) {
                            setTimeout(() => {
                                const angle = (i / organelle.count) * 2 * Math.PI;
                                const distance = 100 + Math.random() * 80;
                                const x = centerX + Math.cos(angle) * distance;
                                const y = centerY + Math.sin(angle) * distance;
                                
                                this.createConstructionElement(
                                    `${organelle.name}-${i}`,
                                    x, y, organelle.size, organelle.size, organelle.color
                                );
                                
                                this.addReasoningThought(`üî¨ ${organelle.name} ${i+1} constructed - cellular function active`);
                            }, i * 200);
                        }
                    });
                    
                    this.addReasoningThought(`‚úÖ Biological organism complete - fully functional cellular system`);
                }, 1000);
            }
            
            constructNetwork() {
                this.addReasoningThought(`üï∏Ô∏è Constructing distributed network architecture...`);
                
                setTimeout(() => {
                    // Create network nodes
                    const nodes = [];
                    const nodeCount = 15;
                    
                    for (let i = 0; i < nodeCount; i++) {
                        const x = Math.random() * (window.innerWidth - 200) + 100;
                        const y = Math.random() * (window.innerHeight - 200) + 100;
                        
                        const node = this.createConstructionElement(
                            `node-${i}`,
                            x, y, 20, 20, '#00ff88'
                        );
                        
                        nodes.push({ element: node, x: x, y: y, id: i });
                    }
                    
                    // Create connections between nodes
                    setTimeout(() => {
                        nodes.forEach((node, index) => {
                            // Connect to 2-4 other nodes
                            const connectionCount = Math.floor(Math.random() * 3) + 2;
                            const connections = [];
                            
                            for (let i = 0; i < connectionCount; i++) {
                                let targetIndex;
                                do {
                                    targetIndex = Math.floor(Math.random() * nodes.length);
                                } while (targetIndex === index || connections.includes(targetIndex));
                                
                                connections.push(targetIndex);
                                this.createConnection(node, nodes[targetIndex]);
                            }
                        });
                        
                        this.addReasoningThought(`üï∏Ô∏è Network construction complete - ${nodeCount} nodes with distributed connections`);
                    }, 1000);
                    
                }, 1000);
            }
            
            constructCustom(command) {
                this.addReasoningThought(`üé® Custom construction based on: "${command}"`);
                
                // Create a generative pattern based on command keywords
                const keywords = command.toLowerCase().split(' ');
                const elementCount = Math.min(keywords.length * 3, 20);
                
                for (let i = 0; i < elementCount; i++) {
                    setTimeout(() => {
                        const x = Math.random() * (window.innerWidth - 100) + 50;
                        const y = Math.random() * (window.innerHeight - 100) + 50;
                        const size = Math.random() * 30 + 10;
                        const color = this.generateColorFromWord(keywords[i % keywords.length]);
                        
                        this.createConstructionElement(
                            `custom-${i}`,
                            x, y, size, size, color
                        );
                        
                        this.addReasoningThought(`üéØ Custom element ${i+1} constructed from concept: "${keywords[i % keywords.length]}"`);
                    }, i * 300);
                }
            }
            
            // Helper methods
            createConstructionElement(id, x, y, width, height, color) {
                const element = document.createElement('div');
                element.className = 'construction-element';
                element.id = id;
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.width = width + 'px';
                element.style.height = height + 'px';
                element.style.backgroundColor = color;
                element.style.borderColor = color;
                element.title = `${id} - Built by AI Swarms`;
                
                this.universe.appendChild(element);
                this.constructions.push({ element, id, x, y, width, height, color });
                
                return element;
            }
            
            createOrbitalPath(centerX, centerY, radius) {
                const path = document.createElement('div');
                path.style.position = 'absolute';
                path.style.left = (centerX - radius) + 'px';
                path.style.top = (centerY - radius) + 'px';
                path.style.width = (radius * 2) + 'px';
                path.style.height = (radius * 2) + 'px';
                path.style.border = '1px dashed rgba(0, 255, 136, 0.3)';
                path.style.borderRadius = '50%';
                path.style.pointerEvents = 'none';
                
                this.universe.appendChild(path);
            }
            
            createConnection(node1, node2) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.left = node1.x + 'px';
                line.style.top = node1.y + 'px';
                line.style.width = distance + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                this.universe.appendChild(line);
            }
            
            selectRandomBuilding(buildingTypes) {
                const random = Math.random();
                let cumulative = 0;
                
                for (const building of buildingTypes) {
                    cumulative += building.probability;
                    if (random <= cumulative) {
                        return building;
                    }
                }
                
                return buildingTypes[0];
            }
            
            getStarColor() {
                const colors = ['#ffffff', '#ffff88', '#ff8888', '#8888ff', '#ff88ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            generateColorFromWord(word) {
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = word.charCodeAt(i) + ((hash << 5) - hash);
                }
                
                const colors = ['#00ff88', '#ff0066', '#0066ff', '#ff6600', '#66ff00', '#ff8800'];
                return colors[Math.abs(hash) % colors.length];
            }
            
            addReasoningThought(thought) {
                const thoughtElement = document.createElement('div');
                thoughtElement.className = 'reasoning-thought';
                thoughtElement.textContent = thought;
                
                this.reasoningLog.appendChild(thoughtElement);
                this.reasoningLog.scrollTop = this.reasoningLog.scrollHeight;
                
                // Keep only last 20 thoughts
                while (this.reasoningLog.children.length > 20) {
                    this.reasoningLog.removeChild(this.reasoningLog.firstChild);
                }
            }
            
            updateAIResponse(message) {
                document.getElementById('ai-response').innerHTML = message;
            }
            
            inspectAgent(agent) {
                this.addReasoningThought(`üîç Inspecting ${agent.type} agent: ${agent.id}`);
                this.addReasoningThought(`‚ö° Status: ${agent.busy ? 'Working on ' + agent.currentTask : 'Available for tasks'}`);
                this.addReasoningThought(`üîã Energy: ${agent.energy}% | Task: ${agent.task}`);
            }
            
            startReasoningCycle() {
                // Continuous reasoning updates
                setInterval(() => {
                    const activeAgents = this.swarmAgents.filter(a => a.busy).length;
                    if (activeAgents > 0) {
                        const thoughts = [
                            `üîÑ ${activeAgents} agents actively working on current construction`,
                            `üìä Analyzing construction progress and resource allocation`,
                            `ü§ù Coordinating inter-swarm communication protocols`,
                            `‚ö° Optimizing agent energy distribution and task efficiency`,
                            `üéØ Evaluating construction quality and specification compliance`
                        ];
                        
                        if (Math.random() < 0.3) { // 30% chance every cycle
                            const thought = thoughts[Math.floor(Math.random() * thoughts.length)];
                            this.addReasoningThought(thought);
                        }
                    }
                }, 5000);
                
                // Animate swarm agents
                setInterval(() => {
                    this.swarmAgents.forEach(agent => {
                        if (!agent.busy) {
                            // Gentle floating movement
                            agent.x += agent.vx;
                            agent.y += agent.vy;
                            
                            // Bounce off edges
                            if (agent.x <= 0 || agent.x >= window.innerWidth) agent.vx *= -1;
                            if (agent.y <= 0 || agent.y >= window.innerHeight) agent.vy *= -1;
                            
                            // Update position
                            agent.element.style.left = agent.x + 'px';
                            agent.element.style.top = agent.y + 'px';
                        }
                    });
                }, 100);
            }
            
            setupMouseControls() {
                let isDragging = false;
                let lastX, lastY;
                
                this.universe.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                this.universe.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;
                        
                        // Pan the universe (implement if needed)
                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });
                
                this.universe.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                // Zoom with mouse wheel
                this.universe.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomDirection = e.deltaY > 0 ? 1 : -1;
                    const newZoom = Math.max(1, Math.min(8, this.currentZoom + zoomDirection));
                    if (newZoom !== this.currentZoom) {
                        zoomTo(newZoom);
                    }
                });
            }
            
            updateZoomDisplay() {
                const scales = {
                    1: { name: 'Genome', focus: 'DNA Sequences & Genetic Code' },
                    2: { name: 'Cell', focus: 'Cellular Organelles & Processes' },
                    3: { name: 'Organism', focus: 'Biological Systems & Life Forms' },
                    4: { name: 'Ecosystem', focus: 'AI Swarm Colonies & Interactions' },
                    5: { name: 'Planet', focus: 'Global Systems & Civilizations' },
                    6: { name: 'Solar System', focus: 'Stellar Systems & Orbital Mechanics' },
                    7: { name: 'Galaxy', focus: 'Galactic Structure & Star Formations' },
                    8: { name: 'Universe', focus: 'Cosmic Scale & Universal Patterns' }
                };
                
                const scale = scales[this.currentZoom];
                document.getElementById('current-scale').textContent = scale.name;
                document.getElementById('zoom-level').textContent = this.currentZoom;
                document.getElementById('focus-target').textContent = scale.focus;
                
                // Update universe background based on zoom level
                const zoomClasses = ['zoom-genome', 'zoom-cell', 'zoom-organism', 'zoom-ecosystem', 
                                   'zoom-planet', 'zoom-solar', 'zoom-galaxy', 'zoom-universe'];
                
                this.universe.className = `universe-container ${zoomClasses[this.currentZoom - 1]}`;
            }
        }
        
        // Global functions
        let universeSystem;
        
        function initializeUniverse() {
            universeSystem = new VisualReasoningUniverse();
        }
        
        function handleCommand(event) {
            if (event.key === 'Enter') {
                const command = event.target.value.trim();
                if (command) {
                    universeSystem.executeCommand(command);
                    event.target.value = '';
                }
            }
        }
        
        function zoomTo(level) {
            universeSystem.currentZoom = level;
            universeSystem.updateZoomDisplay();
            universeSystem.addReasoningThought(`üîç Zoom adjusted to level ${level} - focusing on ${document.getElementById('current-scale').textContent} scale`);
        }
        
        function toggleVoiceCommand() {
            universeSystem.toggleVoiceCommand();
        }
        
        // Initialize when page loads
        window.addEventListener('load', initializeUniverse);
    </script>
</body>
</html>