#!/usr/bin/env node
/**
 * 🛡️⚔️ CAL GUARDIAN RUNELITE BRIDGE
 * Connects Guardian system to RuneLite OSRS client plugin
 * Provides real-time OSRS data and trading oversight
 */

const WebSocket = require('ws');
const http = require('http');
const EventEmitter = require('events');

class CalGuardianRuneLiteBridge extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            // RuneLite plugin connection
            runelitePort: process.env.RUNELITE_PORT || 8095,
            runeliteHost: process.env.RUNELITE_HOST || 'localhost',
            runeliteWsPath: '/runelite-bridge',
            
            // Guardian connection
            guardianPort: process.env.GUARDIAN_WS_PORT || 8082,
            guardianHost: process.env.GUARDIAN_HOST || 'localhost',
            
            // Trading oversight
            enableTradingOversight: true,
            maxTradeValue: 50000000, // 50M gp threshold
            suspiciousPatterns: {
                rapidTrades: 10, // trades per minute
                unusualPrices: 0.2, // 20% above/below GE
                highValueItems: ['Twisted bow', 'Elysian spirit shield', 'Dragon claws']
            },
            
            // Game state monitoring
            monitorInventory: true,
            monitorBank: true,
            monitorGE: true,
            monitorChat: true,
            
            ...config
        };
        
        // Game state
        this.gameState = {
            player: null,
            location: null,
            inventory: [],
            bank: [],
            geOffers: new Map(),
            chatHistory: [],
            skills: {},
            combat: {}
        };
        
        // Trading oversight
        this.tradingSessions = new Map();
        this.suspiciousActivity = [];
        this.priceCache = new Map();
        
        // Connections
        this.runeliteConnection = null;
        this.guardianConnection = null;
        this.reconnectAttempts = 0;
        
        console.log('⚔️ Guardian RuneLite Bridge initializing...');
        this.initialize();
    }
    
    async initialize() {
        try {
            // Start WebSocket server for RuneLite plugin
            await this.startRuneLiteServer();
            
            // Connect to Guardian system
            await this.connectToGuardian();
            
            // Initialize trading oversight
            this.initializeTradingOversight();
            
            console.log('✅ Guardian RuneLite Bridge initialized');
            
        } catch (error) {
            console.error('❌ Failed to initialize RuneLite Bridge:', error.message);
            throw error;
        }
    }
    
    // ==================== RUNELITE SERVER ====================
    
    async startRuneLiteServer() {
        return new Promise((resolve, reject) => {
            console.log(`🖥️ Starting RuneLite server on port ${this.config.runelitePort}...`);
            
            const server = http.createServer();
            const wss = new WebSocket.Server({ server });
            
            wss.on('connection', (ws, req) => {
                console.log('📱 RuneLite client connected');
                this.runeliteConnection = ws;
                
                // Send initialization message
                ws.send(JSON.stringify({
                    type: 'initialize',
                    config: {
                        enableTradingOversight: this.config.enableTradingOversight,
                        monitorInventory: this.config.monitorInventory,
                        monitorBank: this.config.monitorBank,
                        monitorGE: this.config.monitorGE,
                        monitorChat: this.config.monitorChat
                    }
                }));\n                \n                ws.on('message', (data) => {\n                    this.handleRuneLiteMessage(JSON.parse(data));\n                });\n                \n                ws.on('close', () => {\n                    console.log('📱 RuneLite client disconnected');\n                    this.runeliteConnection = null;\n                });\n                \n                ws.on('error', (error) => {\n                    console.error('❌ RuneLite WebSocket error:', error.message);\n                });\n            });\n            \n            server.listen(this.config.runelitePort, () => {\n                console.log(`✅ RuneLite server listening on port ${this.config.runelitePort}`);\n                resolve();\n            });\n            \n            server.on('error', (error) => {\n                console.error('❌ RuneLite server error:', error.message);\n                reject(error);\n            });\n        });\n    }\n    \n    handleRuneLiteMessage(message) {\n        try {\n            switch (message.type) {\n                case 'game-state-update':\n                    this.handleGameStateUpdate(message.data);\n                    break;\n                    \n                case 'trade-initiated':\n                    this.handleTradeInitiated(message.data);\n                    break;\n                    \n                case 'trade-updated':\n                    this.handleTradeUpdated(message.data);\n                    break;\n                    \n                case 'trade-completed':\n                    this.handleTradeCompleted(message.data);\n                    break;\n                    \n                case 'ge-offer-created':\n                    this.handleGEOfferCreated(message.data);\n                    break;\n                    \n                case 'ge-offer-updated':\n                    this.handleGEOfferUpdated(message.data);\n                    break;\n                    \n                case 'chat-message':\n                    this.handleChatMessage(message.data);\n                    break;\n                    \n                case 'inventory-changed':\n                    this.handleInventoryChanged(message.data);\n                    break;\n                    \n                case 'bank-changed':\n                    this.handleBankChanged(message.data);\n                    break;\n                    \n                case 'combat-action':\n                    this.handleCombatAction(message.data);\n                    break;\n                    \n                default:\n                    console.log(`📨 Unknown RuneLite message: ${message.type}`);\n            }\n        } catch (error) {\n            console.error('❌ Error handling RuneLite message:', error.message);\n        }\n    }\n    \n    handleGameStateUpdate(data) {\n        const { player, location, skills, combat } = data;\n        \n        this.gameState.player = player;\n        this.gameState.location = location;\n        this.gameState.skills = skills || this.gameState.skills;\n        this.gameState.combat = combat || this.gameState.combat;\n        \n        // Send status update to Guardian\n        this.sendToGuardian({\n            type: 'runelite-status-update',\n            player: {\n                name: player.name,\n                world: player.world,\n                location: location,\n                combatLevel: combat.combatLevel,\n                totalLevel: this.calculateTotalLevel(skills)\n            }\n        });\n        \n        console.log(`🎮 Game state: ${player.name} @ ${location} (Combat: ${combat.combatLevel})`);\n    }\n    \n    handleTradeInitiated(data) {\n        const { tradeId, partner, timestamp } = data;\n        \n        this.tradingSessions.set(tradeId, {\n            id: tradeId,\n            partner,\n            startTime: timestamp,\n            playerItems: [],\n            partnerItems: [],\n            status: 'initiated',\n            flagged: false\n        });\n        \n        console.log(`🤝 Trade initiated with ${partner} (ID: ${tradeId})`);\n        \n        // Check partner reputation if available\n        this.checkPartnerReputation(partner, tradeId);\n    }\n    \n    handleTradeUpdated(data) {\n        const { tradeId, playerItems, partnerItems } = data;\n        \n        const session = this.tradingSessions.get(tradeId);\n        if (session) {\n            session.playerItems = playerItems || session.playerItems;\n            session.partnerItems = partnerItems || session.partnerItems;\n            session.lastUpdate = Date.now();\n            \n            // Analyze trade for suspicious patterns\n            this.analyzeTrade(session);\n        }\n    }\n    \n    handleTradeCompleted(data) {\n        const { tradeId, success } = data;\n        \n        const session = this.tradingSessions.get(tradeId);\n        if (session) {\n            session.status = success ? 'completed' : 'cancelled';\n            session.endTime = Date.now();\n            \n            if (success) {\n                console.log(`✅ Trade completed: ${tradeId}`);\n                \n                // Calculate trade value and log\n                const tradeValue = this.calculateTradeValue(session);\n                \n                this.sendToGuardian({\n                    type: 'trade-completed',\n                    tradeId,\n                    partner: session.partner,\n                    value: tradeValue,\n                    items: {\n                        given: session.playerItems,\n                        received: session.partnerItems\n                    },\n                    flagged: session.flagged,\n                    duration: session.endTime - session.startTime\n                });\n                \n                if (tradeValue > this.config.maxTradeValue) {\n                    this.requestGuardianApproval({\n                        type: 'high-value-trade',\n                        tradeId,\n                        value: tradeValue,\n                        partner: session.partner,\n                        priority: 'high'\n                    });\n                }\n            } else {\n                console.log(`❌ Trade cancelled: ${tradeId}`);\n            }\n            \n            // Keep completed trades for analysis\n            setTimeout(() => {\n                this.tradingSessions.delete(tradeId);\n            }, 5 * 60 * 1000); // 5 minutes\n        }\n    }\n    \n    handleGEOfferCreated(data) {\n        const { offerId, itemId, itemName, quantity, price, isBuy } = data;\n        \n        this.gameState.geOffers.set(offerId, {\n            id: offerId,\n            itemId,\n            itemName,\n            quantity,\n            price,\n            isBuy,\n            created: Date.now(),\n            status: 'active'\n        });\n        \n        console.log(`📈 GE Offer: ${isBuy ? 'BUY' : 'SELL'} ${itemName} x${quantity} @ ${price}gp`);\n        \n        // Check against market data\n        this.validateGEOffer({ offerId, itemName, quantity, price, isBuy });\n    }\n    \n    handleGEOfferUpdated(data) {\n        const { offerId, progress, completed } = data;\n        \n        const offer = this.gameState.geOffers.get(offerId);\n        if (offer) {\n            offer.progress = progress;\n            if (completed) {\n                offer.status = 'completed';\n                offer.completedAt = Date.now();\n                \n                console.log(`✅ GE Offer completed: ${offer.itemName} x${offer.quantity}`);\n                \n                this.sendToGuardian({\n                    type: 'ge-offer-completed',\n                    offer: offer\n                });\n            }\n        }\n    }\n    \n    handleChatMessage(data) {\n        const { message, sender, channel, timestamp } = data;\n        \n        this.gameState.chatHistory.push({ message, sender, channel, timestamp });\n        \n        // Keep only last 100 messages\n        if (this.gameState.chatHistory.length > 100) {\n            this.gameState.chatHistory.shift();\n        }\n        \n        // Monitor for suspicious chat patterns\n        if (this.isSuspiciousMessage(message)) {\n            this.flagSuspiciousActivity({\n                type: 'suspicious-chat',\n                message,\n                sender,\n                channel,\n                timestamp\n            });\n        }\n        \n        console.log(`💬 [${channel}] ${sender}: ${message}`);\n    }\n    \n    handleInventoryChanged(data) {\n        const { items } = data;\n        \n        this.gameState.inventory = items;\n        \n        // Monitor for suspicious inventory patterns\n        this.analyzeInventoryChanges(items);\n    }\n    \n    handleBankChanged(data) {\n        const { items, tab } = data;\n        \n        if (tab !== undefined) {\n            // Update specific bank tab\n            this.gameState.bank[tab] = items;\n        } else {\n            // Full bank update\n            this.gameState.bank = items;\n        }\n        \n        // Calculate total bank value\n        const bankValue = this.calculateBankValue(this.gameState.bank);\n        \n        this.sendToGuardian({\n            type: 'bank-value-update',\n            value: bankValue,\n            itemCount: Array.isArray(items) ? items.length : Object.keys(items).length\n        });\n    }\n    \n    handleCombatAction(data) {\n        const { action, target, damage, weapon } = data;\n        \n        // Log significant combat events\n        if (damage > 50 || this.isHighValueTarget(target)) {\n            this.sendToGuardian({\n                type: 'combat-action',\n                action,\n                target,\n                damage,\n                weapon,\n                location: this.gameState.location\n            });\n        }\n    }\n    \n    // ==================== GUARDIAN CONNECTION ====================\n    \n    async connectToGuardian() {\n        return new Promise((resolve, reject) => {\n            console.log(`🔌 Connecting to Guardian at localhost:${this.config.guardianPort}...`);\n            \n            this.guardianConnection = new WebSocket(`ws://${this.config.guardianHost}:${this.config.guardianPort}`);\n            \n            this.guardianConnection.on('open', () => {\n                console.log('✅ Connected to Guardian system');\n                \n                // Identify as RuneLite bridge\n                this.guardianConnection.send(JSON.stringify({\n                    type: 'identify',\n                    identity: {\n                        system: 'runelite-bridge',\n                        version: '1.0.0',\n                        capabilities: ['game-monitoring', 'trade-oversight', 'player-tracking']\n                    }\n                }));\n                \n                resolve();\n            });\n            \n            this.guardianConnection.on('message', (data) => {\n                this.handleGuardianMessage(JSON.parse(data));\n            });\n            \n            this.guardianConnection.on('close', () => {\n                console.log('🔌 Guardian connection closed');\n                setTimeout(() => this.connectToGuardian(), 3000);\n            });\n            \n            this.guardianConnection.on('error', (error) => {\n                console.error('❌ Guardian connection error:', error.message);\n                reject(error);\n            });\n        });\n    }\n    \n    handleGuardianMessage(message) {\n        try {\n            switch (message.type) {\n                case 'approval-decision':\n                    this.handleApprovalDecision(message.data);\n                    break;\n                    \n                case 'intervention-request':\n                    this.handleInterventionRequest(message.data);\n                    break;\n                    \n                case 'price-data-request':\n                    this.handlePriceDataRequest(message.data);\n                    break;\n                    \n                default:\n                    console.log(`📨 Unknown Guardian message: ${message.type}`);\n            }\n        } catch (error) {\n            console.error('❌ Error handling Guardian message:', error.message);\n        }\n    }\n    \n    sendToGuardian(data) {\n        if (this.guardianConnection && this.guardianConnection.readyState === WebSocket.OPEN) {\n            this.guardianConnection.send(JSON.stringify(data));\n        }\n    }\n    \n    requestGuardianApproval(data) {\n        const approvalRequest = {\n            type: 'approval-request',\n            brand: 'runelite-bridge',\n            priority: data.priority || 'medium',\n            decision_type: data.type,\n            context: {\n                source: 'runelite-bridge',\n                player: this.gameState.player?.name,\n                location: this.gameState.location,\n                timestamp: new Date().toISOString(),\n                ...data\n            },\n            proposed_action: this.generateProposedAction(data),\n            risk_assessment: this.calculateRiskAssessment(data)\n        };\n        \n        this.sendToGuardian(approvalRequest);\n        console.log(`🛡️ Guardian approval requested: ${data.type}`);\n    }\n    \n    // ==================== TRADING OVERSIGHT ====================\n    \n    initializeTradingOversight() {\n        console.log('🔍 Initializing trading oversight...');\n        \n        // Monitor for suspicious trading patterns\n        setInterval(() => {\n            this.analyzeTradingPatterns();\n        }, 60000); // Every minute\n    }\n    \n    analyzeTrade(session) {\n        const { playerItems, partnerItems, partner } = session;\n        \n        const playerValue = this.calculateItemsValue(playerItems);\n        const partnerValue = this.calculateItemsValue(partnerItems);\n        const valueRatio = partnerValue > 0 ? playerValue / partnerValue : 0;\n        \n        let suspicious = false;\n        const suspiciousReasons = [];\n        \n        // Check for heavily skewed trades\n        if (valueRatio > 10 || (valueRatio < 0.1 && valueRatio > 0)) {\n            suspicious = true;\n            suspiciousReasons.push('heavily-skewed-trade');\n        }\n        \n        // Check for high-value items\n        const allItems = [...playerItems, ...partnerItems];\n        for (const item of allItems) {\n            if (this.config.suspiciousPatterns.highValueItems.includes(item.name)) {\n                suspicious = true;\n                suspiciousReasons.push('high-value-item');\n                break;\n            }\n        }\n        \n        if (suspicious) {\n            session.flagged = true;\n            session.suspiciousReasons = suspiciousReasons;\n            \n            this.flagSuspiciousActivity({\n                type: 'suspicious-trade',\n                tradeId: session.id,\n                partner,\n                playerValue,\n                partnerValue,\n                valueRatio,\n                reasons: suspiciousReasons\n            });\n        }\n    }\n    \n    analyzeTradingPatterns() {\n        // Check for rapid trading\n        const recentTrades = Array.from(this.tradingSessions.values())\n            .filter(session => (Date.now() - session.startTime) < 60000); // Last minute\n        \n        if (recentTrades.length >= this.config.suspiciousPatterns.rapidTrades) {\n            this.requestGuardianApproval({\n                type: 'rapid-trading',\n                tradeCount: recentTrades.length,\n                timeframe: '1-minute',\n                priority: 'high'\n            });\n        }\n    }\n    \n    validateGEOffer(offer) {\n        const { itemName, quantity, price, isBuy } = offer;\n        \n        // Check against cached market prices\n        const marketPrice = this.priceCache.get(itemName);\n        if (marketPrice) {\n            const priceRatio = price / marketPrice;\n            \n            if (priceRatio > (1 + this.config.suspiciousPatterns.unusualPrices) ||\n                priceRatio < (1 - this.config.suspiciousPatterns.unusualPrices)) {\n                \n                this.requestGuardianApproval({\n                    type: 'unusual-ge-price',\n                    itemName,\n                    offerPrice: price,\n                    marketPrice,\n                    ratio: priceRatio,\n                    quantity,\n                    isBuy,\n                    priority: 'medium'\n                });\n            }\n        }\n    }\n    \n    flagSuspiciousActivity(activity) {\n        activity.timestamp = Date.now();\n        activity.player = this.gameState.player?.name;\n        activity.location = this.gameState.location;\n        \n        this.suspiciousActivity.push(activity);\n        \n        // Keep only last 1000 activities\n        if (this.suspiciousActivity.length > 1000) {\n            this.suspiciousActivity.shift();\n        }\n        \n        console.log(`🚨 Suspicious activity flagged: ${activity.type}`);\n        \n        this.sendToGuardian({\n            type: 'suspicious-activity-detected',\n            activity\n        });\n    }\n    \n    // ==================== UTILITY METHODS ====================\n    \n    calculateTotalLevel(skills) {\n        return Object.values(skills || {}).reduce((total, level) => total + level, 0);\n    }\n    \n    calculateItemsValue(items) {\n        return items.reduce((total, item) => {\n            const price = this.priceCache.get(item.name) || 0;\n            return total + (price * item.quantity);\n        }, 0);\n    }\n    \n    calculateTradeValue(session) {\n        const playerValue = this.calculateItemsValue(session.playerItems);\n        const partnerValue = this.calculateItemsValue(session.partnerItems);\n        return Math.max(playerValue, partnerValue);\n    }\n    \n    calculateBankValue(bank) {\n        if (Array.isArray(bank)) {\n            return this.calculateItemsValue(bank);\n        } else {\n            // Bank tabs format\n            let total = 0;\n            for (const tab of Object.values(bank)) {\n                if (Array.isArray(tab)) {\n                    total += this.calculateItemsValue(tab);\n                }\n            }\n            return total;\n        }\n    }\n    \n    isSuspiciousMessage(message) {\n        const suspiciousTerms = [\n            'doubling money',\n            'free items',\n            'drop test',\n            'trust trade',\n            'anti-scam',\n            'quitting rs'\n        ];\n        \n        const lowerMessage = message.toLowerCase();\n        return suspiciousTerms.some(term => lowerMessage.includes(term));\n    }\n    \n    isHighValueTarget(target) {\n        const highValueTargets = [\n            'corporeal beast',\n            'zulrah',\n            'vorkath',\n            'theatre of blood',\n            'chambers of xeric'\n        ];\n        \n        return highValueTargets.some(name => target.toLowerCase().includes(name.toLowerCase()));\n    }\n    \n    analyzeInventoryChanges(items) {\n        // Look for patterns that might indicate botting or unusual behavior\n        const totalValue = this.calculateItemsValue(items);\n        \n        if (totalValue > 100000000) { // 100M+ inventory\n            this.sendToGuardian({\n                type: 'high-value-inventory',\n                value: totalValue,\n                itemCount: items.length\n            });\n        }\n    }\n    \n    checkPartnerReputation(partner, tradeId) {\n        // Request reputation check from Guardian\n        this.sendToGuardian({\n            type: 'reputation-check-request',\n            player: partner,\n            context: 'trade-initiation',\n            tradeId\n        });\n    }\n    \n    generateProposedAction(data) {\n        switch (data.type) {\n            case 'high-value-trade':\n                return {\n                    action: 'monitor-trade',\n                    duration: '24-hours',\n                    reason: 'High value trade requires monitoring'\n                };\n                \n            case 'suspicious-trade':\n                return {\n                    action: 'flag-players',\n                    players: [data.partner],\n                    reason: 'Suspicious trading pattern detected'\n                };\n                \n            case 'rapid-trading':\n                return {\n                    action: 'temporary-trade-limit',\n                    duration: '1-hour',\n                    reason: 'Rapid trading detected'\n                };\n                \n            default:\n                return {\n                    action: 'investigate',\n                    reason: 'Requires human review'\n                };\n        }\n    }\n    \n    calculateRiskAssessment(data) {\n        let riskScore = 0;\n        const factors = [];\n        \n        if (data.value > 50000000) { // 50M+\n            riskScore += 0.4;\n            factors.push('high-value');\n        }\n        \n        if (data.type === 'suspicious-trade') {\n            riskScore += 0.5;\n            factors.push('suspicious-pattern');\n        }\n        \n        if (data.type === 'rapid-trading') {\n            riskScore += 0.3;\n            factors.push('rapid-activity');\n        }\n        \n        return {\n            score: Math.min(riskScore, 1.0),\n            level: riskScore > 0.7 ? 'high' : riskScore > 0.3 ? 'medium' : 'low',\n            factors\n        };\n    }\n    \n    // ==================== API METHODS ====================\n    \n    getGameState() {\n        return this.gameState;\n    }\n    \n    getTradingSessions() {\n        return Array.from(this.tradingSessions.values());\n    }\n    \n    getSuspiciousActivity(limit = 50) {\n        return this.suspiciousActivity.slice(-limit);\n    }\n    \n    // Send command to RuneLite client\n    sendToRuneLite(command) {\n        if (this.runeliteConnection && this.runeliteConnection.readyState === WebSocket.OPEN) {\n            this.runeliteConnection.send(JSON.stringify(command));\n        } else {\n            console.warn('⚠️ Cannot send to RuneLite: client not connected');\n        }\n    }\n    \n    // ==================== CLEANUP ====================\n    \n    async shutdown() {\n        console.log('🛑 Shutting down Guardian RuneLite Bridge...');\n        \n        if (this.runeliteConnection) {\n            this.runeliteConnection.close();\n        }\n        \n        if (this.guardianConnection) {\n            this.guardianConnection.close();\n        }\n        \n        console.log('✅ Guardian RuneLite Bridge shut down');\n    }\n}\n\n// Export for use in other modules\nmodule.exports = CalGuardianRuneLiteBridge;\n\n// CLI testing\nif (require.main === module) {\n    const bridge = new CalGuardianRuneLiteBridge();\n    \n    // Handle graceful shutdown\n    process.on('SIGINT', async () => {\n        await bridge.shutdown();\n        process.exit(0);\n    });\n    \n    process.on('SIGTERM', async () => {\n        await bridge.shutdown();\n        process.exit(0);\n    });\n}