#!/usr/bin/env node
/**
 * üõ°Ô∏èüé¨ CAL GUARDIAN REPLAY SYSTEM
 * HyperCam-style recording and replay for Guardian decisions
 * Creates training data and audit trails from Guardian workflows
 */

const WebSocket = require('ws');
const EventEmitter = require('events');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class CalGuardianReplaySystem extends EventEmitter {
    constructor(config = {}) {
        super();
        
        this.config = {
            // Storage configuration
            replayDir: process.env.REPLAY_DIR || './guardian-replays',
            maxReplays: 1000,
            maxReplaySize: 100 * 1024 * 1024, // 100MB per replay
            compressionEnabled: true,
            
            // Guardian connection
            guardianPort: process.env.GUARDIAN_WS_PORT || 8082,
            guardianHost: process.env.GUARDIAN_HOST || 'localhost',
            
            // Screen recorder integration
            screenRecorderPort: process.env.SCREEN_RECORDER_PORT || 8096,
            enableScreenRecording: true,
            recordingQuality: 'medium', // low, medium, high, ultra\n            \n            // Replay server\n            serverPort: process.env.REPLAY_SERVER_PORT || 8097,\n            enableReplayServer: true,\n            \n            // Training data generation\n            enableTrainingData: true,\n            trainingDataFormat: 'json', // json, csv, parquet\n            \n            ...config\n        };\n        \n        // Recording state\n        this.currentSession = null;\n        this.activeSessions = new Map();\n        this.replayDatabase = new Map();\n        this.recordingBuffer = [];\n        \n        // Connections\n        this.guardianConnection = null;\n        this.screenRecorderConnection = null;\n        this.replayServer = null;\n        \n        // Metrics\n        this.metrics = {\n            totalReplays: 0,\n            totalRecordingTime: 0,\n            averageDecisionTime: 0,\n            accuracyRate: 0,\n            trainingDataPoints: 0\n        };\n        \n        console.log('üé¨ Guardian Replay System initializing...');\n        this.initialize();\n    }\n    \n    async initialize() {\n        try {\n            // Ensure replay directory exists\n            await this.ensureReplayDirectory();\n            \n            // Load existing replay database\n            await this.loadReplayDatabase();\n            \n            // Connect to Guardian system\n            await this.connectToGuardian();\n            \n            // Connect to screen recorder\n            if (this.config.enableScreenRecording) {\n                await this.connectToScreenRecorder();\n            }\n            \n            // Start replay server\n            if (this.config.enableReplayServer) {\n                await this.startReplayServer();\n            }\n            \n            console.log('‚úÖ Guardian Replay System initialized');\n            console.log(`üìÅ Replay directory: ${this.config.replayDir}`);\n            console.log(`üìä Loaded ${this.replayDatabase.size} existing replays`);\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize Replay System:', error.message);\n            throw error;\n        }\n    }\n    \n    // ==================== DIRECTORY SETUP ====================\n    \n    async ensureReplayDirectory() {\n        try {\n            await fs.access(this.config.replayDir);\n        } catch {\n            await fs.mkdir(this.config.replayDir, { recursive: true });\n            console.log(`üìÅ Created replay directory: ${this.config.replayDir}`);\n        }\n        \n        // Create subdirectories\n        const subdirs = ['sessions', 'training-data', 'exports', 'thumbnails'];\n        for (const subdir of subdirs) {\n            const dirPath = path.join(this.config.replayDir, subdir);\n            try {\n                await fs.access(dirPath);\n            } catch {\n                await fs.mkdir(dirPath, { recursive: true });\n            }\n        }\n    }\n    \n    // ==================== GUARDIAN CONNECTION ====================\n    \n    async connectToGuardian() {\n        return new Promise((resolve, reject) => {\n            console.log(`üîå Connecting to Guardian at localhost:${this.config.guardianPort}...`);\n            \n            this.guardianConnection = new WebSocket(`ws://${this.config.guardianHost}:${this.config.guardianPort}`);\n            \n            this.guardianConnection.on('open', () => {\n                console.log('‚úÖ Connected to Guardian system');\n                \n                // Subscribe to all Guardian events\n                this.guardianConnection.send(JSON.stringify({\n                    type: 'subscribe',\n                    channels: ['all'],\n                    identity: {\n                        system: 'replay-system',\n                        version: '1.0.0',\n                        capabilities: ['recording', 'replay', 'training-data']\n                    }\n                }));\n                \n                resolve();\n            });\n            \n            this.guardianConnection.on('message', (data) => {\n                this.handleGuardianMessage(JSON.parse(data));\n            });\n            \n            this.guardianConnection.on('close', () => {\n                console.log('üîå Guardian connection closed, reconnecting...');\n                setTimeout(() => this.connectToGuardian(), 3000);\n            });\n            \n            this.guardianConnection.on('error', (error) => {\n                console.error('‚ùå Guardian connection error:', error.message);\n                reject(error);\n            });\n        });\n    }\n    \n    handleGuardianMessage(message) {\n        try {\n            switch (message.type) {\n                case 'approval-request':\n                    this.handleApprovalRequest(message);\n                    break;\n                    \n                case 'approval-updated':\n                    this.handleApprovalUpdated(message);\n                    break;\n                    \n                case 'decision-made':\n                    this.handleDecisionMade(message);\n                    break;\n                    \n                case 'session-started':\n                    this.handleSessionStarted(message);\n                    break;\n                    \n                case 'session-ended':\n                    this.handleSessionEnded(message);\n                    break;\n                    \n                case 'training-mode':\n                    this.handleTrainingMode(message);\n                    break;\n                    \n                default:\n                    // Record all messages for complete replay\n                    this.recordEvent(message);\n            }\n        } catch (error) {\n            console.error('‚ùå Error handling Guardian message:', error.message);\n        }\n    }\n    \n    handleApprovalRequest(message) {\n        const { approvalId, brand, priority, decision_type } = message;\n        \n        // Start new recording session\n        const sessionId = this.startRecordingSession({\n            type: 'guardian-approval',\n            approvalId,\n            brand,\n            priority,\n            decision_type,\n            startTime: Date.now()\n        });\n        \n        console.log(`üé¨ Started recording session: ${sessionId}`);\n        \n        // Start screen recording if enabled\n        if (this.config.enableScreenRecording) {\n            this.startScreenRecording(sessionId, {\n                type: 'guardian-approval',\n                brand,\n                priority\n            });\n        }\n    }\n    \n    handleApprovalUpdated(message) {\n        // Find active session for this approval\n        const session = Array.from(this.activeSessions.values())\n            .find(s => s.approvalId === message.approvalId);\n        \n        if (session) {\n            this.recordEvent(message, session.id);\n        }\n    }\n    \n    handleDecisionMade(message) {\n        const { approvalId, decision, response_time } = message;\n        \n        // Find and finish recording session\n        const session = Array.from(this.activeSessions.values())\n            .find(s => s.approvalId === approvalId);\n        \n        if (session) {\n            session.decision = decision;\n            session.responseTime = response_time;\n            session.endTime = Date.now();\n            \n            this.recordEvent(message, session.id);\n            this.finishRecordingSession(session.id);\n            \n            console.log(`‚úÖ Finished recording session: ${session.id} (${decision})`);\n        }\n    }\n    \n    // ==================== SCREEN RECORDER INTEGRATION ====================\n    \n    async connectToScreenRecorder() {\n        try {\n            console.log(`üé• Connecting to Screen Recorder at localhost:${this.config.screenRecorderPort}...`);\n            \n            // Check if screen recorder is available\n            const response = await fetch(`http://localhost:${this.config.screenRecorderPort}/api/status`);\n            \n            if (response.ok) {\n                console.log('‚úÖ Screen Recorder available');\n            } else {\n                console.log('‚ö†Ô∏è Screen Recorder not available, continuing without');\n                this.config.enableScreenRecording = false;\n            }\n        } catch (error) {\n            console.log('‚ö†Ô∏è Screen Recorder not available:', error.message);\n            this.config.enableScreenRecording = false;\n        }\n    }\n    \n    async startScreenRecording(sessionId, metadata) {\n        if (!this.config.enableScreenRecording) return;\n        \n        try {\n            const response = await fetch(`http://localhost:${this.config.screenRecorderPort}/api/start`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    sessionId,\n                    quality: this.config.recordingQuality,\n                    metadata: {\n                        ...metadata,\n                        system: 'guardian-replay',\n                        timestamp: new Date().toISOString()\n                    }\n                })\n            });\n            \n            if (response.ok) {\n                console.log(`üé• Screen recording started for session: ${sessionId}`);\n            }\n        } catch (error) {\n            console.error('‚ùå Failed to start screen recording:', error.message);\n        }\n    }\n    \n    async stopScreenRecording(sessionId) {\n        if (!this.config.enableScreenRecording) return;\n        \n        try {\n            const response = await fetch(`http://localhost:${this.config.screenRecorderPort}/api/stop`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ sessionId })\n            });\n            \n            if (response.ok) {\n                const result = await response.json();\n                console.log(`üé• Screen recording stopped for session: ${sessionId}`);\n                return result.videoPath;\n            }\n        } catch (error) {\n            console.error('‚ùå Failed to stop screen recording:', error.message);\n        }\n    }\n    \n    // ==================== RECORDING SESSION MANAGEMENT ====================\n    \n    startRecordingSession(metadata) {\n        const sessionId = crypto.randomUUID();\n        const session = {\n            id: sessionId,\n            ...metadata,\n            events: [],\n            recordingPath: null,\n            thumbnailPath: null,\n            status: 'recording'\n        };\n        \n        this.activeSessions.set(sessionId, session);\n        this.currentSession = session;\n        \n        return sessionId;\n    }\n    \n    recordEvent(event, sessionId = null) {\n        const targetSession = sessionId \n            ? this.activeSessions.get(sessionId)\n            : this.currentSession;\n        \n        if (targetSession) {\n            targetSession.events.push({\n                ...event,\n                timestamp: Date.now(),\n                relativeTime: Date.now() - targetSession.startTime\n            });\n        }\n        \n        // Also add to buffer for general recording\n        this.recordingBuffer.push({\n            ...event,\n            timestamp: Date.now(),\n            sessionId: targetSession?.id\n        });\n        \n        // Keep buffer size manageable\n        if (this.recordingBuffer.length > 10000) {\n            this.recordingBuffer.shift();\n        }\n    }\n    \n    async finishRecordingSession(sessionId) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return;\n        \n        session.status = 'processing';\n        session.duration = session.endTime - session.startTime;\n        \n        try {\n            // Stop screen recording\n            const videoPath = await this.stopScreenRecording(sessionId);\n            if (videoPath) {\n                session.recordingPath = videoPath;\n            }\n            \n            // Generate thumbnail\n            if (videoPath) {\n                session.thumbnailPath = await this.generateThumbnail(videoPath, sessionId);\n            }\n            \n            // Save session data\n            await this.saveSession(session);\n            \n            // Generate training data\n            if (this.config.enableTrainingData) {\n                await this.generateTrainingData(session);\n            }\n            \n            // Add to replay database\n            this.replayDatabase.set(sessionId, {\n                id: sessionId,\n                type: session.type,\n                brand: session.brand,\n                priority: session.priority,\n                decision: session.decision,\n                duration: session.duration,\n                responseTime: session.responseTime,\n                eventCount: session.events.length,\n                recordingPath: session.recordingPath,\n                thumbnailPath: session.thumbnailPath,\n                createdAt: session.startTime,\n                metadata: {\n                    decision_type: session.decision_type,\n                    approvalId: session.approvalId\n                }\n            });\n            \n            // Update metrics\n            this.updateMetrics(session);\n            \n            session.status = 'completed';\n            \n            // Clean up active session\n            this.activeSessions.delete(sessionId);\n            \n            if (this.currentSession?.id === sessionId) {\n                this.currentSession = null;\n            }\n            \n            console.log(`üíæ Session saved: ${sessionId}`);\n            \n        } catch (error) {\n            console.error(`‚ùå Error finishing session ${sessionId}:`, error.message);\n            session.status = 'error';\n        }\n    }\n    \n    async saveSession(session) {\n        const sessionPath = path.join(this.config.replayDir, 'sessions', `${session.id}.json`);\n        \n        const sessionData = {\n            ...session,\n            savedAt: Date.now()\n        };\n        \n        await fs.writeFile(sessionPath, JSON.stringify(sessionData, null, 2));\n    }\n    \n    async generateThumbnail(videoPath, sessionId) {\n        // This would use ffmpeg or similar to generate a thumbnail\n        // For now, return placeholder path\n        const thumbnailPath = path.join(this.config.replayDir, 'thumbnails', `${sessionId}.jpg`);\n        \n        // TODO: Implement actual thumbnail generation\n        console.log(`üì∏ Thumbnail placeholder: ${thumbnailPath}`);\n        \n        return thumbnailPath;\n    }\n    \n    // ==================== TRAINING DATA GENERATION ====================\n    \n    async generateTrainingData(session) {\n        const trainingDataPoint = {\n            sessionId: session.id,\n            features: this.extractFeatures(session),\n            label: this.extractLabel(session),\n            metadata: {\n                brand: session.brand,\n                priority: session.priority,\n                decision_type: session.decision_type,\n                duration: session.duration,\n                responseTime: session.responseTime\n            },\n            timestamp: session.startTime\n        };\n        \n        const trainingDataPath = path.join(\n            this.config.replayDir, \n            'training-data', \n            `${session.id}.json`\n        );\n        \n        await fs.writeFile(trainingDataPath, JSON.stringify(trainingDataPoint, null, 2));\n        \n        this.metrics.trainingDataPoints++;\n        console.log(`üéØ Training data generated: ${session.id}`);\n    }\n    \n    extractFeatures(session) {\n        // Extract features for ML training\n        const features = {\n            // Timing features\n            responseTimeMs: session.responseTime || 0,\n            sessionDurationMs: session.duration,\n            eventCount: session.events.length,\n            \n            // Decision features\n            priority: this.encodePriority(session.priority),\n            brand: this.encodeBrand(session.brand),\n            decisionType: this.encodeDecisionType(session.decision_type),\n            \n            // Interaction features\n            clickCount: session.events.filter(e => e.type === 'click').length,\n            keyboardEvents: session.events.filter(e => e.type === 'keyboard').length,\n            mouseMovements: session.events.filter(e => e.type === 'mouse').length,\n            \n            // Context features\n            timeOfDay: new Date(session.startTime).getHours(),\n            dayOfWeek: new Date(session.startTime).getDay(),\n            \n            // Risk features\n            riskScore: this.calculateRiskScore(session),\n            complexity: this.calculateComplexity(session)\n        };\n        \n        return features;\n    }\n    \n    extractLabel(session) {\n        // Extract ground truth label for supervised learning\n        return {\n            decision: session.decision, // 'approved', 'rejected', 'corrected'\n            correct: true, // Would be validated later\n            confidence: 1.0 // Would be determined by human review\n        };\n    }\n    \n    encodePriority(priority) {\n        const priorityMap = { 'low': 1, 'medium': 2, 'high': 3, 'critical': 4 };\n        return priorityMap[priority] || 0;\n    }\n    \n    encodeBrand(brand) {\n        const brandMap = { 'deathtodata.com': 1, 'soulfra.ai': 2, 'grand-exchange': 3 };\n        return brandMap[brand] || 0;\n    }\n    \n    encodeDecisionType(type) {\n        const typeMap = { \n            'pricing': 1, 'suspicious-activity': 2, 'high-value': 3, \n            'unusual-pattern': 4, 'manual-review': 5 \n        };\n        return typeMap[type] || 0;\n    }\n    \n    calculateRiskScore(session) {\n        // Calculate composite risk score from session events\n        let score = 0;\n        \n        if (session.priority === 'critical') score += 0.5;\n        if (session.priority === 'high') score += 0.3;\n        if (session.decision_type === 'suspicious-activity') score += 0.4;\n        if (session.duration > 60000) score += 0.2; // Over 1 minute\n        \n        return Math.min(score, 1.0);\n    }\n    \n    calculateComplexity(session) {\n        // Calculate decision complexity\n        let complexity = 0;\n        \n        complexity += session.events.length * 0.1;\n        complexity += (session.duration / 10000); // Duration factor\n        \n        return Math.min(complexity, 1.0);\n    }\n    \n    // ==================== REPLAY SERVER ====================\n    \n    async startReplayServer() {\n        const express = require('express');\n        const app = express();\n        \n        app.use(express.json());\n        app.use(express.static(path.join(__dirname, 'replay-ui')));\n        \n        // Get all replays\n        app.get('/api/replays', (req, res) => {\n            const replays = Array.from(this.replayDatabase.values())\n                .sort((a, b) => b.createdAt - a.createdAt)\n                .slice(0, parseInt(req.query.limit) || 50);\n            \n            res.json({\n                replays,\n                total: this.replayDatabase.size,\n                metrics: this.metrics\n            });\n        });\n        \n        // Get specific replay\n        app.get('/api/replays/:id', async (req, res) => {\n            const replayData = await this.getReplayData(req.params.id);\n            if (replayData) {\n                res.json(replayData);\n            } else {\n                res.status(404).json({ error: 'Replay not found' });\n            }\n        });\n        \n        // Stream replay events\n        app.get('/api/replays/:id/events', async (req, res) => {\n            const events = await this.getReplayEvents(req.params.id);\n            res.json({ events });\n        });\n        \n        // Export replay\n        app.get('/api/replays/:id/export', async (req, res) => {\n            const exportData = await this.exportReplay(req.params.id, req.query.format || 'json');\n            if (exportData) {\n                res.setHeader('Content-Disposition', `attachment; filename=\"replay-${req.params.id}.${req.query.format || 'json'}\"`);\n                res.json(exportData);\n            } else {\n                res.status(404).json({ error: 'Replay not found' });\n            }\n        });\n        \n        // Search replays\n        app.post('/api/replays/search', (req, res) => {\n            const results = this.searchReplays(req.body);\n            res.json({ results });\n        });\n        \n        this.replayServer = app.listen(this.config.serverPort, () => {\n            console.log(`üé¨ Replay server listening on port ${this.config.serverPort}`);\n        });\n    }\n    \n    async getReplayData(replayId) {\n        try {\n            const sessionPath = path.join(this.config.replayDir, 'sessions', `${replayId}.json`);\n            const sessionData = await fs.readFile(sessionPath, 'utf8');\n            return JSON.parse(sessionData);\n        } catch (error) {\n            console.error(`‚ùå Error loading replay ${replayId}:`, error.message);\n            return null;\n        }\n    }\n    \n    async getReplayEvents(replayId) {\n        const replayData = await this.getReplayData(replayId);\n        return replayData ? replayData.events : [];\n    }\n    \n    async exportReplay(replayId, format) {\n        const replayData = await this.getReplayData(replayId);\n        if (!replayData) return null;\n        \n        switch (format) {\n            case 'csv':\n                return this.convertToCSV(replayData);\n            case 'json':\n                return replayData;\n            default:\n                return replayData;\n        }\n    }\n    \n    searchReplays(criteria) {\n        const results = [];\n        \n        for (const replay of this.replayDatabase.values()) {\n            let matches = true;\n            \n            if (criteria.brand && replay.brand !== criteria.brand) matches = false;\n            if (criteria.decision && replay.decision !== criteria.decision) matches = false;\n            if (criteria.priority && replay.priority !== criteria.priority) matches = false;\n            \n            if (criteria.dateFrom && replay.createdAt < new Date(criteria.dateFrom).getTime()) matches = false;\n            if (criteria.dateTo && replay.createdAt > new Date(criteria.dateTo).getTime()) matches = false;\n            \n            if (matches) {\n                results.push(replay);\n            }\n        }\n        \n        return results.sort((a, b) => b.createdAt - a.createdAt);\n    }\n    \n    // ==================== DATABASE MANAGEMENT ====================\n    \n    async loadReplayDatabase() {\n        try {\n            const sessionsDir = path.join(this.config.replayDir, 'sessions');\n            const files = await fs.readdir(sessionsDir);\n            \n            for (const file of files) {\n                if (file.endsWith('.json')) {\n                    try {\n                        const sessionData = await fs.readFile(path.join(sessionsDir, file), 'utf8');\n                        const session = JSON.parse(sessionData);\n                        \n                        this.replayDatabase.set(session.id, {\n                            id: session.id,\n                            type: session.type,\n                            brand: session.brand,\n                            priority: session.priority,\n                            decision: session.decision,\n                            duration: session.duration,\n                            responseTime: session.responseTime,\n                            eventCount: session.events?.length || 0,\n                            recordingPath: session.recordingPath,\n                            thumbnailPath: session.thumbnailPath,\n                            createdAt: session.startTime,\n                            metadata: session.metadata || {}\n                        });\n                        \n                        this.metrics.totalReplays++;\n                        this.metrics.totalRecordingTime += session.duration || 0;\n                    } catch (error) {\n                        console.error(`‚ùå Error loading replay ${file}:`, error.message);\n                    }\n                }\n            }\n            \n            console.log(`üìä Loaded ${this.replayDatabase.size} replays`);\n            \n        } catch (error) {\n            console.log('üìÅ No existing replays found, starting fresh');\n        }\n    }\n    \n    updateMetrics(session) {\n        this.metrics.totalReplays++;\n        this.metrics.totalRecordingTime += session.duration;\n        \n        if (session.responseTime) {\n            this.metrics.averageDecisionTime = \n                (this.metrics.averageDecisionTime * (this.metrics.totalReplays - 1) + session.responseTime) / \n                this.metrics.totalReplays;\n        }\n        \n        // Calculate accuracy rate (would be updated by human review)\n        if (session.decision) {\n            // Placeholder - would be updated by validation system\n            this.metrics.accuracyRate = 0.95; // 95% placeholder\n        }\n    }\n    \n    // ==================== UTILITY METHODS ====================\n    \n    convertToCSV(replayData) {\n        const headers = ['timestamp', 'type', 'relativeTime', 'data'];\n        const rows = [headers];\n        \n        for (const event of replayData.events) {\n            rows.push([\n                event.timestamp,\n                event.type,\n                event.relativeTime,\n                JSON.stringify(event.data || {})\n            ]);\n        }\n        \n        return rows.map(row => row.join(',')).join('\\n');\n    }\n    \n    getMetrics() {\n        return {\n            ...this.metrics,\n            activeReplays: this.activeSessions.size,\n            totalReplays: this.replayDatabase.size,\n            storageUsed: this.calculateStorageUsed()\n        };\n    }\n    \n    calculateStorageUsed() {\n        // Would calculate actual storage usage\n        return this.replayDatabase.size * 5 * 1024 * 1024; // 5MB estimate per replay\n    }\n    \n    // ==================== API METHODS ====================\n    \n    startManualRecording(metadata = {}) {\n        return this.startRecordingSession({\n            type: 'manual',\n            ...metadata,\n            startTime: Date.now()\n        });\n    }\n    \n    stopManualRecording(sessionId) {\n        const session = this.activeSessions.get(sessionId);\n        if (session) {\n            session.endTime = Date.now();\n            this.finishRecordingSession(sessionId);\n            return true;\n        }\n        return false;\n    }\n    \n    getAllReplays(limit = 50, offset = 0) {\n        return Array.from(this.replayDatabase.values())\n            .sort((a, b) => b.createdAt - a.createdAt)\n            .slice(offset, offset + limit);\n    }\n    \n    // ==================== CLEANUP ====================\n    \n    async shutdown() {\n        console.log('üõë Shutting down Guardian Replay System...');\n        \n        // Finish any active sessions\n        for (const [sessionId, session] of this.activeSessions) {\n            if (session.status === 'recording') {\n                session.endTime = Date.now();\n                await this.finishRecordingSession(sessionId);\n            }\n        }\n        \n        // Close connections\n        if (this.guardianConnection) {\n            this.guardianConnection.close();\n        }\n        \n        if (this.replayServer) {\n            this.replayServer.close();\n        }\n        \n        console.log('‚úÖ Guardian Replay System shut down');\n    }\n}\n\n// Export for use in other modules\nmodule.exports = CalGuardianReplaySystem;\n\n// CLI testing\nif (require.main === module) {\n    const replaySystem = new CalGuardianReplaySystem();\n    \n    // Handle graceful shutdown\n    process.on('SIGINT', async () => {\n        await replaySystem.shutdown();\n        process.exit(0);\n    });\n    \n    process.on('SIGTERM', async () => {\n        await replaySystem.shutdown();\n        process.exit(0);\n    });\n}