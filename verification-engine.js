#!/usr/bin/env node

/**
 * VERIFICATION ENGINE
 * Proof-of-work verification system with screen recording
 * Generates GIF/Loom-style evidence that the system works
 */

const express = require('express');
const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');
const WebSocket = require('ws');

class VerificationEngine {
    constructor() {
        this.app = express();
        this.port = 42010;
        this.wsPort = 42011;
        
        // Recording state
        this.isRecording = false;
        this.recordingSession = null;
        this.browser = null;
        this.page = null;
        
        // Verification tests
        this.testSuite = [];
        this.results = [];
        
        // Paths
        this.outputDir = './verification-output';
        this.screenshotDir = path.join(this.outputDir, 'screenshots');
        this.videoDir = path.join(this.outputDir, 'videos');
        this.gifDir = path.join(this.outputDir, 'gifs');
        
        console.log('üîç Verification Engine initializing...');
        this.initialize();
    }
    
    async initialize() {
        try {
            // Create output directories
            this.createDirectories();
            
            // Setup middleware
            this.setupMiddleware();
            
            // Setup routes
            this.setupRoutes();
            
            // Setup WebSocket
            this.setupWebSocket();
            
            // Initialize browser
            await this.initializeBrowser();
            
            // Define test suite
            this.defineTestSuite();
            
            // Start server
            this.app.listen(this.port, () => {
                console.log(`üîç Verification Engine running on http://localhost:${this.port}`);
                console.log(`üìä Dashboard: http://localhost:${this.port}/verification-dashboard`);
            });
            
        } catch (error) {
            console.error('‚ùå Initialization failed:', error);
            process.exit(1);
        }
    }
    
    createDirectories() {
        [this.outputDir, this.screenshotDir, this.videoDir, this.gifDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });
    }
    
    setupMiddleware() {
        this.app.use(express.json());
        this.app.use(express.static('public'));
        this.app.use('/verification-output', express.static(this.outputDir));
    }
    
    setupRoutes() {
        // Health check
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                isRecording: this.isRecording,
                testsAvailable: this.testSuite.length,
                resultsGenerated: this.results.length
            });
        });
        
        // Start recording
        this.app.post('/api/recording/start', this.startRecording.bind(this));
        
        // Stop recording
        this.app.post('/api/recording/stop', this.stopRecording.bind(this));
        
        // Run verification test
        this.app.post('/api/test/run/:testId', this.runTest.bind(this));
        
        // Run all tests
        this.app.post('/api/test/run-all', this.runAllTests.bind(this));
        
        // Get test results
        this.app.get('/api/results', this.getResults.bind(this));
        
        // Generate proof package
        this.app.post('/api/proof/generate', this.generateProofPackage.bind(this));
        
        // Verification dashboard
        this.app.get('/verification-dashboard', this.serveVerificationDashboard.bind(this));
    }
    
    setupWebSocket() {\n        this.wss = new WebSocket.Server({ port: this.wsPort });\n        \n        this.wss.on('connection', (ws) => {\n            console.log('üîå Verification client connected');\n            \n            ws.send(JSON.stringify({\n                type: 'connected',\n                availableTests: this.testSuite.map(t => ({ id: t.id, name: t.name, description: t.description }))\n            }));\n            \n            ws.on('message', async (message) => {\n                try {\n                    const data = JSON.parse(message);\n                    await this.handleWebSocketMessage(ws, data);\n                } catch (error) {\n                    ws.send(JSON.stringify({ type: 'error', error: error.message }));\n                }\n            });\n        });\n    }\n    \n    async initializeBrowser() {\n        this.browser = await puppeteer.launch({\n            headless: false, // We want to see what's happening\n            defaultViewport: { width: 1920, height: 1080 },\n            args: [\n                '--no-sandbox',\n                '--disable-setuid-sandbox',\n                '--disable-dev-shm-usage',\n                '--disable-web-security',\n                '--allow-running-insecure-content'\n            ]\n        });\n        \n        this.page = await this.browser.newPage();\n        \n        // Set up page monitoring\n        this.page.on('console', msg => {\n            console.log('Browser console:', msg.text());\n        });\n        \n        this.page.on('pageerror', error => {\n            console.error('Browser error:', error);\n        });\n        \n        console.log('üåê Browser initialized');\n    }\n    \n    defineTestSuite() {\n        this.testSuite = [\n            {\n                id: 'character-registration',\n                name: 'Character Registration Flow',\n                description: 'Test complete character registration with QR generation',\n                steps: [\n                    { action: 'navigate', url: 'http://localhost:42002/qr-login' },\n                    { action: 'wait', duration: 2000 },\n                    { action: 'screenshot', name: 'qr-login-page' },\n                    { action: 'click', selector: '#refreshBtn' },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'screenshot', name: 'qr-generated' }\n                ]\n            },\n            {\n                id: 'chat-interface',\n                name: 'Chat Interface with Symbol Parsing',\n                description: 'Test typing messages with @, #, !, ? symbols',\n                steps: [\n                    { action: 'navigate', url: `file://${process.cwd()}/character-chat-interface.html` },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'screenshot', name: 'chat-interface' },\n                    { action: 'type', selector: '#chatInput', text: '@alice !quest(dragon) ?help #explore' },\n                    { action: 'screenshot', name: 'symbols-typed' },\n                    { action: 'click', selector: '#sendButton' },\n                    { action: 'wait', duration: 2000 },\n                    { action: 'screenshot', name: 'message-sent' }\n                ]\n            },\n            {\n                id: 'claude-query',\n                name: 'Claude API Query Test',\n                description: 'Test Claude querying character data',\n                steps: [\n                    { action: 'api-call', url: 'http://localhost:42006/api/claude/docs', method: 'GET' },\n                    { action: 'api-call', url: 'http://localhost:42006/api/claude/character/1', method: 'GET', headers: { 'X-API-Key': 'local-dev' } },\n                    { action: 'api-call', url: 'http://localhost:42006/api/claude/dialogue/1', method: 'GET', headers: { 'X-API-Key': 'local-dev' } }\n                ]\n            },\n            {\n                id: 'overlay-system',\n                name: 'RuneLite-Style Overlay Demo',\n                description: 'Test overlay system with quest markers',\n                steps: [\n                    { action: 'navigate', url: 'http://localhost:42007/overlay-demo' },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'screenshot', name: 'overlay-demo' },\n                    { action: 'click', selector: 'button[onclick=\"triggerQuest()\"]' },\n                    { action: 'wait', duration: 2000 },\n                    { action: 'screenshot', name: 'quest-overlay' },\n                    { action: 'click', selector: 'button[onclick=\"triggerHelp()\"]' },\n                    { action: 'wait', duration: 2000 },\n                    { action: 'screenshot', name: 'help-overlay' }\n                ]\n            },\n            {\n                id: 'monitoring-dashboard',\n                name: 'Live Monitoring Dashboard',\n                description: 'Test real-time monitoring and metrics',\n                steps: [\n                    { action: 'navigate', url: `file://${process.cwd()}/live-monitoring-dashboard.html` },\n                    { action: 'wait', duration: 5000 },\n                    { action: 'screenshot', name: 'monitoring-dashboard' },\n                    { action: 'click', selector: 'button[onclick=\"testSystem()\"]' },\n                    { action: 'wait', duration: 5000 },\n                    { action: 'screenshot', name: 'system-test-complete' }\n                ]\n            },\n            {\n                id: 'end-to-end',\n                name: 'Complete End-to-End Flow',\n                description: 'Full system verification from registration to Claude query',\n                steps: [\n                    { action: 'navigate', url: 'http://localhost:42002/qr-login' },\n                    { action: 'screenshot', name: 'e2e-start' },\n                    { action: 'click', selector: '#refreshBtn' },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'navigate', url: `file://${process.cwd()}/character-chat-interface.html` },\n                    { action: 'wait', duration: 2000 },\n                    { action: 'type', selector: '#chatInput', text: 'System verification test @claude !verify ?status' },\n                    { action: 'click', selector: '#sendButton' },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'navigate', url: `file://${process.cwd()}/live-monitoring-dashboard.html` },\n                    { action: 'wait', duration: 3000 },\n                    { action: 'screenshot', name: 'e2e-complete' }\n                ]\n            }\n        ];\n        \n        console.log(`üß™ Test suite defined: ${this.testSuite.length} tests`);\n    }\n    \n    async startRecording(req, res) {\n        try {\n            if (this.isRecording) {\n                return res.status(409).json({ error: 'Recording already in progress' });\n            }\n            \n            const { testId, format = 'mp4' } = req.body;\n            \n            this.isRecording = true;\n            const timestamp = Date.now();\n            \n            this.recordingSession = {\n                id: timestamp,\n                testId,\n                format,\n                startTime: timestamp,\n                outputFile: path.join(this.videoDir, `verification-${timestamp}.${format}`),\n                screenshots: []\n            };\n            \n            // Start screen recording (requires ffmpeg)\n            if (format === 'mp4') {\n                this.startScreenRecording();\n            }\n            \n            this.broadcastToClients({\n                type: 'recording_started',\n                session: this.recordingSession\n            });\n            \n            res.json({\n                success: true,\n                sessionId: timestamp,\n                message: 'Recording started'\n            });\n            \n        } catch (error) {\n            console.error('Recording start error:', error);\n            res.status(500).json({ error: error.message });\n        }\n    }\n    \n    async stopRecording(req, res) {\n        try {\n            if (!this.isRecording) {\n                return res.status(409).json({ error: 'No recording in progress' });\n            }\n            \n            this.isRecording = false;\n            \n            if (this.ffmpegProcess) {\n                this.ffmpegProcess.kill('SIGTERM');\n                this.ffmpegProcess = null;\n            }\n            \n            // Generate GIF from video if requested\n            if (this.recordingSession.format === 'mp4') {\n                await this.generateGifFromVideo();\n            }\n            \n            const session = this.recordingSession;\n            this.recordingSession = null;\n            \n            this.broadcastToClients({\n                type: 'recording_stopped',\n                session\n            });\n            \n            res.json({\n                success: true,\n                outputFile: session.outputFile,\n                duration: Date.now() - session.startTime,\n                screenshots: session.screenshots.length\n            });\n            \n        } catch (error) {\n            console.error('Recording stop error:', error);\n            res.status(500).json({ error: error.message });\n        }\n    }\n    \n    async runTest(req, res) {\n        try {\n            const testId = req.params.testId;\n            const test = this.testSuite.find(t => t.id === testId);\n            \n            if (!test) {\n                return res.status(404).json({ error: 'Test not found' });\n            }\n            \n            console.log(`üß™ Running test: ${test.name}`);\n            \n            const result = await this.executeTest(test);\n            this.results.push(result);\n            \n            this.broadcastToClients({\n                type: 'test_completed',\n                result\n            });\n            \n            res.json(result);\n            \n        } catch (error) {\n            console.error('Test execution error:', error);\n            res.status(500).json({ error: error.message });\n        }\n    }\n    \n    async runAllTests(req, res) {\n        try {\n            console.log('üß™ Running all verification tests...');\n            \n            const results = [];\n            \n            for (const test of this.testSuite) {\n                console.log(`‚ñ∂Ô∏è Running: ${test.name}`);\n                const result = await this.executeTest(test);\n                results.push(result);\n                \n                this.broadcastToClients({\n                    type: 'test_progress',\n                    completed: results.length,\n                    total: this.testSuite.length,\n                    current: result\n                });\n                \n                // Wait between tests\n                await new Promise(resolve => setTimeout(resolve, 2000));\n            }\n            \n            this.results = results;\n            \n            this.broadcastToClients({\n                type: 'all_tests_completed',\n                results\n            });\n            \n            res.json({\n                success: true,\n                totalTests: results.length,\n                passed: results.filter(r => r.success).length,\n                failed: results.filter(r => !r.success).length,\n                results\n            });\n            \n        } catch (error) {\n            console.error('Test suite execution error:', error);\n            res.status(500).json({ error: error.message });\n        }\n    }\n    \n    async executeTest(test) {\n        const startTime = Date.now();\n        const result = {\n            id: test.id,\n            name: test.name,\n            startTime,\n            endTime: null,\n            duration: null,\n            success: false,\n            screenshots: [],\n            apiResults: [],\n            errors: []\n        };\n        \n        try {\n            for (let i = 0; i < test.steps.length; i++) {\n                const step = test.steps[i];\n                console.log(`  üìã Step ${i + 1}: ${step.action}`);\n                \n                await this.executeStep(step, result);\n                \n                // Brief pause between steps\n                await new Promise(resolve => setTimeout(resolve, 500));\n            }\n            \n            result.success = true;\n            \n        } catch (error) {\n            console.error(`‚ùå Test ${test.id} failed:`, error);\n            result.errors.push(error.message);\n            result.success = false;\n        }\n        \n        result.endTime = Date.now();\n        result.duration = result.endTime - result.startTime;\n        \n        console.log(`${result.success ? '‚úÖ' : '‚ùå'} Test ${test.name} ${result.success ? 'passed' : 'failed'} (${result.duration}ms)`);\n        \n        return result;\n    }\n    \n    async executeStep(step, result) {\n        switch (step.action) {\n            case 'navigate':\n                await this.page.goto(step.url, { waitUntil: 'networkidle0' });\n                break;\n                \n            case 'wait':\n                await new Promise(resolve => setTimeout(resolve, step.duration));\n                break;\n                \n            case 'screenshot':\n                const screenshotPath = path.join(this.screenshotDir, `${result.id}-${step.name}-${Date.now()}.png`);\n                await this.page.screenshot({ path: screenshotPath, fullPage: true });\n                result.screenshots.push(screenshotPath);\n                break;\n                \n            case 'click':\n                await this.page.click(step.selector);\n                break;\n                \n            case 'type':\n                await this.page.type(step.selector, step.text);\n                break;\n                \n            case 'api-call':\n                const apiResult = await this.makeAPICall(step);\n                result.apiResults.push(apiResult);\n                break;\n                \n            default:\n                throw new Error(`Unknown step action: ${step.action}`);\n        }\n    }\n    \n    async makeAPICall(step) {\n        const fetch = (await import('node-fetch')).default;\n        \n        const options = {\n            method: step.method || 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                ...step.headers\n            }\n        };\n        \n        if (step.body) {\n            options.body = JSON.stringify(step.body);\n        }\n        \n        const startTime = Date.now();\n        const response = await fetch(step.url, options);\n        const endTime = Date.now();\n        \n        const result = {\n            url: step.url,\n            method: step.method || 'GET',\n            status: response.status,\n            responseTime: endTime - startTime,\n            headers: Object.fromEntries(response.headers),\n            body: null\n        };\n        \n        try {\n            result.body = await response.json();\n        } catch {\n            result.body = await response.text();\n        }\n        \n        return result;\n    }\n    \n    startScreenRecording() {\n        // Requires ffmpeg to be installed\n        const outputFile = this.recordingSession.outputFile;\n        \n        try {\n            this.ffmpegProcess = spawn('ffmpeg', [\n                '-f', 'avfoundation',\n                '-framerate', '30',\n                '-i', '1:0', // Screen:Audio\n                '-c:v', 'libx264',\n                '-preset', 'fast',\n                '-crf', '23',\n                '-c:a', 'aac',\n                '-b:a', '128k',\n                '-y',\n                outputFile\n            ]);\n            \n            console.log(`üé• Screen recording started: ${outputFile}`);\n            \n        } catch (error) {\n            console.warn('‚ö†Ô∏è Screen recording not available (ffmpeg required):', error.message);\n        }\n    }\n    \n    async generateGifFromVideo() {\n        if (!this.recordingSession) return;\n        \n        const inputFile = this.recordingSession.outputFile;\n        const outputFile = path.join(this.gifDir, `verification-${this.recordingSession.id}.gif`);\n        \n        try {\n            execSync(`ffmpeg -i ${inputFile} -vf \"fps=10,scale=800:-1:flags=lanczos\" -c:v gif ${outputFile}`);\n            console.log(`üéûÔ∏è GIF generated: ${outputFile}`);\n            \n            this.recordingSession.gifFile = outputFile;\n        } catch (error) {\n            console.warn('‚ö†Ô∏è GIF generation failed:', error.message);\n        }\n    }\n    \n    async generateProofPackage(req, res) {\n        try {\n            const timestamp = Date.now();\n            const packageName = `verification-proof-${timestamp}`;\n            const packageDir = path.join(this.outputDir, packageName);\n            \n            // Create package directory\n            fs.mkdirSync(packageDir, { recursive: true });\n            \n            // Generate comprehensive report\n            const report = {\n                timestamp: new Date().toISOString(),\n                system: {\n                    platform: process.platform,\n                    nodeVersion: process.version,\n                    architecture: process.arch\n                },\n                tests: this.results,\n                summary: {\n                    totalTests: this.results.length,\n                    passed: this.results.filter(r => r.success).length,\n                    failed: this.results.filter(r => !r.success).length,\n                    totalDuration: this.results.reduce((sum, r) => sum + r.duration, 0)\n                },\n                serviceEndpoints: {\n                    characterAPI: 'http://localhost:42001',\n                    qrAuth: 'http://localhost:42002',\n                    commandInterface: 'ws://localhost:42005',\n                    claudeAPI: 'http://localhost:42006',\n                    overlaySystem: 'http://localhost:42007'\n                },\n                proofOfWork: {\n                    screenshotsGenerated: this.results.reduce((sum, r) => sum + r.screenshots.length, 0),\n                    apiCallsMade: this.results.reduce((sum, r) => sum + r.apiResults.length, 0),\n                    verificationComplete: true\n                }\n            };\n            \n            // Write report\n            fs.writeFileSync(\n                path.join(packageDir, 'verification-report.json'),\n                JSON.stringify(report, null, 2)\n            );\n            \n            // Copy all screenshots\n            const screenshotPackageDir = path.join(packageDir, 'screenshots');\n            fs.mkdirSync(screenshotPackageDir, { recursive: true });\n            \n            this.results.forEach(result => {\n                result.screenshots.forEach(screenshot => {\n                    if (fs.existsSync(screenshot)) {\n                        const filename = path.basename(screenshot);\n                        fs.copyFileSync(screenshot, path.join(screenshotPackageDir, filename));\n                    }\n                });\n            });\n            \n            // Generate HTML report\n            const htmlReport = this.generateHTMLReport(report);\n            fs.writeFileSync(path.join(packageDir, 'verification-report.html'), htmlReport);\n            \n            res.json({\n                success: true,\n                packagePath: packageDir,\n                report,\n                message: 'Verification proof package generated'\n            });\n            \n        } catch (error) {\n            console.error('Proof package generation error:', error);\n            res.status(500).json({ error: error.message });\n        }\n    }\n    \n    generateHTMLReport(report) {\n        return `<!DOCTYPE html>\n<html>\n<head>\n    <title>System Verification Report</title>\n    <style>\n        body { font-family: monospace; background: #0a0a0f; color: #00ff88; padding: 20px; }\n        .header { text-align: center; margin-bottom: 30px; }\n        .section { margin: 20px 0; padding: 15px; border: 1px solid #00ff88; border-radius: 5px; }\n        .test-result { margin: 10px 0; padding: 10px; background: rgba(0,255,136,0.1); }\n        .success { border-left: 5px solid #00ff88; }\n        .failure { border-left: 5px solid #ff4444; }\n        .summary { text-align: center; font-size: 18px; margin: 20px 0; }\n        .timestamp { color: #666; font-size: 12px; }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <h1>üîç System Verification Report</h1>\n        <div class=\"timestamp\">Generated: ${report.timestamp}</div>\n    </div>\n    \n    <div class=\"summary\">\n        <strong>Tests: ${report.summary.totalTests} | Passed: ${report.summary.passed} | Failed: ${report.summary.failed}</strong>\n    </div>\n    \n    <div class=\"section\">\n        <h2>üìä Test Results</h2>\n        ${report.tests.map(test => `\n            <div class=\"test-result ${test.success ? 'success' : 'failure'}\">\n                <strong>${test.name}</strong> - ${test.success ? '‚úÖ PASSED' : '‚ùå FAILED'} (${test.duration}ms)<br>\n                Screenshots: ${test.screenshots.length} | API Calls: ${test.apiResults.length}\n                ${test.errors.length > 0 ? `<br>Errors: ${test.errors.join(', ')}` : ''}\n            </div>\n        `).join('')}\n    </div>\n    \n    <div class=\"section\">\n        <h2>üéØ Proof of Work</h2>\n        <p>‚úÖ Screenshots Generated: ${report.proofOfWork.screenshotsGenerated}</p>\n        <p>‚úÖ API Calls Made: ${report.proofOfWork.apiCallsMade}</p>\n        <p>‚úÖ System Verification: Complete</p>\n    </div>\n    \n    <div class=\"section\">\n        <h2>üîó Service Endpoints Verified</h2>\n        ${Object.entries(report.serviceEndpoints).map(([name, url]) => `<p>${name}: ${url}</p>`).join('')}\n    </div>\n</body>\n</html>`;\n    }\n    \n    getResults(req, res) {\n        res.json({\n            totalTests: this.results.length,\n            results: this.results,\n            summary: {\n                passed: this.results.filter(r => r.success).length,\n                failed: this.results.filter(r => !r.success).length,\n                totalDuration: this.results.reduce((sum, r) => sum + r.duration, 0)\n            }\n        });\n    }\n    \n    serveVerificationDashboard(req, res) {\n        // This would serve a comprehensive verification dashboard\n        // For now, redirect to monitoring dashboard\n        res.redirect('/live-monitoring-dashboard.html');\n    }\n    \n    broadcastToClients(data) {\n        this.wss.clients.forEach(client => {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(JSON.stringify(data));\n            }\n        });\n    }\n    \n    async handleWebSocketMessage(ws, data) {\n        switch (data.type) {\n            case 'start_test':\n                if (data.testId) {\n                    const test = this.testSuite.find(t => t.id === data.testId);\n                    if (test) {\n                        const result = await this.executeTest(test);\n                        ws.send(JSON.stringify({ type: 'test_result', result }));\n                    }\n                }\n                break;\n                \n            case 'get_status':\n                ws.send(JSON.stringify({\n                    type: 'status',\n                    isRecording: this.isRecording,\n                    testsCompleted: this.results.length\n                }));\n                break;\n        }\n    }\n    \n    async shutdown() {\n        console.log('üîç Verification Engine shutting down...');\n        \n        if (this.browser) {\n            await this.browser.close();\n        }\n        \n        if (this.ffmpegProcess) {\n            this.ffmpegProcess.kill('SIGTERM');\n        }\n        \n        if (this.wss) {\n            this.wss.close();\n        }\n    }\n}\n\n// Start the service\nconst verificationEngine = new VerificationEngine();\n\n// Handle shutdown\nprocess.on('SIGINT', async () => {\n    await verificationEngine.shutdown();\n    process.exit(0);\n});\n\nmodule.exports = VerificationEngine;