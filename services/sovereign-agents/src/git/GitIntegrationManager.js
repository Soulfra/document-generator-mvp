/**
 * Git Integration Manager - Automated Git operations for Sovereign Agents
 */

const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const EventEmitter = require('events');
const { v4: uuidv4 } = require('uuid');

class GitIntegrationManager extends EventEmitter {
  constructor(options = {}) {
    super();
    this.options = {
      workingDirectory: options.workingDirectory || process.cwd(),
      autoCommit: options.autoCommit !== false,
      autoCommitPattern: options.autoCommitPattern || 'auto: ',
      branchPrefix: options.branchPrefix || 'agent/',
      enableHooks: options.enableHooks !== false,
      maxConcurrentOps: options.maxConcurrentOps || 5,
      ...options
    };

    this.activeOperations = new Map();
    this.operationHistory = [];
    this.hooks = new Map();
    this.metrics = {
      commits: 0,
      branches: 0,
      merges: 0,
      rollbacks: 0,
      errors: 0
    };
  }

  /**
   * Initialize Git integration
   */
  async initialize() {
    try {
      console.log('üîÑ Initializing Git Integration Manager...');

      // Verify git repository
      await this.verifyGitRepository();

      // Set up git hooks if enabled
      if (this.options.enableHooks) {
        await this.setupGitHooks();
      }

      // Get current repository info
      this.repositoryInfo = await this.getRepositoryInfo();

      console.log('‚úÖ Git Integration Manager initialized');
      console.log(`üìç Repository: ${this.repositoryInfo.name}`);
      console.log(`üåø Current branch: ${this.repositoryInfo.currentBranch}`);

      this.emit('initialized', this.repositoryInfo);

    } catch (error) {
      console.error('‚ùå Git Integration Manager initialization failed:', error);
      throw error;
    }
  }

  /**
   * Create automated commit
   */
  async createAutoCommit(files = [], message, options = {}) {
    const operationId = uuidv4();
    
    try {
      const operation = {
        id: operationId,
        type: 'commit',
        startTime: new Date(),
        files,
        message,
        options
      };

      this.activeOperations.set(operationId, operation);

      console.log(`üìù Creating auto commit: ${message}`);
      this.emit('operation:started', operation);

      // Get current state for rollback
      const currentHead = await this.getCurrentCommit();

      // Stage files
      if (files.length > 0) {
        await this.executeGit(['add', ...files]);
      } else {
        await this.executeGit(['add', '.']);
      }

      // Check if there are changes to commit
      const status = await this.getStatus();
      if (status.staged.length === 0) {
        console.log('‚ÑπÔ∏è No changes to commit');
        this.activeOperations.delete(operationId);
        return null;
      }

      // Create commit
      const fullMessage = `${this.options.autoCommitPattern}${message}\n\nü§ñ Generated by Sovereign Agent\nOperation ID: ${operationId}`;
      
      await this.executeGit(['commit', '-m', fullMessage]);

      // Get new commit hash
      const newCommit = await this.getCurrentCommit();

      operation.result = {
        commitHash: newCommit.hash,
        previousHash: currentHead.hash,
        message: fullMessage,
        stagedFiles: status.staged.length
      };

      operation.endTime = new Date();
      operation.duration = operation.endTime - operation.startTime;
      operation.status = 'completed';

      this.operationHistory.unshift(operation);
      this.activeOperations.delete(operationId);
      this.metrics.commits++;

      console.log(`‚úÖ Auto commit created: ${newCommit.hash.substring(0, 8)}`);
      this.emit('commit:created', operation);

      return operation.result;

    } catch (error) {
      console.error(`‚ùå Auto commit failed (${operationId}):`, error.message);
      this.activeOperations.delete(operationId);
      this.metrics.errors++;
      this.emit('operation:failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Create feature branch for agent work
   */
  async createAgentBranch(agentId, feature, options = {}) {
    const operationId = uuidv4();
    
    try {
      const branchName = `${this.options.branchPrefix}${agentId}/${feature}`;
      const fromBranch = options.fromBranch || 'main';

      const operation = {
        id: operationId,
        type: 'branch',
        startTime: new Date(),
        branchName,
        fromBranch,
        agentId
      };

      this.activeOperations.set(operationId, operation);

      console.log(`üåø Creating agent branch: ${branchName}`);
      this.emit('operation:started', operation);

      // Check if branch already exists
      const branches = await this.listBranches();
      if (branches.all.includes(branchName)) {
        // Switch to existing branch
        await this.executeGit(['checkout', branchName]);
        console.log(`üîÑ Switched to existing branch: ${branchName}`);
      } else {
        // Create new branch
        await this.executeGit(['checkout', '-b', branchName, fromBranch]);
        console.log(`‚úÖ Created new branch: ${branchName}`);
      }

      operation.result = {
        branchName,
        created: !branches.all.includes(branchName),
        fromBranch
      };

      operation.endTime = new Date();
      operation.duration = operation.endTime - operation.startTime;
      operation.status = 'completed';

      this.operationHistory.unshift(operation);
      this.activeOperations.delete(operationId);
      this.metrics.branches++;

      this.emit('branch:created', operation);

      return operation.result;

    } catch (error) {
      console.error(`‚ùå Branch creation failed (${operationId}):`, error.message);
      this.activeOperations.delete(operationId);
      this.metrics.errors++;
      this.emit('operation:failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Create pull request (if supported by remote)
   */
  async createPullRequest(fromBranch, toBranch = 'main', title, description, options = {}) {
    const operationId = uuidv4();

    try {
      const operation = {
        id: operationId,
        type: 'pull_request',
        startTime: new Date(),
        fromBranch,
        toBranch,
        title,
        description
      };

      this.activeOperations.set(operationId, operation);

      console.log(`üîÄ Creating pull request: ${fromBranch} ‚Üí ${toBranch}`);
      this.emit('operation:started', operation);

      // Push branch if not already pushed
      await this.pushBranch(fromBranch);

      // Use GitHub CLI if available
      try {
        const result = await this.executeCommand('gh', [
          'pr', 'create',
          '--title', title,
          '--body', description,
          '--base', toBranch,
          '--head', fromBranch
        ]);

        operation.result = {
          url: result.stdout.trim(),
          fromBranch,
          toBranch,
          title
        };

        console.log(`‚úÖ Pull request created: ${operation.result.url}`);

      } catch (ghError) {
        // Fallback: create manual PR info
        operation.result = {
          manual: true,
          fromBranch,
          toBranch,
          title,
          description,
          message: 'Manual PR creation required - GitHub CLI not available'
        };

        console.log(`‚ö†Ô∏è Manual pull request required: ${fromBranch} ‚Üí ${toBranch}`);
      }

      operation.endTime = new Date();
      operation.duration = operation.endTime - operation.startTime;
      operation.status = 'completed';

      this.operationHistory.unshift(operation);
      this.activeOperations.delete(operationId);

      this.emit('pull_request:created', operation);

      return operation.result;

    } catch (error) {
      console.error(`‚ùå Pull request creation failed (${operationId}):`, error.message);
      this.activeOperations.delete(operationId);
      this.metrics.errors++;
      this.emit('operation:failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Merge branch with validation
   */
  async mergeBranch(fromBranch, toBranch = 'main', options = {}) {
    const operationId = uuidv4();

    try {
      const operation = {
        id: operationId,
        type: 'merge',
        startTime: new Date(),
        fromBranch,
        toBranch,
        options
      };

      this.activeOperations.set(operationId, operation);

      console.log(`üîÄ Merging branch: ${fromBranch} ‚Üí ${toBranch}`);
      this.emit('operation:started', operation);

      // Switch to target branch
      await this.executeGit(['checkout', toBranch]);

      // Pull latest changes
      await this.executeGit(['pull', 'origin', toBranch]);

      // Get current commit for rollback
      const premergeCommit = await this.getCurrentCommit();

      // Perform merge
      const mergeStrategy = options.strategy || 'merge';
      
      if (mergeStrategy === 'squash') {
        await this.executeGit(['merge', '--squash', fromBranch]);
        
        // Create squash commit
        const message = options.message || `Merge ${fromBranch} (squashed)`;
        await this.executeGit(['commit', '-m', message]);
      } else {
        await this.executeGit(['merge', fromBranch, '--no-ff']);
      }

      // Get new commit
      const postmergeCommit = await this.getCurrentCommit();

      operation.result = {
        fromBranch,
        toBranch,
        strategy: mergeStrategy,
        premergeCommit: premergeCommit.hash,
        postmergeCommit: postmergeCommit.hash
      };

      operation.endTime = new Date();
      operation.duration = operation.endTime - operation.startTime;
      operation.status = 'completed';

      this.operationHistory.unshift(operation);
      this.activeOperations.delete(operationId);
      this.metrics.merges++;

      console.log(`‚úÖ Branch merged successfully: ${postmergeCommit.hash.substring(0, 8)}`);
      this.emit('merge:completed', operation);

      return operation.result;

    } catch (error) {
      console.error(`‚ùå Branch merge failed (${operationId}):`, error.message);
      this.activeOperations.delete(operationId);
      this.metrics.errors++;
      this.emit('operation:failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Rollback to previous commit
   */
  async rollbackToCommit(commitHash, options = {}) {
    const operationId = uuidv4();

    try {
      const operation = {
        id: operationId,
        type: 'rollback',
        startTime: new Date(),
        targetCommit: commitHash,
        options
      };

      this.activeOperations.set(operationId, operation);

      console.log(`üîÑ Rolling back to commit: ${commitHash}`);
      this.emit('operation:started', operation);

      // Get current commit
      const currentCommit = await this.getCurrentCommit();

      // Perform rollback
      const resetType = options.resetType || 'hard';
      await this.executeGit(['reset', `--${resetType}`, commitHash]);

      operation.result = {
        fromCommit: currentCommit.hash,
        toCommit: commitHash,
        resetType
      };

      operation.endTime = new Date();
      operation.duration = operation.endTime - operation.startTime;
      operation.status = 'completed';

      this.operationHistory.unshift(operation);
      this.activeOperations.delete(operationId);
      this.metrics.rollbacks++;

      console.log(`‚úÖ Rolled back to: ${commitHash.substring(0, 8)}`);
      this.emit('rollback:completed', operation);

      return operation.result;

    } catch (error) {
      console.error(`‚ùå Rollback failed (${operationId}):`, error.message);
      this.activeOperations.delete(operationId);
      this.metrics.errors++;
      this.emit('operation:failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Get repository status
   */
  async getStatus() {
    const result = await this.executeGit(['status', '--porcelain']);
    const lines = result.stdout.split('\n').filter(line => line.trim());

    const status = {
      staged: [],
      unstaged: [],
      untracked: [],
      clean: lines.length === 0
    };

    for (const line of lines) {
      const statusCode = line.substring(0, 2);
      const file = line.substring(3);

      if (statusCode[0] !== ' ' && statusCode[0] !== '?') {
        status.staged.push({ file, status: statusCode[0] });
      }
      if (statusCode[1] !== ' ') {
        if (statusCode[1] === '?') {
          status.untracked.push(file);
        } else {
          status.unstaged.push({ file, status: statusCode[1] });
        }
      }
    }

    return status;
  }

  /**
   * Get commit history
   */
  async getCommitHistory(limit = 10, branch = 'HEAD') {
    const result = await this.executeGit([
      'log',
      '--oneline',
      '--format=%H|%an|%ae|%ad|%s',
      '--date=iso',
      `-${limit}`,
      branch
    ]);

    const commits = result.stdout.split('\n')
      .filter(line => line.trim())
      .map(line => {
        const [hash, author, email, date, message] = line.split('|');
        return {
          hash,
          author,
          email,
          date: new Date(date),
          message
        };
      });

    return commits;
  }

  /**
   * List branches
   */
  async listBranches() {
    const result = await this.executeGit(['branch', '-a']);
    const lines = result.stdout.split('\n').filter(line => line.trim());

    const branches = {
      current: null,
      local: [],
      remote: [],
      all: []
    };

    for (const line of lines) {
      const trimmed = line.trim();
      const isCurrent = trimmed.startsWith('* ');
      const branchName = trimmed.replace(/^\* /, '').replace(/^remotes\//, '');

      if (isCurrent) {
        branches.current = branchName;
      }

      if (trimmed.startsWith('remotes/')) {
        branches.remote.push(branchName);
      } else {
        branches.local.push(branchName.replace(/^\* /, ''));
      }

      branches.all.push(branchName);
    }

    return branches;
  }

  /**
   * Push branch to remote
   */
  async pushBranch(branchName, remote = 'origin') {
    try {
      await this.executeGit(['push', remote, branchName]);
      console.log(`üì§ Pushed branch: ${branchName} to ${remote}`);
      return true;
    } catch (error) {
      // Try with -u flag for new branches
      try {
        await this.executeGit(['push', '-u', remote, branchName]);
        console.log(`üì§ Pushed new branch: ${branchName} to ${remote}`);
        return true;
      } catch (secondError) {
        console.error(`‚ùå Failed to push branch ${branchName}:`, secondError.message);
        throw secondError;
      }
    }
  }

  /**
   * Get current commit info
   */
  async getCurrentCommit() {
    const result = await this.executeGit(['rev-parse', 'HEAD']);
    const hash = result.stdout.trim();

    const infoResult = await this.executeGit([
      'log', '-1',
      '--format=%an|%ae|%ad|%s',
      '--date=iso'
    ]);

    const [author, email, date, message] = infoResult.stdout.split('|');

    return {
      hash,
      author,
      email,
      date: new Date(date),
      message
    };
  }

  /**
   * Get repository information
   */
  async getRepositoryInfo() {
    const remoteResult = await this.executeGit(['remote', 'get-url', 'origin']);
    const branchResult = await this.executeGit(['branch', '--show-current']);
    const statusResult = await this.getStatus();

    const remoteUrl = remoteResult.stdout.trim();
    const repoName = remoteUrl.split('/').pop().replace('.git', '');

    return {
      name: repoName,
      remoteUrl,
      currentBranch: branchResult.stdout.trim(),
      workingDirectory: this.options.workingDirectory,
      status: statusResult
    };
  }

  /**
   * Setup git hooks
   */
  async setupGitHooks() {
    const hooksDir = path.join(this.options.workingDirectory, '.git', 'hooks');

    // Pre-commit hook
    const preCommitHook = `#!/bin/sh
# Sovereign Agent pre-commit hook
echo "ü§ñ Sovereign Agent pre-commit validation..."

# Add validation logic here
exit 0
`;

    await fs.writeFile(path.join(hooksDir, 'pre-commit'), preCommitHook, { mode: 0o755 });

    // Post-commit hook
    const postCommitHook = `#!/bin/sh
# Sovereign Agent post-commit hook
echo "üìù Commit completed by Sovereign Agent"

# Notify event bus about commit
# (This would integrate with the EventBus system)
`;

    await fs.writeFile(path.join(hooksDir, 'post-commit'), postCommitHook, { mode: 0o755 });

    console.log('‚úÖ Git hooks installed');
  }

  /**
   * Verify git repository
   */
  async verifyGitRepository() {
    try {
      await this.executeGit(['rev-parse', '--git-dir']);
      return true;
    } catch (error) {
      throw new Error('Not a git repository');
    }
  }

  /**
   * Execute git command
   */
  async executeGit(args) {
    return this.executeCommand('git', args);
  }

  /**
   * Execute shell command
   */
  async executeCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, {
        cwd: this.options.workingDirectory,
        stdio: 'pipe'
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => stdout += data.toString());
      process.stderr.on('data', (data) => stderr += data.toString());

      process.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout: stdout.trim(), stderr: stderr.trim() });
        } else {
          reject(new Error(`Command failed (${code}): ${stderr || stdout}`));
        }
      });

      process.on('error', (error) => {
        reject(new Error(`Command execution error: ${error.message}`));
      });
    });
  }

  /**
   * Get operation metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      activeOperations: this.activeOperations.size,
      operationHistory: this.operationHistory.length,
      repositoryInfo: this.repositoryInfo
    };
  }

  /**
   * Get active operations
   */
  getActiveOperations() {
    return Array.from(this.activeOperations.values());
  }

  /**
   * Get operation history
   */
  getOperationHistory(limit = 50) {
    return this.operationHistory.slice(0, limit);
  }

  /**
   * Cancel active operation
   */
  async cancelOperation(operationId) {
    const operation = this.activeOperations.get(operationId);
    if (!operation) {
      throw new Error(`Operation not found: ${operationId}`);
    }

    // Mark as cancelled (actual cancellation depends on operation type)
    operation.status = 'cancelled';
    operation.endTime = new Date();

    this.activeOperations.delete(operationId);
    this.operationHistory.unshift(operation);

    console.log(`üö´ Operation cancelled: ${operationId}`);
    this.emit('operation:cancelled', operation);

    return operation;
  }

  /**
   * Cleanup old operation history
   */
  cleanup(maxHistory = 1000) {
    if (this.operationHistory.length > maxHistory) {
      this.operationHistory = this.operationHistory.slice(0, maxHistory);
      console.log(`üßπ Cleaned up operation history (kept ${maxHistory} entries)`);
    }
  }

  /**
   * Health check
   */
  async healthCheck() {
    try {
      await this.verifyGitRepository();
      const status = await this.getStatus();
      
      return {
        healthy: true,
        repository: this.repositoryInfo,
        status,
        activeOperations: this.activeOperations.size,
        metrics: this.metrics
      };
    } catch (error) {
      return {
        healthy: false,
        error: error.message
      };
    }
  }
}

module.exports = GitIntegrationManager;