#!/usr/bin/env node

/**
 * 🧹 CODE QUALITY CHECKER
 * 
 * Ensures generated code is production-ready with no slop
 * Removes placeholders, adds error handling, ensures consistency
 */

const fs = require('fs').promises;
const path = require('path');
const EventEmitter = require('events');

class CodeQualityChecker extends EventEmitter {
    constructor() {
        super();
        
        this.rules = {
            remove: {
                consoleLogs: /console\.(log|debug|trace)\s*\([^)]*\);?/g,
                todoComments: /\/\/\s*(TODO|FIXME|HACK|XXX|NOTE):.*/gi,
                placeholders: /\/\/\s*(placeholder|implement|add.*here|your.*code.*here)/gi,
                debugCode: /debugger;?/g,
                unusedImports: /import\s+{\s*}\s+from\s+['"][^'"]+['"]/g,
                emptyBlocks: /{\s*\/\/\s*}\s*;?/g,
                multipleNewlines: /\n{3,}/g
            },
            
            ensure: {
                errorHandling: {
                    asyncFunctions: /async\s+function|async\s*\(/g,
                    promises: /\.then\s*\(/g,
                    callbacks: /\((err|error),\s*[^)]+\)\s*=>/g
                },
                
                naming: {
                    camelCase: /^[a-z][a-zA-Z0-9]*$/,
                    pascalCase: /^[A-Z][a-zA-Z0-9]*$/,
                    kebabCase: /^[a-z]+(-[a-z]+)*$/,
                    snakeCase: /^[a-z]+(_[a-z]+)*$/
                },
                
                documentation: {
                    functions: /(?:function|const|let|var)\s+(\w+)\s*(?:=\s*)?\(/g,
                    classes: /class\s+(\w+)/g,
                    exports: /(?:module\.)?exports\.(\w+)|export\s+(?:default\s+)?(?:class|function|const|let|var)\s+(\w+)/g
                }
            },
            
            add: {
                errorHandling: {
                    tryWrapper: (code) => `try {\n${code}\n} catch (error) {\n  console.error('Error:', error);\n  throw error;\n}`,
                    asyncWrapper: (code) => code.replace(/async\s+function\s+(\w+)\s*\([^)]*\)\s*{/, 
                        'async function $1(...args) {\n  try {'),
                    promiseCatch: (code) => code.replace(/\.then\(([^)]+)\)(?![\s\S]*\.catch)/g, 
                        '.then($1).catch(error => { console.error("Promise error:", error); throw error; })')
                },
                
                documentation: {
                    jsdoc: (name, type = 'function') => 
`/**
 * ${name} - ${type === 'class' ? 'Class' : 'Function'} description
 * @param {*} params - Parameter description
 * @returns {*} Return description
 */`,
                    moduleHeader: (filename) => 
`/**
 * ${filename}
 * Generated by Document Generator
 * ${new Date().toISOString()}
 */

`
                }
            }
        };
        
        this.stats = {
            filesProcessed: 0,
            issuesFixed: 0,
            errorHandlingAdded: 0,
            documentationAdded: 0
        };
    }
    
    async cleanProject(projectPath) {
        console.log('🧹 Starting code quality check...');
        this.emit('start', { projectPath });
        
        try {
            const files = await this.findCodeFiles(projectPath);
            
            for (const file of files) {
                await this.cleanFile(file);
            }
            
            console.log('\n✅ Code quality check complete!');
            console.log(`📊 Stats:`);
            console.log(`   Files processed: ${this.stats.filesProcessed}`);
            console.log(`   Issues fixed: ${this.stats.issuesFixed}`);
            console.log(`   Error handling added: ${this.stats.errorHandlingAdded}`);
            console.log(`   Documentation added: ${this.stats.documentationAdded}`);
            
            this.emit('complete', this.stats);
            
            return this.stats;
            
        } catch (error) {
            console.error('❌ Quality check failed:', error);
            this.emit('error', error);
            throw error;
        }
    }
    
    async cleanFile(filePath) {
        try {
            console.log(`  📄 Processing: ${path.basename(filePath)}`);
            
            let content = await fs.readFile(filePath, 'utf8');
            const originalContent = content;
            let issuesFixed = 0;
            
            // Step 1: Remove unwanted patterns
            for (const [ruleName, pattern] of Object.entries(this.rules.remove)) {
                const matches = content.match(pattern);
                if (matches) {
                    content = content.replace(pattern, '');
                    issuesFixed += matches.length;
                    console.log(`    - Removed ${matches.length} ${ruleName}`);
                }
            }
            
            // Step 2: Ensure error handling
            const errorHandlingAdded = await this.ensureErrorHandling(content, filePath);
            if (errorHandlingAdded.changed) {
                content = errorHandlingAdded.content;
                this.stats.errorHandlingAdded += errorHandlingAdded.count;
                console.log(`    - Added ${errorHandlingAdded.count} error handlers`);
            }
            
            // Step 3: Add documentation
            const docsAdded = await this.ensureDocumentation(content, filePath);
            if (docsAdded.changed) {
                content = docsAdded.content;
                this.stats.documentationAdded += docsAdded.count;
                console.log(`    - Added ${docsAdded.count} documentation blocks`);
            }
            
            // Step 4: Fix formatting
            content = this.fixFormatting(content);
            
            // Step 5: Validate naming conventions
            const namingIssues = this.validateNaming(content);
            if (namingIssues.length > 0) {
                console.log(`    ⚠️  Found ${namingIssues.length} naming convention issues`);
            }
            
            // Save if changed
            if (content !== originalContent) {
                await fs.writeFile(filePath, content);
                this.stats.issuesFixed += issuesFixed;
                console.log(`    ✅ File cleaned and saved`);
            } else {
                console.log(`    ✓ File already clean`);
            }
            
            this.stats.filesProcessed++;
            
        } catch (error) {
            console.error(`    ❌ Error processing ${filePath}:`, error.message);
        }
    }
    
    async findCodeFiles(projectPath) {
        const files = [];
        const extensions = ['.js', '.jsx', '.ts', '.tsx', '.mjs'];
        const ignoreDirs = ['node_modules', '.git', 'dist', 'build', 'coverage'];
        
        async function scan(dir) {
            const entries = await fs.readdir(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory()) {
                    if (!ignoreDirs.includes(entry.name)) {
                        await scan(fullPath);
                    }
                } else if (entry.isFile()) {
                    const ext = path.extname(entry.name);
                    if (extensions.includes(ext)) {
                        files.push(fullPath);
                    }
                }
            }
        }
        
        await scan(projectPath);
        return files;
    }
    
    async ensureErrorHandling(content, filePath) {
        let changed = false;
        let count = 0;
        let newContent = content;
        
        // Check for async functions without try/catch
        const asyncFunctions = content.match(/async\s+function\s+\w+\s*\([^)]*\)\s*{[^}]+}/g) || [];
        
        for (const func of asyncFunctions) {
            if (!func.includes('try {')) {
                // Extract function body
                const bodyMatch = func.match(/async\s+function\s+(\w+)\s*\([^)]*\)\s*{([^}]+)}/);
                if (bodyMatch) {
                    const [fullMatch, funcName, body] = bodyMatch;
                    const wrappedBody = `async function ${funcName}(...args) {\n  try {${body}\n  } catch (error) {\n    console.error('Error in ${funcName}:', error);\n    throw error;\n  }\n}`;
                    newContent = newContent.replace(fullMatch, wrappedBody);
                    changed = true;
                    count++;
                }
            }
        }
        
        // Check for .then() without .catch()
        const promiseChains = content.match(/\.then\([^)]+\)(?![\s\S]*?\.catch)/g) || [];
        
        for (const chain of promiseChains) {
            newContent = newContent.replace(chain, `${chain}.catch(error => { console.error('Promise error:', error); throw error; })`);
            changed = true;
            count++;
        }
        
        return { changed, content: newContent, count };
    }
    
    async ensureDocumentation(content, filePath) {
        let changed = false;
        let count = 0;
        let newContent = content;
        
        // Add file header if missing
        if (!content.startsWith('/**') && !content.startsWith('//')) {
            newContent = this.rules.add.documentation.moduleHeader(path.basename(filePath)) + newContent;
            changed = true;
            count++;
        }
        
        // Find undocumented functions
        const functionMatches = [...content.matchAll(/(?:^|\n)((?:export\s+)?(?:async\s+)?function\s+(\w+)|(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?(?:function|\([^)]*\)\s*=>))/g)];
        
        for (const match of functionMatches) {
            const [fullMatch, , funcName1, funcName2] = match;
            const funcName = funcName1 || funcName2;
            const index = match.index;
            
            // Check if there's already documentation above
            const before = content.substring(Math.max(0, index - 200), index);
            if (!before.includes('/**') && !before.includes('//')) {
                const indent = fullMatch.match(/^\s*/)?.[0] || '';
                const jsdoc = this.rules.add.documentation.jsdoc(funcName, 'function')
                    .split('\n')
                    .map(line => indent + line)
                    .join('\n');
                
                newContent = newContent.slice(0, index) + jsdoc + '\n' + newContent.slice(index);
                changed = true;
                count++;
            }
        }
        
        return { changed, content: newContent, count };
    }
    
    fixFormatting(content) {
        // Remove multiple empty lines
        content = content.replace(/\n{3,}/g, '\n\n');
        
        // Ensure newline at end of file
        if (!content.endsWith('\n')) {
            content += '\n';
        }
        
        // Fix spacing around operators
        content = content.replace(/\s*([=+\-*/<>!&|])\s*/g, ' $1 ');
        
        // Fix spacing after commas
        content = content.replace(/,(?!\s)/g, ', ');
        
        // Fix spacing in objects
        content = content.replace(/{\s*}/g, '{}');
        content = content.replace(/\[\s*\]/g, '[]');
        
        return content;
    }
    
    validateNaming(content) {
        const issues = [];
        
        // Check variable names
        const variableDeclarations = content.match(/(?:const|let|var)\s+(\w+)/g) || [];
        
        for (const decl of variableDeclarations) {
            const varName = decl.match(/(?:const|let|var)\s+(\w+)/)?.[1];
            if (varName && !this.rules.ensure.naming.camelCase.test(varName) && 
                !varName.startsWith('_') && !varName.toUpperCase() === varName) {
                issues.push({ type: 'variable', name: varName, expected: 'camelCase' });
            }
        }
        
        // Check class names
        const classDeclarations = content.match(/class\s+(\w+)/g) || [];
        
        for (const decl of classDeclarations) {
            const className = decl.match(/class\s+(\w+)/)?.[1];
            if (className && !this.rules.ensure.naming.pascalCase.test(className)) {
                issues.push({ type: 'class', name: className, expected: 'PascalCase' });
            }
        }
        
        return issues;
    }
}

// Export for use
module.exports = CodeQualityChecker;

// CLI interface
if (require.main === module) {
    const checker = new CodeQualityChecker();
    const projectPath = process.argv[2] || '.';
    
    console.log(`🧹 Running code quality check on: ${projectPath}`);
    
    checker.cleanProject(projectPath)
        .then(stats => {
            console.log('\n✨ Code quality check complete!');
            process.exit(0);
        })
        .catch(error => {
            console.error('\n❌ Quality check failed:', error);
            process.exit(1);
        });
}