<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆü§ñ Secure Agentic OS PWA</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiU2VjdXJlIEFnZW50aWMgT1MiLCJzaG9ydF9uYW1lIjoiQWdlbnRpY09TIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJ0aGVtZV9jb2xvciI6IiMwMGZmZmYiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0lpSUhacFpYZENiM2c5SWpBZ01DQXlNREFnTWpBd0lpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnbzhjbVZqZENCM2FXUjBhRDBpTWpBd0lpQm9aV2xuYUhROUlqSXdNQ0lpSUdacGJHdzlJaU13TURBaUx6NEtQSFJsZUhRZ2VEMGlNVEF3SWlCNVBTSTVNQ0lpSUhSbGVIUXRZVzVqYUc5eVBTSnRhV1JrYkdVaUlHWnZiblF0YzJsNlpUMGlOekFpSUdacGJHdzlJaU13Wm1abUlpNDRRWGRsYm5ScFl5NEpQQzlqZW5RK1BDOXpkbWMrIiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:application/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZXZlbnQgPT4gewogICAgc2VsZi5za2lwV2FpdGluZygpOwp9KTsKCnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCBldmVudCA9PiB7CiAgICBldmVudC5yZXNwb25kV2l0aChmZXRjaChldmVudC5yZXF1ZXN0KSk7Cn0pOw==');
        }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }
        
        .agentic-os {
            display: grid;
            grid-template-areas: 
                "clippy brain games"
                "terminal workflow wallet";
            grid-template-rows: 1fr 1fr;
            grid-template-columns: 1fr 1fr 1fr;
            height: 100vh;
            gap: 5px;
            padding: 5px;
        }
        
        .panel {
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            background: rgba(0, 255, 255, 0.05);
            overflow-y: auto;
            position: relative;
        }
        
        #clippy-panel {
            grid-area: clippy;
            background: linear-gradient(45deg, #001a1a, #002a2a);
        }
        
        #brain-panel {
            grid-area: brain;
            background: linear-gradient(135deg, #1a0020, #2a0030);
        }
        
        #games-panel {
            grid-area: games;
            background: linear-gradient(225deg, #002000, #003000);
        }
        
        #terminal-panel {
            grid-area: terminal;
            background: linear-gradient(315deg, #200000, #300000);
        }
        
        #workflow-panel {
            grid-area: workflow;
            background: linear-gradient(45deg, #0a0a2a, #1a1a3a);
        }
        
        #wallet-panel {
            grid-area: wallet;
            background: linear-gradient(135deg, #2a2a00, #3a3a00);
        }
        
        .clippy-avatar {
            font-size: 2rem;
            text-align: center;
            margin-bottom: 10px;
            animation: bounce 2s infinite;
            cursor: pointer;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 8px;
            margin: 3px 0;
            width: 100%;
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .btn:hover {
            background: rgba(0, 255, 255, 0.4);
        }
        
        .terminal {
            background: #000;
            padding: 8px;
            height: 150px;
            overflow-y: auto;
            font-size: 10px;
            border: 1px solid #333;
            margin: 5px 0;
        }
        
        .input {
            width: 100%;
            background: #000;
            color: #0ff;
            border: 1px solid #333;
            padding: 5px;
            font-family: monospace;
            font-size: 10px;
        }
        
        .brain-viz {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        
        .brain-layer {
            width: 15px;
            height: 15px;
            background: #0ff;
            border-radius: 50%;
            animation: brainPulse 3s infinite;
        }
        
        @keyframes brainPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        .game-area {
            background: #001;
            border: 1px solid #333;
            padding: 10px;
            margin: 5px 0;
            min-height: 100px;
            position: relative;
        }
        
        .encrypted-capsule {
            border: 1px dashed #0ff;
            padding: 5px;
            margin: 3px 0;
            font-size: 10px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .workflow-step {
            display: flex;
            align-items: center;
            padding: 3px;
            margin: 2px 0;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 11px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-active { background: #0f0; }
        .status-pending { background: #ff0; }
        .status-complete { background: #0ff; }
        
        .wallet-balance {
            text-align: center;
            font-size: 1.2rem;
            color: #ff0;
            margin: 10px 0;
        }
        
        .toast {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .agentic-os {
                grid-template-areas: 
                    "clippy"
                    "brain"
                    "games"
                    "terminal"
                    "workflow"
                    "wallet";
                grid-template-columns: 1fr;
                grid-template-rows: repeat(6, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="agentic-os">
        <!-- Clippy Panel -->
        <div id="clippy-panel" class="panel">
            <div class="clippy-avatar" onclick="clippyInteract()">üìé</div>
            <h4>Agentic Clippy</h4>
            <div id="clippy-status">Observing & Learning...</div>
            <div id="clippy-messages" class="terminal">
                <div>üìé Secure PWA initialized!</div>
                <div>üîí All data encrypted locally</div>
                <div>üéÆ Ready for verification games</div>
            </div>
            <button class="btn" onclick="uploadDocument()">üìÑ Upload Document</button>
            <button class="btn" onclick="startPatternVerification()">üéØ Verify Patterns</button>
        </div>
        
        <!-- Brain Panel -->
        <div id="brain-panel" class="panel">
            <h4>üß† AI Brain (Local)</h4>
            <div class="brain-viz">
                <!-- 23 layers represented as dots -->
            </div>
            <div id="brain-status">Status: LEARNING</div>
            <div class="encrypted-capsule">
                üîí <span id="patterns-learned">0</span> patterns learned
            </div>
            <div class="encrypted-capsule">
                üìä <span id="accuracy">85%</span> accuracy
            </div>
            <div class="encrypted-capsule">
                üèóÔ∏è <span id="components-generated">0</span> components generated
            </div>
            <button class="btn" onclick="trainAI()">üß† Train AI</button>
        </div>
        
        <!-- Games Panel -->
        <div id="games-panel" class="panel">
            <h4>üéÆ Verification Games</h4>
            <div class="game-area" id="game-area">
                <div style="text-align: center; padding: 20px;">
                    <div>üéØ Ready for games!</div>
                    <div style="font-size: 10px; margin-top: 5px;">Upload documents to create verification games</div>
                </div>
            </div>
            <button class="btn" onclick="startMinesweeper()">üí£ Crypto Sweeper</button>
            <button class="btn" onclick="startFlashcards()">üé¥ Study Cards</button>
            <button class="btn" onclick="startQuiz()">‚ùì Pattern Quiz</button>
        </div>
        
        <!-- Terminal Panel -->
        <div id="terminal-panel" class="panel">
            <h4>üíª Secure Terminal</h4>
            <div class="terminal" id="terminal">
                <div>Secure Agentic OS v1.0</div>
                <div>üîí Encryption: AES-256</div>
                <div>üè† Storage: Local Only</div>
                <div>üì± Platform: PWA</div>
                <div>&gt; system ready</div>
            </div>
            <input class="input" id="terminal-input" placeholder="Enter command..." 
                   onkeypress="handleTerminalInput(event)">
            <button class="btn" onclick="exportData()">üì§ Export Capsules</button>
        </div>
        
        <!-- Workflow Panel -->
        <div id="workflow-panel" class="panel">
            <h4>‚ö° Auto Workflows</h4>
            <div id="workflow-list">
                <div class="workflow-step">
                    <div class="status-dot status-active"></div>
                    Document Processing
                </div>
                <div class="workflow-step">
                    <div class="status-dot status-pending"></div>
                    Pattern Extraction
                </div>
                <div class="workflow-step">
                    <div class="status-dot status-pending"></div>
                    Component Generation
                </div>
            </div>
            <button class="btn" onclick="createWorkflow()">‚ö° New Workflow</button>
            <button class="btn" onclick="executeAutomation()">ü§ñ Run Automation</button>
        </div>
        
        <!-- Wallet Panel -->
        <div id="wallet-panel" class="panel">
            <h4>üí≥ Gaming Wallet</h4>
            <div class="wallet-balance">
                ü™ô <span id="coin-balance">1000</span>
            </div>
            <div class="encrypted-capsule">
                üéí <span id="inventory-count">3</span> items
            </div>
            <div class="encrypted-capsule">
                üèÜ Level <span id="player-level">1</span>
            </div>
            <div class="encrypted-capsule">
                ‚≠ê <span id="xp-points">0</span> XP
            </div>
            <button class="btn" onclick="openInventory()">üéí Inventory</button>
            <button class="btn" onclick="tradeItems()">üîÑ Trade</button>
        </div>
    </div>
    
    <!-- Toast Notifications -->
    <div id="toast" class="toast"></div>
    
    <!-- Hidden File Input -->
    <input type="file" id="file-input" style="display: none;" accept=".txt,.md,.pdf" onchange="processUploadedFile(event)">

    <script>
        // ===== SECURE AGENTIC PWA CORE =====
        class SecureAgenticPWA {
            constructor() {
                this.encryptionKey = null;
                this.localDatabase = new Map();
                this.aiModel = new LocalAIModel();
                this.patternExtractor = new PatternExtractor();
                this.componentGenerator = new ComponentGenerator();
                this.gameEngine = new VerificationGameEngine();
                this.workflowAutomator = new WorkflowAutomator();
                this.secureWallet = new SecureWallet();
                
                this.initializeEncryption();
                this.initializeBrainVisualization();
                this.startClippyObservation();
                
                console.log('üéÆü§ñ Secure Agentic PWA initialized');
            }
            
            async initializeEncryption() {
                // Generate local encryption key
                this.encryptionKey = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );
                
                this.showToast('üîí Encryption initialized');
            }
            
            async encryptData(data) {
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(JSON.stringify(data));
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    dataBuffer
                );
                
                return {
                    iv: Array.from(iv),
                    data: Array.from(new Uint8Array(encrypted))
                };
            }
            
            async decryptData(encryptedData) {
                const iv = new Uint8Array(encryptedData.iv);
                const data = new Uint8Array(encryptedData.data);
                
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.encryptionKey,
                    data
                );
                
                const decoder = new TextDecoder();
                return JSON.parse(decoder.decode(decrypted));
            }
            
            initializeBrainVisualization() {
                const brainViz = document.querySelector('.brain-viz');
                for (let i = 0; i < 23; i++) {
                    const layer = document.createElement('div');
                    layer.className = 'brain-layer';
                    layer.style.animationDelay = `${i * 0.1}s`;
                    brainViz.appendChild(layer);
                }
                
                // Simulate brain activity
                setInterval(() => {
                    const layers = document.querySelectorAll('.brain-layer');
                    const randomLayer = layers[Math.floor(Math.random() * layers.length)];
                    randomLayer.style.background = '#ff0';
                    setTimeout(() => randomLayer.style.background = '#0ff', 200);
                }, 1000);
            }
            
            startClippyObservation() {
                setInterval(() => {
                    if (Math.random() < 0.1) { // 10% chance every 30 seconds
                        this.clippyComment();
                    }
                }, 30000);
            }
            
            clippyComment() {
                const comments = [
                    "üìé I see you're working! Upload a document and I'll create games from it.",
                    "‚ö° Your AI is learning! Each verification makes me smarter.",
                    "üéÆ Ready for a pattern verification game?",
                    "üîí All your data is encrypted locally - completely secure!",
                    "üèóÔ∏è I can generate components from your verified patterns."
                ];
                
                const comment = comments[Math.floor(Math.random() * comments.length)];
                this.addClippyMessage(comment);
            }
            
            addClippyMessage(message) {
                const messagesDiv = document.getElementById('clippy-messages');
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                
                // Keep only last 10 messages
                while (messagesDiv.children.length > 10) {
                    messagesDiv.removeChild(messagesDiv.firstChild);
                }
            }
            
            addTerminalOutput(text) {
                const terminal = document.getElementById('terminal');
                const line = document.createElement('div');
                line.textContent = text;
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                
                // Keep only last 20 lines
                while (terminal.children.length > 20) {
                    terminal.removeChild(terminal.firstChild);
                }
            }
            
            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
            
            updateStats() {
                document.getElementById('patterns-learned').textContent = this.aiModel.patternsLearned;
                document.getElementById('accuracy').textContent = Math.round(this.aiModel.accuracy * 100) + '%';
                document.getElementById('components-generated').textContent = this.componentGenerator.componentsGenerated;
                document.getElementById('coin-balance').textContent = this.secureWallet.balance;
                document.getElementById('inventory-count').textContent = this.secureWallet.inventory.length;
            }
        }
        
        // ===== LOCAL AI MODEL =====
        class LocalAIModel {
            constructor() {
                this.patterns = new Map();
                this.patternsLearned = 0;
                this.accuracy = 0.85;
                this.verificationHistory = [];
            }
            
            learnFromVerification(pattern, userVerification) {
                const patternId = this.hashPattern(pattern);
                
                if (!this.patterns.has(patternId)) {
                    this.patterns.set(patternId, {
                        pattern: pattern,
                        userVerifications: [],
                        confidence: 0.5
                    });
                }
                
                const patternData = this.patterns.get(patternId);
                patternData.userVerifications.push(userVerification);
                
                // Update confidence based on user feedback
                const correctVerifications = patternData.userVerifications.filter(v => v.correct).length;
                const totalVerifications = patternData.userVerifications.length;
                patternData.confidence = correctVerifications / totalVerifications;
                
                this.patternsLearned = this.patterns.size;
                this.updateAccuracy();
                
                console.log(`üìö AI learned from verification: Pattern ${patternId}, Confidence: ${patternData.confidence.toFixed(2)}`);
            }
            
            updateAccuracy() {
                const confidences = Array.from(this.patterns.values()).map(p => p.confidence);
                this.accuracy = confidences.reduce((a, b) => a + b, 0) / confidences.length || 0.85;
            }
            
            hashPattern(pattern) {
                return btoa(JSON.stringify(pattern)).slice(0, 16);
            }
            
            getPrediction(pattern) {
                const patternId = this.hashPattern(pattern);
                const patternData = this.patterns.get(patternId);
                
                if (patternData) {
                    return {
                        confidence: patternData.confidence,
                        prediction: patternData.confidence > 0.5 ? 'positive' : 'negative'
                    };
                }
                
                return {
                    confidence: 0.5,
                    prediction: 'uncertain'
                };
            }
        }
        
        // ===== PATTERN EXTRACTOR =====
        class PatternExtractor {
            extractPatterns(text) {
                const patterns = [];
                
                // Business idea patterns
                const businessKeywords = /\b(business|startup|idea|revenue|market|customer|product|service)\b/gi;
                const businessMatches = text.match(businessKeywords);
                if (businessMatches && businessMatches.length > 2) {
                    patterns.push({
                        type: 'business_idea',
                        content: this.extractSentenceWithKeywords(text, businessKeywords),
                        confidence: 0.7,
                        category: 'business'
                    });
                }
                
                // Workflow patterns
                const workflowKeywords = /\b(step|then|next|after|process|workflow|automation)\b/gi;
                const workflowMatches = text.match(workflowKeywords);
                if (workflowMatches && workflowMatches.length > 1) {
                    patterns.push({
                        type: 'workflow_step',
                        content: this.extractSentenceWithKeywords(text, workflowKeywords),
                        confidence: 0.8,
                        category: 'workflow'
                    });
                }
                
                // Code patterns
                const codeKeywords = /\b(function|class|method|api|endpoint|database)\b/gi;
                const codeMatches = text.match(codeKeywords);
                if (codeMatches && codeMatches.length > 0) {
                    patterns.push({
                        type: 'code_pattern',
                        content: this.extractSentenceWithKeywords(text, codeKeywords),
                        confidence: 0.9,
                        category: 'technical'
                    });
                }
                
                // Documentation patterns
                const docKeywords = /\b(document|explain|guide|tutorial|readme)\b/gi;
                const docMatches = text.match(docKeywords);
                if (docMatches && docMatches.length > 0) {
                    patterns.push({
                        type: 'documentation',
                        content: this.extractSentenceWithKeywords(text, docKeywords),
                        confidence: 0.6,
                        category: 'documentation'
                    });
                }
                
                return patterns;
            }
            
            extractSentenceWithKeywords(text, keywordRegex) {
                const sentences = text.split(/[.!?]+/);
                const matchingSentences = sentences.filter(sentence => keywordRegex.test(sentence));
                return matchingSentences[0]?.trim() || 'Pattern detected';
            }
        }
        
        // ===== VERIFICATION GAME ENGINE =====
        class VerificationGameEngine {
            constructor() {
                this.currentGame = null;
                this.gameHistory = [];
            }
            
            createPatternVerificationGame(pattern) {
                const game = {
                    id: Date.now(),
                    type: 'pattern_verification',
                    pattern: pattern,
                    question: this.generateQuestion(pattern),
                    correctAnswer: this.generateCorrectAnswer(pattern),
                    startTime: Date.now()
                };
                
                this.currentGame = game;
                return game;
            }
            
            generateQuestion(pattern) {
                const questions = {
                    'business_idea': `Is this a viable business opportunity?\n"${pattern.content}"`,
                    'workflow_step': `Is this a logical workflow step?\n"${pattern.content}"`,
                    'code_pattern': `Is this good coding practice?\n"${pattern.content}"`,
                    'documentation': `Does this need documentation?\n"${pattern.content}"`
                };
                
                return questions[pattern.type] || `Is this pattern correct?\n"${pattern.content}"`;
            }
            
            generateCorrectAnswer(pattern) {
                // AI's best guess based on current learning
                const prediction = agenticPWA.aiModel.getPrediction(pattern);
                return prediction.prediction === 'positive' ? 'yes' : 'no';
            }
            
            processUserAnswer(userAnswer) {
                if (!this.currentGame) return null;
                
                const game = this.currentGame;
                const isCorrect = userAnswer.toLowerCase() === game.correctAnswer.toLowerCase();
                const timeSpent = Date.now() - game.startTime;
                
                // Create verification record
                const verification = {
                    pattern: game.pattern,
                    userAnswer: userAnswer,
                    aiAnswer: game.correctAnswer,
                    correct: isCorrect,
                    timeSpent: timeSpent,
                    timestamp: Date.now()
                };
                
                // Update AI learning
                agenticPWA.aiModel.learnFromVerification(game.pattern, verification);
                
                // Update game history
                this.gameHistory.push(verification);
                
                // Award coins for participation
                agenticPWA.secureWallet.addCoins(isCorrect ? 50 : 25);
                
                // Reset current game
                this.currentGame = null;
                
                return {
                    correct: isCorrect,
                    explanation: this.generateExplanation(verification),
                    coinsEarned: isCorrect ? 50 : 25
                };
            }
            
            generateExplanation(verification) {
                if (verification.correct) {
                    return `‚úÖ Correct! You and the AI agreed. Your verification helps train the system.`;
                } else {
                    return `üìö Thanks for the correction! The AI learned that "${verification.pattern.content}" should be "${verification.userAnswer}". This improves accuracy.`;
                }
            }
            
            createMinesweeper() {
                const grid = [];
                const size = 8;
                const mines = 10;
                
                // Initialize grid
                for (let i = 0; i < size * size; i++) {
                    grid.push({
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        neighborMines: 0
                    });
                }
                
                // Place mines
                let placed = 0;
                while (placed < mines) {
                    const index = Math.floor(Math.random() * grid.length);
                    if (!grid[index].isMine) {
                        grid[index].isMine = true;
                        placed++;
                    }
                }
                
                // Calculate neighbors
                for (let i = 0; i < grid.length; i++) {
                    if (!grid[i].isMine) {
                        grid[i].neighborMines = this.countNeighborMines(i, size, grid);
                    }
                }
                
                return {
                    type: 'minesweeper',
                    grid: grid,
                    size: size,
                    minesRemaining: mines,
                    gameOver: false,
                    won: false
                };
            }
            
            countNeighborMines(index, size, grid) {
                let count = 0;
                const row = Math.floor(index / size);
                const col = index % size;
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                            const neighborIndex = newRow * size + newCol;
                            if (grid[neighborIndex].isMine) count++;
                        }
                    }
                }
                
                return count;
            }
        }
        
        // ===== COMPONENT GENERATOR =====
        class ComponentGenerator {
            constructor() {
                this.componentsGenerated = 0;
                this.componentLibrary = [];
            }
            
            generateFromVerifiedPatterns() {
                const verifiedPatterns = Array.from(agenticPWA.aiModel.patterns.values())
                    .filter(p => p.confidence > 0.7);
                
                const components = [];
                
                for (const patternData of verifiedPatterns) {
                    const pattern = patternData.pattern;
                    
                    if (pattern.category === 'business') {
                        components.push(this.generateBusinessComponent(pattern));
                    } else if (pattern.category === 'workflow') {
                        components.push(this.generateWorkflowComponent(pattern));
                    } else if (pattern.category === 'technical') {
                        components.push(this.generateCodeComponent(pattern));
                    }
                }
                
                this.componentLibrary.push(...components);
                this.componentsGenerated = this.componentLibrary.length;
                
                return components;
            }
            
            generateBusinessComponent(pattern) {
                const componentName = this.sanitizeName(pattern.content);
                
                return {
                    type: 'react_component',
                    name: `${componentName}Business.jsx`,
                    code: `
import React from 'react';

const ${componentName}Business = () => {
    return (
        <div className="business-component">
            <h2>${componentName}</h2>
            <p>Business Pattern: ${pattern.content}</p>
            <div className="confidence">
                Verified with ${Math.round(pattern.confidence * 100)}% confidence
            </div>
        </div>
    );
};

export default ${componentName}Business;`,
                    pattern: pattern,
                    generated: Date.now()
                };
            }
            
            generateWorkflowComponent(pattern) {
                const componentName = this.sanitizeName(pattern.content);
                
                return {
                    type: 'workflow_script',
                    name: `${componentName}Workflow.js`,
                    code: `
// Auto-generated workflow: ${componentName}
// Pattern: ${pattern.content}

class ${componentName}Workflow {
    constructor() {
        this.pattern = ${JSON.stringify(pattern, null, 2)};
        this.steps = this.extractSteps();
    }
    
    extractSteps() {
        // Extract workflow steps from pattern
        return [
            { name: 'Start', action: () => console.log('Workflow started') },
            { name: 'Process', action: () => this.processPattern() },
            { name: 'Complete', action: () => console.log('Workflow completed') }
        ];
    }
    
    async execute() {
        console.log('üîÑ Executing ${componentName} workflow...');
        
        for (const step of this.steps) {
            console.log(\`üìã \${step.name}\`);
            await step.action();
        }
        
        console.log('‚úÖ Workflow completed successfully');
    }
    
    processPattern() {
        console.log('Processing pattern:', this.pattern.content);
    }
}

module.exports = ${componentName}Workflow;`,
                    pattern: pattern,
                    generated: Date.now()
                };
            }
            
            generateCodeComponent(pattern) {
                const componentName = this.sanitizeName(pattern.content);
                
                return {
                    type: 'code_module',
                    name: `${componentName}Module.js`,
                    code: `
// Auto-generated code module: ${componentName}
// Pattern: ${pattern.content}

class ${componentName}Module {
    constructor() {
        this.pattern = '${pattern.content}';
        this.initialized = false;
    }
    
    initialize() {
        console.log('üöÄ Initializing ${componentName}...');
        this.initialized = true;
        return this;
    }
    
    execute(input) {
        if (!this.initialized) {
            throw new Error('Module not initialized');
        }
        
        console.log('‚ö° Executing ${componentName} with input:', input);
        
        // Process based on verified pattern
        return {
            pattern: this.pattern,
            result: 'Processed successfully',
            timestamp: Date.now()
        };
    }
}

module.exports = ${componentName}Module;`,
                    pattern: pattern,
                    generated: Date.now()
                };
            }
            
            sanitizeName(content) {
                return content
                    .replace(/[^a-zA-Z0-9\s]/g, '')
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join('')
                    .slice(0, 20);
            }
        }
        
        // ===== WORKFLOW AUTOMATOR =====
        class WorkflowAutomator {
            constructor() {
                this.workflows = [];
                this.activeWorkflows = new Set();
            }
            
            createWorkflow(name, steps) {
                const workflow = {
                    id: Date.now(),
                    name: name,
                    steps: steps,
                    status: 'ready',
                    created: Date.now()
                };
                
                this.workflows.push(workflow);
                return workflow;
            }
            
            executeWorkflow(workflowId) {
                const workflow = this.workflows.find(w => w.id === workflowId);
                if (!workflow) return false;
                
                this.activeWorkflows.add(workflowId);
                workflow.status = 'running';
                
                console.log(`‚ö° Executing workflow: ${workflow.name}`);
                
                // Simulate workflow execution
                setTimeout(() => {
                    workflow.status = 'completed';
                    this.activeWorkflows.delete(workflowId);
                    console.log(`‚úÖ Workflow completed: ${workflow.name}`);
                    
                    agenticPWA.addTerminalOutput(`‚úÖ Workflow "${workflow.name}" completed`);
                    agenticPWA.showToast(`Workflow "${workflow.name}" completed!`);
                }, Math.random() * 5000 + 2000); // 2-7 seconds
                
                return true;
            }
        }
        
        // ===== SECURE WALLET =====
        class SecureWallet {
            constructor() {
                this.balance = 1000;
                this.inventory = [
                    { id: 1, name: 'Iron Sword', type: 'weapon', rarity: 'common' },
                    { id: 2, name: 'Leather Armor', type: 'armor', rarity: 'common' },
                    { id: 3, name: 'Health Potion', type: 'consumable', rarity: 'common' }
                ];
                this.level = 1;
                this.xp = 0;
            }
            
            addCoins(amount) {
                this.balance += amount;
                this.addXP(Math.floor(amount / 10));
                agenticPWA.updateStats();
            }
            
            addXP(amount) {
                this.xp += amount;
                const newLevel = Math.floor(this.xp / 100) + 1;
                
                if (newLevel > this.level) {
                    this.level = newLevel;
                    agenticPWA.showToast(`Level up! Now level ${this.level}`);
                }
                
                document.getElementById('player-level').textContent = this.level;
                document.getElementById('xp-points').textContent = this.xp;
            }
            
            addItem(item) {
                this.inventory.push({
                    id: Date.now(),
                    ...item
                });
                agenticPWA.updateStats();
            }
        }
        
        // ===== GLOBAL INSTANCE =====
        let agenticPWA;
        
        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            agenticPWA = new SecureAgenticPWA();
            
            // Initial stats update
            setTimeout(() => {
                agenticPWA.updateStats();
            }, 1000);
        });
        
        // ===== UI EVENT HANDLERS =====
        function clippyInteract() {
            const messages = [
                "üìé Hi there! I'm your secure AI assistant. Upload documents and I'll create verification games!",
                "‚ö° I learn from every game you play. The more you verify, the smarter I get!",
                "üîí Everything is encrypted locally - your data never leaves this device.",
                "üéÆ Try uploading a document or starting a verification game!",
                "üèóÔ∏è I can generate components from patterns you verify as correct."
            ];
            
            const message = messages[Math.floor(Math.random() * messages.length)];
            agenticPWA.addClippyMessage(message);
        }
        
        function uploadDocument() {
            document.getElementById('file-input').click();
        }
        
        function processUploadedFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                
                agenticPWA.addTerminalOutput(`üìÑ Processing: ${file.name}`);
                agenticPWA.addClippyMessage(`üìÑ Processing "${file.name}"...`);
                
                // Extract patterns
                const patterns = agenticPWA.patternExtractor.extractPatterns(text);
                
                agenticPWA.addTerminalOutput(`üîç Found ${patterns.length} patterns`);
                agenticPWA.addClippyMessage(`üîç Found ${patterns.length} patterns! Ready for verification games.`);
                
                // Store patterns for games
                window.currentPatterns = patterns;
                
                agenticPWA.showToast(`Processed ${file.name} - ${patterns.length} patterns found`);
            };
            
            reader.readAsText(file);
        }
        
        function startPatternVerification() {
            if (!window.currentPatterns || window.currentPatterns.length === 0) {
                agenticPWA.showToast('Upload a document first to extract patterns!');
                return;
            }
            
            const pattern = window.currentPatterns[Math.floor(Math.random() * window.currentPatterns.length)];
            const game = agenticPWA.gameEngine.createPatternVerificationGame(pattern);
            
            const gameArea = document.getElementById('game-area');
            gameArea.innerHTML = `
                <div style="padding: 10px;">
                    <h4>üéØ Pattern Verification</h4>
                    <div style="margin: 10px 0; padding: 10px; background: rgba(0,255,255,0.1); border-radius: 5px;">
                        ${game.question}
                    </div>
                    <div style="margin: 10px 0;">
                        <button class="btn" onclick="answerVerification('yes')" style="width: 48%; margin-right: 2%;">‚úÖ Yes</button>
                        <button class="btn" onclick="answerVerification('no')" style="width: 48%;">‚ùå No</button>
                    </div>
                </div>
            `;
        }
        
        function answerVerification(answer) {
            const result = agenticPWA.gameEngine.processUserAnswer(answer);
            
            if (result) {
                const gameArea = document.getElementById('game-area');
                gameArea.innerHTML = `
                    <div style="padding: 10px;">
                        <h4>${result.correct ? '‚úÖ Correct!' : 'üìö Learning!'}</h4>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(0,255,255,0.1); border-radius: 5px;">
                            ${result.explanation}
                        </div>
                        <div style="margin: 10px 0;">
                            <div>ü™ô Earned: ${result.coinsEarned} coins</div>
                        </div>
                        <button class="btn" onclick="startPatternVerification()" style="margin-top: 10px;">üéØ Next Pattern</button>
                    </div>
                `;
                
                agenticPWA.updateStats();
                agenticPWA.addTerminalOutput(`üéÆ Pattern verification: ${result.correct ? 'CORRECT' : 'LEARNED'} (+${result.coinsEarned} coins)`);
            }
        }
        
        function startMinesweeper() {
            const game = agenticPWA.gameEngine.createMinesweeper();
            
            let html = `
                <div style="padding: 10px;">
                    <h4>üí£ Crypto Sweeper</h4>
                    <div style="margin: 10px 0;">Mines: ${game.minesRemaining}</div>
                    <div style="display: grid; grid-template-columns: repeat(${game.size}, 1fr); gap: 1px; max-width: 200px;">
            `;
            
            for (let i = 0; i < game.grid.length; i++) {
                const cell = game.grid[i];
                html += `
                    <button onclick="revealCell(${i})" 
                            style="width: 24px; height: 24px; font-size: 10px; background: #333; color: #0ff; border: 1px solid #666;">
                        ${cell.isRevealed ? (cell.isMine ? 'üí£' : cell.neighborMines || '') : ''}
                    </button>
                `;
            }
            
            html += `</div></div>`;
            
            document.getElementById('game-area').innerHTML = html;
            window.currentMinesweeperGame = game;
        }
        
        function revealCell(index) {
            const game = window.currentMinesweeperGame;
            if (!game || game.gameOver) return;
            
            const cell = game.grid[index];
            if (cell.isRevealed) return;
            
            cell.isRevealed = true;
            
            if (cell.isMine) {
                game.gameOver = true;
                agenticPWA.showToast('üí£ Game Over! Try again.');
                agenticPWA.secureWallet.addCoins(10); // Consolation prize
            } else {
                const unrevealed = game.grid.filter(c => !c.isRevealed && !c.isMine).length;
                if (unrevealed === 0) {
                    game.won = true;
                    game.gameOver = true;
                    agenticPWA.showToast('üéâ You won! 100 coins earned!');
                    agenticPWA.secureWallet.addCoins(100);
                }
            }
            
            // Refresh display
            startMinesweeper();
        }
        
        function startFlashcards() {
            const gameArea = document.getElementById('game-area');
            gameArea.innerHTML = `
                <div style="padding: 10px;">
                    <h4>üé¥ Study Flashcards</h4>
                    <div style="margin: 10px 0;">Upload documents to create custom flashcards!</div>
                    <button class="btn" onclick="uploadDocument()">üìÑ Upload Study Material</button>
                </div>
            `;
        }
        
        function startQuiz() {
            const gameArea = document.getElementById('game-area');
            gameArea.innerHTML = `
                <div style="padding: 10px;">
                    <h4>‚ùì Pattern Quiz</h4>
                    <div style="margin: 10px 0;">Test your pattern recognition skills!</div>
                    <button class="btn" onclick="startPatternVerification()">üéØ Start Quiz</button>
                </div>
            `;
        }
        
        function handleTerminalInput(event) {
            if (event.key === 'Enter') {
                const input = event.target;
                const command = input.value.trim();
                input.value = '';
                
                agenticPWA.addTerminalOutput(`> ${command}`);
                
                // Process commands
                if (command === 'help') {
                    agenticPWA.addTerminalOutput('Commands: help, status, patterns, generate, encrypt, decrypt, clear');
                } else if (command === 'status') {
                    agenticPWA.addTerminalOutput(`AI Patterns: ${agenticPWA.aiModel.patternsLearned}`);
                    agenticPWA.addTerminalOutput(`Accuracy: ${Math.round(agenticPWA.aiModel.accuracy * 100)}%`);
                    agenticPWA.addTerminalOutput(`Components: ${agenticPWA.componentGenerator.componentsGenerated}`);
                } else if (command === 'patterns') {
                    if (window.currentPatterns) {
                        agenticPWA.addTerminalOutput(`Found ${window.currentPatterns.length} patterns in uploaded document`);
                        window.currentPatterns.forEach((p, i) => {
                            agenticPWA.addTerminalOutput(`${i + 1}. ${p.type}: ${p.content.slice(0, 50)}...`);
                        });
                    } else {
                        agenticPWA.addTerminalOutput('No patterns loaded. Upload a document first.');
                    }
                } else if (command === 'generate') {
                    const components = agenticPWA.componentGenerator.generateFromVerifiedPatterns();
                    agenticPWA.addTerminalOutput(`Generated ${components.length} components from verified patterns`);
                } else if (command === 'clear') {
                    document.getElementById('terminal').innerHTML = '';
                } else if (command.startsWith('encrypt ')) {
                    const text = command.slice(8);
                    agenticPWA.addTerminalOutput(`Encrypted: ${btoa(text)}`);
                } else if (command.startsWith('decrypt ')) {
                    const encrypted = command.slice(8);
                    try {
                        agenticPWA.addTerminalOutput(`Decrypted: ${atob(encrypted)}`);
                    } catch {
                        agenticPWA.addTerminalOutput('Invalid encrypted text');
                    }
                } else {
                    agenticPWA.addTerminalOutput(`Unknown command: ${command}`);
                }
            }
        }
        
        function exportData() {
            const data = {
                patterns: Array.from(agenticPWA.aiModel.patterns.entries()),
                components: agenticPWA.componentGenerator.componentLibrary,
                gameHistory: agenticPWA.gameEngine.gameHistory,
                walletData: {
                    balance: agenticPWA.secureWallet.balance,
                    inventory: agenticPWA.secureWallet.inventory,
                    level: agenticPWA.secureWallet.level,
                    xp: agenticPWA.secureWallet.xp
                },
                exported: Date.now()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `agentic-os-data-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            agenticPWA.showToast('üîê Encrypted data capsule exported!');
        }
        
        function trainAI() {
            agenticPWA.addTerminalOutput('üß† Training AI model...');
            agenticPWA.showToast('AI training started');
            
            // Simulate training
            setTimeout(() => {
                agenticPWA.aiModel.accuracy = Math.min(0.95, agenticPWA.aiModel.accuracy + 0.02);
                agenticPWA.updateStats();
                agenticPWA.addTerminalOutput('‚úÖ AI training completed');
                agenticPWA.showToast('AI training completed!');
            }, 3000);
        }
        
        function createWorkflow() {
            const name = prompt('Enter workflow name:');
            if (!name) return;
            
            const workflow = agenticPWA.workflowAutomator.createWorkflow(name, [
                { name: 'Initialize', duration: 1000 },
                { name: 'Process', duration: 2000 },
                { name: 'Complete', duration: 1000 }
            ]);
            
            agenticPWA.addTerminalOutput(`‚ö° Created workflow: ${name}`);
            agenticPWA.showToast(`Workflow "${name}" created!`);
        }
        
        function executeAutomation() {
            if (agenticPWA.workflowAutomator.workflows.length === 0) {
                agenticPWA.showToast('Create a workflow first!');
                return;
            }
            
            const workflow = agenticPWA.workflowAutomator.workflows[0];
            agenticPWA.workflowAutomator.executeWorkflow(workflow.id);
        }
        
        function openInventory() {
            const inventory = agenticPWA.secureWallet.inventory;
            const gameArea = document.getElementById('game-area');
            
            let html = `
                <div style="padding: 10px;">
                    <h4>üéí Inventory</h4>
                    <div style="margin: 10px 0;">
            `;
            
            inventory.forEach(item => {
                html += `
                    <div style="margin: 5px 0; padding: 5px; background: rgba(0,255,255,0.1); border-radius: 3px;">
                        <strong>${item.name}</strong> (${item.type})
                        <div style="font-size: 10px; color: #999;">Rarity: ${item.rarity}</div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <button class="btn" onclick="startMinesweeper()">üéÆ Back to Games</button>
                </div>
            `;
            
            gameArea.innerHTML = html;
        }
        
        function tradeItems() {
            agenticPWA.showToast('Trading system coming soon!');
        }
        
        // ===== PWA INSTALLATION =====
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button
            const installBtn = document.createElement('button');
            installBtn.textContent = 'üì± Install App';
            installBtn.className = 'btn';
            installBtn.onclick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to install prompt: ${outcome}`);
                    deferredPrompt = null;
                    installBtn.remove();
                }
            };
            
            document.getElementById('clippy-panel').appendChild(installBtn);
        });
    </script>
</body>
</html>