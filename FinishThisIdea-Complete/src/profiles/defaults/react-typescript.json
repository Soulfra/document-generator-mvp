{
  "id": "react-typescript",
  "name": "React TypeScript",
  "description": "React with TypeScript, hooks, and modern component patterns",
  "language": "typescript",
  "framework": "react",
  "version": "1.0.0",
  "style": {
    "indentation": "spaces",
    "indentSize": 2,
    "lineEnding": "lf",
    "quoteStyle": "single",
    "semicolons": true,
    "trailingComma": "all",
    "maxLineLength": 100,
    "bracketSpacing": true
  },
  "rules": {
    "naming": {
      "functions": "camelCase",
      "variables": "camelCase",
      "constants": "UPPER_SNAKE",
      "classes": "PascalCase",
      "files": "PascalCase"
    },
    "imports": {
      "orderBy": "grouped",
      "groups": ["react", "external", "internal", "parent", "sibling", "index", "styles"],
      "removeUnused": true,
      "combineImports": true
    },
    "comments": {
      "style": "jsdoc",
      "removeAll": false,
      "preserveTodos": true
    },
    "whitespace": {
      "trimTrailing": true,
      "insertFinalNewline": true,
      "collapseMultipleEmptyLines": true
    }
  },
  "aiContext": {
    "systemPrompt": "You are a React TypeScript expert. Focus on functional components, hooks, proper typing, and performance optimization.",
    "priorities": [
      "Use functional components with hooks",
      "Properly type all props and state",
      "Memoize expensive computations",
      "Handle loading and error states",
      "Follow React naming conventions"
    ],
    "avoidPatterns": [
      "Class components (unless necessary)",
      "Direct DOM manipulation",
      "Inline styles in loops",
      "Anonymous functions in JSX props",
      "Missing key props in lists"
    ],
    "preferredPatterns": [
      "Custom hooks for logic reuse",
      "React.memo for pure components",
      "useCallback and useMemo appropriately",
      "Proper error boundaries",
      "Semantic HTML elements"
    ],
    "codeExamples": [
      {
        "description": "Functional component with proper typing",
        "before": "function Button({onClick, children}) {\n  return <button onClick={onClick}>{children}</button>\n}",
        "after": "interface ButtonProps {\n  onClick: () => void;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nexport const Button: React.FC<ButtonProps> = ({ onClick, children, disabled = false }) => {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className=\"btn\"\n    >\n      {children}\n    </button>\n  );\n};"
      },
      {
        "description": "Custom hook pattern",
        "before": "const [data, setData] = useState(null);\nconst [loading, setLoading] = useState(false);\n\nuseEffect(() => {\n  setLoading(true);\n  fetchData().then(setData).finally(() => setLoading(false));\n}, []);",
        "after": "const useData = <T,>(fetchFn: () => Promise<T>) => {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    let cancelled = false;\n    \n    const loadData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const result = await fetchFn();\n        if (!cancelled) {\n          setData(result);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err instanceof Error ? err : new Error('Unknown error'));\n        }\n      } finally {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      }\n    };\n    \n    loadData();\n    \n    return () => {\n      cancelled = true;\n    };\n  }, [fetchFn]);\n\n  return { data, loading, error };\n};"
      }
    ]
  },
  "isDefault": true
}