<!DOCTYPE html>
<html>
<head>
    <title>üíé Voxel Laser Economy Arena - Token-Powered Vector Field</title>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff41;
            overflow: hidden;
        }

        #voxel-arena {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .overlay-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .economy-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff41;
            padding: 20px;
            border-radius: 10px;
            pointer-events: all;
            box-shadow: 0 0 20px rgba(0,255,65,0.3);
        }

        .economy-title {
            font-size: 1.2em;
            color: #ffff00;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffff00;
        }

        .token-display {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .token-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            animation: tokenPulse 2s infinite;
        }

        @keyframes tokenPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px #ffd700; }
            50% { transform: scale(1.1); box-shadow: 0 0 20px #ffd700; }
        }

        .token-count {
            font-size: 1.5em;
            color: #ffd700;
            font-weight: bold;
        }

        .laser-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #ff6600;
            padding: 20px;
            border-radius: 10px;
            pointer-events: all;
        }

        .control-btn {
            background: linear-gradient(45deg, #ff6600, #ff8800);
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            border-radius: 20px;
            transition: all 0.3s;
            pointer-events: all;
        }

        .control-btn:hover {
            background: linear-gradient(45deg, #ff8800, #ffaa00);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #00ff41, #00cc33);
            box-shadow: 0 0 20px #00ff41;
        }

        .voxel-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #ffff00;
            padding: 15px;
            border-radius: 10px;
            pointer-events: all;
            max-width: 300px;
        }

        .ai-agents-3d {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff41;
            padding: 15px;
            border-radius: 10px;
            pointer-events: all;
        }

        .agent-voxel {
            margin: 5px 0;
            padding: 5px;
            background: rgba(0,255,65,0.1);
            border-left: 3px solid #00ff41;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .laser-cost {
            color: #ff6600;
            font-weight: bold;
        }

        .pattern-match {
            color: #ffff00;
            animation: patternGlow 1s infinite alternate;
        }

        @keyframes patternGlow {
            from { text-shadow: 0 0 5px #ffff00; }
            to { text-shadow: 0 0 15px #ffff00, 0 0 25px #ffff00; }
        }

        .dungeon-depth-3d {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: rgba(255,255,255,0.1);
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255,255,255,0.2);
        }

        .laser-beam-info {
            position: absolute;
            padding: 10px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ff6600;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="voxel-arena"></canvas>
    
    <div class="overlay-ui">
        <!-- Background dungeon depth indicator -->
        <div class="dungeon-depth-3d">LEVEL 47</div>
        
        <!-- Token Economy Panel -->
        <div class="economy-panel">
            <div class="economy-title">üíé Voxel Token Economy</div>
            <div class="token-display">
                <div class="token-icon">‚ÇÆ</div>
                <div class="token-count" id="token-count">10,000</div>
            </div>
            <div style="font-size: 0.8em; margin: 10px 0;">
                <div>üí® Laser Cost: <span class="laser-cost">1 ‚ÇÆ/voxel/sec</span></div>
                <div>üéØ Pattern Hit: <span style="color: #00ff41;">+10 ‚ÇÆ</span></div>
                <div>ü•ö Easter Egg: <span style="color: #ffd700;">+100 ‚ÇÆ</span></div>
                <div>üîë Key Phrase: <span style="color: #ff00ff;">+500 ‚ÇÆ</span></div>
            </div>
            <div style="margin-top: 15px; font-size: 0.8em;">
                <div>‚ö° Active Lasers: <span id="active-lasers">0</span></div>
                <div>üí∏ Burn Rate: <span id="burn-rate">0</span> ‚ÇÆ/sec</div>
                <div>üìà Earn Rate: <span id="earn-rate">0</span> ‚ÇÆ/sec</div>
            </div>
        </div>

        <!-- AI Agents in 3D Space -->
        <div class="ai-agents-3d">
            <div style="color: #ffff00; margin-bottom: 10px;">ü§ñ AI Agents (Voxelized)</div>
            <div class="agent-voxel" data-agent="reasoning">
                üß† ReasoningBot [X:12 Y:8 Z:15]
                <div style="font-size: 0.8em; color: #888;">Firing: Pattern Analysis Lasers</div>
            </div>
            <div class="agent-voxel" data-agent="pattern">
                üîç PatternHunter [X:45 Y:12 Z:20]
                <div style="font-size: 0.8em; color: #888;">Firing: Easter Egg Scan Beams</div>
            </div>
            <div class="agent-voxel" data-agent="security">
                üõ°Ô∏è SecurityGuard [X:30 Y:25 Z:10]
                <div style="font-size: 0.8em; color: #888;">Firing: Threat Detection Rays</div>
            </div>
            <div class="agent-voxel" data-agent="lore">
                üìö LoreMaster [X:8 Y:30 Z:25]
                <div style="font-size: 0.8em; color: #888;">Firing: Cross-Reference Beams</div>
            </div>
        </div>

        <!-- Laser Controls -->
        <div class="laser-controls">
            <div style="color: #ff6600; margin-bottom: 10px;">‚ö° Laser Firing Modes</div>
            <button class="control-btn active" onclick="setLaserMode('pattern')">üéØ Pattern Scan</button>
            <button class="control-btn" onclick="setLaserMode('easter')">ü•ö Easter Hunt</button>
            <button class="control-btn" onclick="setLaserMode('phrase')">üîë Phrase Detect</button>
            <button class="control-btn" onclick="setLaserMode('mirror')">ü™û Mirror Mode</button>
            <button class="control-btn" onclick="toggleAutoFire()">üî• Auto-Fire: <span id="auto-fire">ON</span></button>
        </div>

        <!-- Voxel Information -->
        <div class="voxel-info">
            <div style="color: #ffff00; margin-bottom: 10px;">üìä Voxel Field Analysis</div>
            <div style="font-size: 0.8em;">
                <div>Grid: <span id="grid-size">64x64x32</span> voxels</div>
                <div>Active Voxels: <span id="active-voxels">2,048</span></div>
                <div>Pattern Density: <span class="pattern-match">47%</span></div>
                <div>Easter Eggs: <span id="easter-density">12</span> detected</div>
                <div>Key Phrases: <span id="phrase-density">7</span> locked</div>
            </div>
            <div style="margin-top: 10px; font-size: 0.8em;">
                <div class="pattern-match">üéØ HOT ZONE: [32,16,20]</div>
                <div style="color: #ff6600;">‚ö†Ô∏è High token burn area</div>
            </div>
        </div>

        <!-- Laser beam tooltip -->
        <div class="laser-beam-info" id="laser-tooltip"></div>
    </div>

    <script>
        // Three.js Scene Setup
        let scene, camera, renderer;
        let voxelGrid = [];
        let lasers = [];
        let particles = [];
        let tokenCount = 10000;
        let laserMode = 'pattern';
        let autoFire = true;
        let activeLasers = 0;
        let burnRate = 0;
        let earnRate = 0;

        // Voxel Grid Configuration
        const GRID_SIZE = { x: 64, y: 64, z: 32 };
        const VOXEL_SIZE = 0.5;
        const VOXEL_SPACING = 0.1;

        // Token Economics
        const LASER_COST = 1; // tokens per voxel per second
        const PATTERN_REWARD = 10;
        const EASTER_REWARD = 100;
        const PHRASE_REWARD = 500;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 100);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('voxel-arena'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create voxel grid
            createVoxelGrid();
            
            // Create AI agents as voxel entities
            createAIAgentVoxels();
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(40, 40, 0x00ff41, 0x003300);
            scene.add(gridHelper);
            
            // Mouse controls
            setupMouseControls();
            
            // Start animation
            animate();
            
            // Start token economy
            startTokenEconomy();
            
            // Start laser firing
            startLaserSystem();
        }

        function createVoxelGrid() {
            const voxelGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
            
            for (let x = 0; x < GRID_SIZE.x; x++) {
                voxelGrid[x] = [];
                for (let y = 0; y < GRID_SIZE.y; y++) {
                    voxelGrid[x][y] = [];
                    for (let z = 0; z < GRID_SIZE.z; z++) {
                        // Only create voxels at certain positions for performance
                        if (Math.random() > 0.85) {
                            const material = new THREE.MeshPhongMaterial({
                                color: getVoxelColor(x, y, z),
                                emissive: getVoxelColor(x, y, z),
                                emissiveIntensity: 0.2,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const voxel = new THREE.Mesh(voxelGeometry, material);
                            voxel.position.set(
                                (x - GRID_SIZE.x / 2) * (VOXEL_SIZE + VOXEL_SPACING),
                                (y - GRID_SIZE.y / 2) * (VOXEL_SIZE + VOXEL_SPACING),
                                (z - GRID_SIZE.z / 2) * (VOXEL_SIZE + VOXEL_SPACING)
                            );
                            
                            voxel.userData = {
                                gridPos: { x, y, z },
                                type: getVoxelType(x, y, z),
                                value: Math.random() * 100,
                                active: false
                            };
                            
                            scene.add(voxel);
                            voxelGrid[x][y][z] = voxel;
                        }
                    }
                }
            }
        }

        function getVoxelColor(x, y, z) {
            // Color based on position and type
            const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * Math.sin(z * 0.1);
            
            if (noise > 0.5) return 0xffff00; // Pattern zone
            if (noise > 0.2) return 0x00ff41; // Normal zone
            if (noise > -0.2) return 0xff6600; // High cost zone
            return 0xff00ff; // Key phrase zone
        }

        function getVoxelType(x, y, z) {
            const types = ['pattern', 'easter', 'phrase', 'normal'];
            const index = Math.floor(Math.random() * types.length);
            return types[index];
        }

        function createAIAgentVoxels() {
            const agentData = [
                { name: 'ReasoningBot', pos: [12, 8, 15], color: 0x00ff41, icon: 'üß†' },
                { name: 'PatternHunter', pos: [45, 12, 20], color: 0xffff00, icon: 'üîç' },
                { name: 'SecurityGuard', pos: [30, 25, 10], color: 0xff6600, icon: 'üõ°Ô∏è' },
                { name: 'LoreMaster', pos: [8, 30, 25], color: 0xff00ff, icon: 'üìö' }
            ];
            
            agentData.forEach(agent => {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshPhongMaterial({
                    color: agent.color,
                    emissive: agent.color,
                    emissiveIntensity: 0.5
                });
                
                const agentMesh = new THREE.Mesh(geometry, material);
                agentMesh.position.set(
                    (agent.pos[0] - GRID_SIZE.x / 2) * (VOXEL_SIZE + VOXEL_SPACING),
                    (agent.pos[1] - GRID_SIZE.y / 2) * (VOXEL_SIZE + VOXEL_SPACING),
                    (agent.pos[2] - GRID_SIZE.z / 2) * (VOXEL_SIZE + VOXEL_SPACING)
                );
                
                agentMesh.userData = {
                    type: 'ai_agent',
                    name: agent.name,
                    firingRate: 0.5 + Math.random() * 0.5
                };
                
                scene.add(agentMesh);
                
                // Start agent laser firing
                if (autoFire) {
                    setInterval(() => fireAgentLaser(agentMesh, agent.color), 1000 / agentMesh.userData.firingRate);
                }
            });
        }

        function fireAgentLaser(agent, color) {
            if (!autoFire || tokenCount <= 0) return;
            
            // Random target voxel
            const targetX = Math.floor(Math.random() * GRID_SIZE.x);
            const targetY = Math.floor(Math.random() * GRID_SIZE.y);
            const targetZ = Math.floor(Math.random() * GRID_SIZE.z);
            
            const targetVoxel = voxelGrid[targetX]?.[targetY]?.[targetZ];
            if (!targetVoxel) return;
            
            // Create laser beam
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.8
            });
            
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // Position and orient laser
            const start = agent.position;
            const end = targetVoxel.position;
            const distance = start.distanceTo(end);
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            
            laser.position.copy(start).add(direction.multiplyScalar(distance / 2));
            laser.lookAt(end);
            laser.rotateX(Math.PI / 2);
            laser.scale.y = distance;
            
            laser.userData = {
                start: start.clone(),
                end: end.clone(),
                targetVoxel: targetVoxel,
                lifeTime: 2,
                cost: LASER_COST
            };
            
            scene.add(laser);
            lasers.push(laser);
            
            // Deduct tokens
            tokenCount -= LASER_COST;
            activeLasers++;
            
            // Check for hits
            checkLaserHit(targetVoxel);
            
            // Activate voxel
            if (targetVoxel.userData) {
                targetVoxel.userData.active = true;
                targetVoxel.material.emissiveIntensity = 1;
            }
        }

        function checkLaserHit(voxel) {
            if (!voxel.userData) return;
            
            const type = voxel.userData.type;
            let reward = 0;
            
            switch (type) {
                case 'pattern':
                    reward = PATTERN_REWARD;
                    showHitEffect(voxel.position, 0xffff00, 'PATTERN +10‚ÇÆ');
                    break;
                case 'easter':
                    reward = EASTER_REWARD;
                    showHitEffect(voxel.position, 0xffd700, 'EASTER EGG +100‚ÇÆ');
                    break;
                case 'phrase':
                    reward = PHRASE_REWARD;
                    showHitEffect(voxel.position, 0xff00ff, 'KEY PHRASE +500‚ÇÆ');
                    checkLevelJump();
                    break;
            }
            
            if (reward > 0) {
                tokenCount += reward;
                earnRate += reward;
            }
        }

        function showHitEffect(position, color, text) {
            // Create particle effect
            const particleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1
            });
            
            for (let i = 0; i < 10; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.2
                    ),
                    lifeTime: 1
                };
                scene.add(particle);
                particles.push(particle);
            }
        }

        function checkLevelJump() {
            // Check if we have enough key phrases for level jump
            const phraseCount = parseInt(document.getElementById('phrase-density').textContent);
            if (phraseCount >= 10) {
                document.querySelector('.dungeon-depth-3d').textContent = `LEVEL ${47 + Math.floor(phraseCount / 10) * 5}`;
                console.log('üöÄ LEVEL JUMP TRIGGERED!');
            }
        }

        function startTokenEconomy() {
            setInterval(() => {
                // Update token display
                document.getElementById('token-count').textContent = Math.floor(tokenCount).toLocaleString();
                document.getElementById('active-lasers').textContent = activeLasers;
                document.getElementById('burn-rate').textContent = burnRate;
                document.getElementById('earn-rate').textContent = earnRate;
                
                // Update voxel stats
                let activeVoxelCount = 0;
                for (let x = 0; x < GRID_SIZE.x; x++) {
                    for (let y = 0; y < GRID_SIZE.y; y++) {
                        for (let z = 0; z < GRID_SIZE.z; z++) {
                            const voxel = voxelGrid[x]?.[y]?.[z];
                            if (voxel && voxel.userData && voxel.userData.active) {
                                activeVoxelCount++;
                            }
                        }
                    }
                }
                document.getElementById('active-voxels').textContent = activeVoxelCount.toLocaleString();
                
                // Reset rates
                burnRate = activeLasers * LASER_COST;
                earnRate = 0;
                activeLasers = 0;
            }, 1000);
        }

        function startLaserSystem() {
            // Continuous laser updates
            setInterval(() => {
                // Update lasers
                lasers = lasers.filter(laser => {
                    laser.userData.lifeTime -= 0.016;
                    
                    if (laser.userData.lifeTime <= 0) {
                        scene.remove(laser);
                        
                        // Deactivate target voxel
                        if (laser.userData.targetVoxel && laser.userData.targetVoxel.userData) {
                            laser.userData.targetVoxel.userData.active = false;
                            laser.userData.targetVoxel.material.emissiveIntensity = 0.2;
                        }
                        
                        return false;
                    }
                    
                    // Fade out
                    laser.material.opacity = laser.userData.lifeTime / 2;
                    return true;
                });
                
                // Update particles
                particles = particles.filter(particle => {
                    particle.userData.lifeTime -= 0.016;
                    
                    if (particle.userData.lifeTime <= 0) {
                        scene.remove(particle);
                        return false;
                    }
                    
                    // Move particle
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.y -= 0.01; // Gravity
                    particle.material.opacity = particle.userData.lifeTime;
                    
                    return true;
                });
            }, 16);
        }

        function setupMouseControls() {
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Smooth camera rotation
            setInterval(() => {
                targetX += (mouseX - targetX) * 0.05;
                targetY += (mouseY - targetY) * 0.05;
                
                camera.position.x = Math.cos(targetX * Math.PI) * 50;
                camera.position.z = Math.sin(targetX * Math.PI) * 50;
                camera.position.y = 30 + targetY * 20;
                camera.lookAt(0, 0, 0);
            }, 16);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate voxel grid slowly
            scene.rotation.y += 0.001;
            
            // Update voxel glow
            const time = Date.now() * 0.001;
            for (let x = 0; x < GRID_SIZE.x; x++) {
                for (let y = 0; y < GRID_SIZE.y; y++) {
                    for (let z = 0; z < GRID_SIZE.z; z++) {
                        const voxel = voxelGrid[x]?.[y]?.[z];
                        if (voxel && voxel.userData && voxel.userData.active) {
                            voxel.material.emissiveIntensity = 0.5 + Math.sin(time * 5) * 0.5;
                        }
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // Control functions
        function setLaserMode(mode) {
            laserMode = mode;
            document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function toggleAutoFire() {
            autoFire = !autoFire;
            document.getElementById('auto-fire').textContent = autoFire ? 'ON' : 'OFF';
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>