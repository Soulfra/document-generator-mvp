/**
 * ðŸŽ¬ Content-to-Movie Generator
 * Transforms existing content (HTML, text, stories) into interactive canvas-based movies
 * Features scene extraction, visual generation, character integration, and SEO optimization
 */

const { EventEmitter } = require('events');
const { JSDOM } = require('jsdom');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class ContentToMovieGenerator extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.options = {
            outputDir: options.outputDir || './generated-movies',
            assetsDir: options.assetsDir || './movie-assets',
            enableImageGeneration: options.enableImageGeneration !== false,
            enableSEOOptimization: options.enableSEOOptimization !== false,
            watermarkStyle: options.watermarkStyle || 'kodak',
            defaultTheme: options.defaultTheme || 'pirates',
            ...options
        };
        
        // Story parsing patterns for different content types
        this.storyPatterns = {
            chapter: {
                sceneIndicators: [
                    'Chapter', 'Part', 'Section', 'The Data Symphony', 'The Sacred Convergence',
                    'The Technical Revelation', 'Cal\\'s Discovery', 'The Mystical Awakening'
                ],
                characterIndicators: ['Cal', 'Captain Cal', 'Agent Zero', 'CEO Claude', 'Wizard Claude'],
                emotionIndicators: {
                    mysterious: ['mysterious', 'enigmatic', 'hidden', 'secret', 'shadow'],
                    technical: ['data', 'algorithm', 'system', 'code', 'API', 'dashboard'],
                    adventurous: ['journey', 'discovery', 'exploration', 'quest', 'convergence'],
                    dramatic: ['revelation', 'awakening', 'transformation', 'realization']
                }
            },
            tutorial: {
                sceneIndicators: ['Step', 'Getting Started', 'Setup', 'Configuration', 'Testing'],
                actionIndicators: ['click', 'navigate', 'create', 'generate', 'save', 'copy'],
                warningIndicators: ['important', 'warning', 'note', 'tip', 'security']
            },
            conversation: {
                sceneIndicators: ['Human:', 'AI:', 'Assistant:', 'User:', 'Claude:'],
                emotionIndicators: {
                    helpful: ['help', 'assist', 'guide', 'support'],
                    analytical: ['analyze', 'examine', 'evaluate', 'assess'],
                    creative: ['create', 'design', 'build', 'generate']
                }
            }
        };
        
        // Visual style templates for different content domains
        this.visualStyles = {
            crypto: {
                colorPalette: ['#FFD700', '#8B4513', '#DAA520', '#FF6347', '#1E3A8A'],
                backgroundStyle: 'pirate-ship-deck',
                characterStyle: 'pirate',
                visualElements: ['treasure-chest', 'coins', 'ship-wheel', 'map'],
                watermarkStyle: 'treasure-map'
            },
            webdev: {
                colorPalette: ['#61DAFB', '#282C34', '#F7DF1E', '#E34F26', '#1572B6'],
                backgroundStyle: 'modern-workspace',
                characterStyle: 'developer',
                visualElements: ['code-editor', 'browser', 'terminal', 'laptop'],
                watermarkStyle: 'tech-badge'
            },
            cyberpunk: {
                colorPalette: ['#00FFFF', '#FF00FF', '#00FF00', '#0A0A0A', '#FFFFFF'],
                backgroundStyle: 'neon-city',
                characterStyle: 'cyber-agent',
                visualElements: ['hologram', 'neon-grid', 'data-stream', 'terminal'],
                watermarkStyle: 'glitch-brand'
            },
            business: {
                colorPalette: ['#1E3A8A', '#374151', '#F59E0B', '#F9FAFB', '#111827'],
                backgroundStyle: 'boardroom',
                characterStyle: 'executive',
                visualElements: ['chart', 'presentation', 'skyline', 'meeting-table'],
                watermarkStyle: 'corporate-seal'
            },
            fantasy: {
                colorPalette: ['#7C3AED', '#059669', '#F59E0B', '#1F2937', '#F3F4F6'],
                backgroundStyle: 'magical-library',
                characterStyle: 'wizard',
                visualElements: ['spell-book', 'crystal-orb', 'magical-runes', 'enchanted-forest'],
                watermarkStyle: 'mystical-seal'
            }
        };
        
        // Scene generation templates
        this.sceneTemplates = {
            introduction: {
                duration: 5000, // 5 seconds
                transitions: ['fade-in', 'slide-right'],
                visualElements: ['title-card', 'character-introduction'],
                audioElements: ['intro-music', 'character-voice']
            },
            narrative: {
                duration: 8000, // 8 seconds
                transitions: ['cross-fade', 'zoom-in'],
                visualElements: ['background-scene', 'character', 'text-overlay'],
                audioElements: ['background-music', 'narration']
            },
            technical: {
                duration: 10000, // 10 seconds
                transitions: ['wipe-left', 'matrix-transition'],
                visualElements: ['code-snippet', 'diagram', 'highlight-box'],
                audioElements: ['tech-ambience', 'explanation-voice']
            },
            climax: {
                duration: 6000, // 6 seconds
                transitions: ['dramatic-zoom', 'lightning-flash'],
                visualElements: ['dramatic-background', 'character-closeup', 'effect-overlay'],
                audioElements: ['dramatic-music', 'character-exclamation']
            },
            conclusion: {
                duration: 4000, // 4 seconds
                transitions: ['fade-out', 'spiral-out'],
                visualElements: ['summary-card', 'call-to-action'],
                audioElements: ['outro-music', 'final-narration']
            }
        };
        
        // Character personality profiles
        this.characterProfiles = {
            'captain-cal': {
                personality: 'wise-mentor-pirate',
                voiceStyle: 'deep-gravelly',
                catchphrases: [
                    'Ahoy there, matey!',
                    'Chart your course to knowledge!',
                    'Batten down the hatches, learning ahead!',
                    'By my beard, that\\'s fine work!'
                ],
                expressions: ['confident-smile', 'thoughtful-nod', 'excited-gesture', 'wise-gaze'],
                backgroundElements: ['ship-deck', 'treasure-map', 'compass', 'telescope']
            },
            'agent-zero': {
                personality: 'digital-mentor-cyberpunk',
                voiceStyle: 'electronic-processed',
                catchphrases: [
                    'Initializing knowledge transfer...',
                    'Your neural pathways are expanding',
                    'Data packet received, processing...',
                    'System optimization complete'
                ],
                expressions: ['digital-smile', 'scanning-eyes', 'processing-gesture', 'confident-stance'],
                backgroundElements: ['neon-grid', 'data-streams', 'holographic-display', 'cyber-city']
            },
            'ceo-claude': {
                personality: 'executive-mentor-corporate',
                voiceStyle: 'professional-confident',
                catchphrases: [
                    'Let\\'s strategize your learning objectives',
                    'Time to scale your knowledge portfolio',
                    'Your ROI on learning is exceptional',
                    'Ready for your next promotion in skills?'
                ],
                expressions: ['professional-smile', 'strategic-thinking', 'presenting-gesture', 'approving-nod'],
                backgroundElements: ['boardroom', 'city-skyline', 'presentation-screen', 'executive-desk']
            }
        };
        
        this.init();
    }
    
    async init() {
        // Ensure output directories exist
        await this.ensureDirectories();
        
        console.log('ðŸŽ¬ Content-to-Movie Generator initialized');
        console.log(`ðŸ“ Output directory: ${this.options.outputDir}`);
        console.log(`ðŸŽ¨ Available themes: ${Object.keys(this.visualStyles).join(', ')}`);
    }
    
    async ensureDirectories() {
        const dirs = [
            this.options.outputDir,
            this.options.assetsDir,
            path.join(this.options.outputDir, 'scenes'),
            path.join(this.options.outputDir, 'movies'),
            path.join(this.options.assetsDir, 'images'),
            path.join(this.options.assetsDir, 'audio'),
            path.join(this.options.assetsDir, 'watermarks')
        ];
        
        for (const dir of dirs) {
            try {
                await fs.mkdir(dir, { recursive: true });
            } catch (error) {
                console.error(`Failed to create directory ${dir}:`, error);
            }
        }
    }
    
    /**
     * Main method: Convert content to interactive movie
     */
    async generateMovie(input, options = {}) {\n        const movieId = this.generateMovieId();\n        \n        console.log(`ðŸŽ¬ Starting movie generation: ${movieId}`);\n        \n        // Parse input content\n        const parsedContent = await this.parseContent(input, options);\n        \n        // Detect content domain and style\n        const contentDomain = this.detectContentDomain(parsedContent);\n        const visualStyle = this.visualStyles[contentDomain] || this.visualStyles[this.options.defaultTheme];\n        \n        // Extract scenes from content\n        const scenes = await this.extractScenes(parsedContent, contentDomain);\n        \n        // Generate visuals for each scene\n        const enhancedScenes = await this.enhanceScenes(scenes, visualStyle, options);\n        \n        // Create interactive movie structure\n        const movie = await this.createInteractiveMovie({\n            id: movieId,\n            title: parsedContent.title || 'Untitled Story',\n            domain: contentDomain,\n            style: visualStyle,\n            scenes: enhancedScenes,\n            characters: this.extractCharacters(parsedContent),\n            metadata: {\n                originalContent: input.type,\n                generatedAt: Date.now(),\n                estimatedDuration: this.calculateDuration(enhancedScenes),\n                interactiveElements: this.countInteractiveElements(enhancedScenes)\n            }\n        });\n        \n        // Generate SEO assets\n        if (this.options.enableSEOOptimization) {\n            await this.generateSEOAssets(movie);\n        }\n        \n        // Save movie data\n        await this.saveMovie(movie);\n        \n        this.emit('movie:generated', {\n            movieId,\n            title: movie.title,\n            domain: contentDomain,\n            sceneCount: scenes.length,\n            duration: movie.metadata.estimatedDuration\n        });\n        \n        console.log(`âœ… Movie generated successfully: ${movieId}`);\n        return movie;\n    }\n    \n    /**\n     * Parse different types of input content\n     */\n    async parseContent(input, options = {}) {\n        let content = {\n            type: 'unknown',\n            title: '',\n            sections: [],\n            rawText: '',\n            characters: [],\n            metadata: {}\n        };\n        \n        if (typeof input === 'string') {\n            // File path\n            if (input.endsWith('.html')) {\n                content = await this.parseHTMLFile(input);\n            } else if (input.endsWith('.md')) {\n                content = await this.parseMarkdownFile(input);\n            } else {\n                content = await this.parseTextFile(input);\n            }\n        } else if (input.content) {\n            // Direct content object\n            content = await this.parseDirectContent(input);\n        }\n        \n        return content;\n    }\n    \n    async parseHTMLFile(filePath) {\n        try {\n            const htmlContent = await fs.readFile(filePath, 'utf-8');\n            const dom = new JSDOM(htmlContent);\n            const document = dom.window.document;\n            \n            const content = {\n                type: 'html',\n                title: this.extractTitle(document),\n                sections: this.extractSections(document),\n                rawText: document.body.textContent,\n                characters: this.extractCharacters(document.body.textContent),\n                metadata: this.extractMetadata(document)\n            };\n            \n            return content;\n        } catch (error) {\n            console.error('Error parsing HTML file:', error);\n            throw error;\n        }\n    }\n    \n    extractTitle(document) {\n        // Try multiple selectors for title\n        const titleSelectors = [\n            'title',\n            'h1',\n            '.header h1',\n            '.chapter-header h2',\n            '[data-title]'\n        ];\n        \n        for (const selector of titleSelectors) {\n            const element = document.querySelector(selector);\n            if (element && element.textContent.trim()) {\n                return element.textContent.trim();\n            }\n        }\n        \n        return 'Untitled Content';\n    }\n    \n    extractSections(document) {\n        const sections = [];\n        \n        // Look for chapter/section containers\n        const sectionContainers = document.querySelectorAll(\n            '.chapter-container, .section, .chapter-section, .part'\n        );\n        \n        sectionContainers.forEach((container, index) => {\n            const section = {\n                id: `section_${index}`,\n                title: this.extractSectionTitle(container),\n                content: this.extractSectionContent(container),\n                type: this.determineSectionType(container),\n                metadata: this.extractSectionMetadata(container)\n            };\n            \n            sections.push(section);\n        });\n        \n        // If no structured sections found, create sections from paragraphs\n        if (sections.length === 0) {\n            const paragraphs = document.querySelectorAll('p');\n            let currentSection = null;\n            \n            paragraphs.forEach((p, index) => {\n                const text = p.textContent.trim();\n                if (text.length > 50) { // Skip very short paragraphs\n                    if (!currentSection || currentSection.content.length > 500) {\n                        // Start new section\n                        currentSection = {\n                            id: `auto_section_${sections.length}`,\n                            title: this.generateSectionTitle(text),\n                            content: text,\n                            type: 'narrative',\n                            metadata: { auto_generated: true }\n                        };\n                        sections.push(currentSection);\n                    } else {\n                        // Add to current section\n                        currentSection.content += '\\n\\n' + text;\n                    }\n                }\n            });\n        }\n        \n        return sections;\n    }\n    \n    extractSectionTitle(container) {\n        const titleSelectors = [\n            'h1', 'h2', 'h3', '.section-title', '.chapter-meta h2'\n        ];\n        \n        for (const selector of titleSelectors) {\n            const element = container.querySelector(selector);\n            if (element) {\n                return element.textContent.trim();\n            }\n        }\n        \n        return 'Untitled Section';\n    }\n    \n    extractSectionContent(container) {\n        // Remove title elements and extract main content\n        const clone = container.cloneNode(true);\n        const titleElements = clone.querySelectorAll('h1, h2, h3, .section-title');\n        titleElements.forEach(el => el.remove());\n        \n        return clone.textContent.trim();\n    }\n    \n    determineSectionType(container) {\n        const content = container.textContent.toLowerCase();\n        \n        // Check for technical content\n        if (content.includes('api') || content.includes('code') || content.includes('function')) {\n            return 'technical';\n        }\n        \n        // Check for narrative content\n        if (content.includes('cal') || content.includes('story') || content.includes('journey')) {\n            return 'narrative';\n        }\n        \n        // Check for introduction/conclusion\n        if (content.includes('introduction') || content.includes('welcome')) {\n            return 'introduction';\n        }\n        \n        if (content.includes('conclusion') || content.includes('summary')) {\n            return 'conclusion';\n        }\n        \n        return 'narrative'; // Default\n    }\n    \n    extractSectionMetadata(container) {\n        const metadata = {};\n        \n        // Look for routing badges, cost info, etc.\n        const badge = container.querySelector('.routing-badge');\n        if (badge) {\n            metadata.routingType = badge.textContent.trim();\n        }\n        \n        const costInfo = container.querySelector('[style*=\"cost\"]');\n        if (costInfo) {\n            metadata.generationCost = costInfo.textContent.trim();\n        }\n        \n        return metadata;\n    }\n    \n    generateSectionTitle(content) {\n        // Extract first meaningful phrase as title\n        const sentences = content.split('.');\n        const firstSentence = sentences[0].trim();\n        \n        if (firstSentence.length > 50) {\n            const words = firstSentence.split(' ').slice(0, 6);\n            return words.join(' ') + '...';\n        }\n        \n        return firstSentence;\n    }\n    \n    /**\n     * Detect content domain for styling\n     */\n    detectContentDomain(content) {\n        const text = content.rawText.toLowerCase();\n        \n        // Domain detection patterns\n        const domainPatterns = {\n            crypto: [\n                'blockchain', 'bitcoin', 'cryptocurrency', 'token', 'smart contract',\n                'defi', 'nft', 'wallet', 'mining', 'consensus', 'pirate', 'treasure',\n                'doubloon', 'captain cal'\n            ],\n            webdev: [\n                'javascript', 'html', 'css', 'react', 'node', 'api', 'frontend',\n                'backend', 'database', 'framework', 'component', 'developer'\n            ],\n            cyberpunk: [\n                'cyberpunk', 'matrix', 'cyber', 'neon', 'digital', 'neural',\n                'agent zero', 'hologram', 'data stream', 'virtual'\n            ],\n            business: [\n                'business', 'corporate', 'strategy', 'revenue', 'market',\n                'boardroom', 'executive', 'ceo claude', 'roi', 'scaling'\n            ],\n            fantasy: [\n                'magic', 'wizard', 'spell', 'enchanted', 'mystical', 'crystal',\n                'wizard claude', 'academy', 'runes', 'magical'\n            ]\n        };\n        \n        let maxScore = 0;\n        let detectedDomain = this.options.defaultTheme;\n        \n        Object.entries(domainPatterns).forEach(([domain, patterns]) => {\n            const score = patterns.reduce((count, pattern) => {\n                const regex = new RegExp(pattern, 'gi');\n                const matches = text.match(regex);\n                return count + (matches ? matches.length : 0);\n            }, 0);\n            \n            if (score > maxScore) {\n                maxScore = score;\n                detectedDomain = domain;\n            }\n        });\n        \n        console.log(`ðŸŽ¯ Detected domain: ${detectedDomain} (score: ${maxScore})`);\n        return detectedDomain;\n    }\n    \n    /**\n     * Extract scenes from content sections\n     */\n    async extractScenes(content, domain) {\n        const scenes = [];\n        \n        // Add introduction scene if not present\n        if (!content.sections.some(s => s.type === 'introduction')) {\n            scenes.push(this.createIntroductionScene(content, domain));\n        }\n        \n        // Convert each section to a scene\n        content.sections.forEach((section, index) => {\n            const scene = {\n                id: `scene_${index}`,\n                title: section.title,\n                content: section.content,\n                type: section.type,\n                duration: this.calculateSceneDuration(section.content),\n                characters: this.detectSceneCharacters(section.content),\n                emotions: this.detectSceneEmotions(section.content, domain),\n                visualElements: this.generateVisualElements(section, domain),\n                audioElements: this.generateAudioElements(section, domain),\n                interactiveElements: this.generateInteractiveElements(section, domain),\n                metadata: section.metadata || {}\n            };\n            \n            scenes.push(scene);\n        });\n        \n        // Add conclusion scene if not present\n        if (!content.sections.some(s => s.type === 'conclusion')) {\n            scenes.push(this.createConclusionScene(content, domain));\n        }\n        \n        return scenes;\n    }\n    \n    createIntroductionScene(content, domain) {\n        const character = this.selectDomainCharacter(domain);\n        \n        return {\n            id: 'intro_scene',\n            title: 'Welcome',\n            content: `Welcome to ${content.title}! Join ${character.name} on this incredible journey.`,\n            type: 'introduction',\n            duration: 5000,\n            characters: [character.id],\n            emotions: ['welcoming', 'excited'],\n            visualElements: [\n                {\n                    type: 'character_introduction',\n                    character: character.id,\n                    expression: 'welcoming',\n                    position: 'center'\n                },\n                {\n                    type: 'title_card',\n                    text: content.title,\n                    style: 'dramatic'\n                },\n                {\n                    type: 'background',\n                    style: this.visualStyles[domain].backgroundStyle\n                }\n            ],\n            audioElements: [\n                {\n                    type: 'background_music',\n                    track: `${domain}_intro`,\n                    volume: 0.3\n                },\n                {\n                    type: 'character_voice',\n                    character: character.id,\n                    text: character.catchphrases[0]\n                }\n            ],\n            interactiveElements: [\n                {\n                    type: 'click_to_continue',\n                    position: 'bottom-center',\n                    text: 'Begin Adventure'\n                }\n            ]\n        };\n    }\n    \n    createConclusionScene(content, domain) {\n        const character = this.selectDomainCharacter(domain);\n        \n        return {\n            id: 'conclusion_scene',\n            title: 'Journey Complete',\n            content: 'What an incredible adventure! Ready for the next challenge?',\n            type: 'conclusion',\n            duration: 4000,\n            characters: [character.id],\n            emotions: ['satisfied', 'encouraging'],\n            visualElements: [\n                {\n                    type: 'character_conclusion',\n                    character: character.id,\n                    expression: 'proud',\n                    position: 'center'\n                },\n                {\n                    type: 'achievement_display',\n                    achievements: ['story_completed', 'knowledge_gained'],\n                    style: domain\n                }\n            ],\n            audioElements: [\n                {\n                    type: 'victory_music',\n                    track: `${domain}_victory`,\n                    volume: 0.4\n                }\n            ],\n            interactiveElements: [\n                {\n                    type: 'share_achievement',\n                    position: 'bottom-left',\n                    text: 'Share Story'\n                },\n                {\n                    type: 'next_adventure',\n                    position: 'bottom-right',\n                    text: 'Next Adventure'\n                }\n            ]\n        };\n    }\n    \n    selectDomainCharacter(domain) {\n        const characterMap = {\n            crypto: this.characterProfiles['captain-cal'],\n            cyberpunk: this.characterProfiles['agent-zero'],\n            business: this.characterProfiles['ceo-claude'],\n            fantasy: this.characterProfiles['wizard-claude'] || this.characterProfiles['captain-cal'],\n            webdev: this.characterProfiles['captain-cal'] // Default for now\n        };\n        \n        const character = characterMap[domain] || this.characterProfiles['captain-cal'];\n        return {\n            id: Object.keys(this.characterProfiles).find(key => \n                this.characterProfiles[key] === character\n            ),\n            name: character.personality.split('-')[0].charAt(0).toUpperCase() + \n                  character.personality.split('-')[0].slice(1),\n            ...character\n        };\n    }\n    \n    calculateSceneDuration(content) {\n        // Base duration calculation: ~150 words per minute reading speed\n        const wordCount = content.split(/\\s+/).length;\n        const readingTime = (wordCount / 150) * 60 * 1000; // Convert to milliseconds\n        \n        // Add time for visual effects and interactions\n        const baseTime = Math.max(3000, readingTime); // Minimum 3 seconds\n        const maxTime = 15000; // Maximum 15 seconds\n        \n        return Math.min(baseTime * 1.5, maxTime); // 1.5x reading time for visuals\n    }\n    \n    detectSceneCharacters(content) {\n        const characters = [];\n        const text = content.toLowerCase();\n        \n        Object.keys(this.characterProfiles).forEach(characterId => {\n            const character = this.characterProfiles[characterId];\n            const names = characterId.split('-').concat(\n                character.personality.split('-')\n            );\n            \n            if (names.some(name => text.includes(name))) {\n                characters.push(characterId);\n            }\n        });\n        \n        return characters.length > 0 ? characters : ['captain-cal']; // Default character\n    }\n    \n    detectSceneEmotions(content, domain) {\n        const text = content.toLowerCase();\n        const emotions = [];\n        \n        const emotionPatterns = {\n            mysterious: ['mysterious', 'enigmatic', 'hidden', 'secret', 'unknown'],\n            exciting: ['discovery', 'revelation', 'breakthrough', 'amazing', 'incredible'],\n            technical: ['algorithm', 'system', 'code', 'data', 'analysis'],\n            dramatic: ['convergence', 'transformation', 'awakening', 'climax'],\n            peaceful: ['harmony', 'balance', 'calm', 'serene', 'gentle']\n        };\n        \n        Object.entries(emotionPatterns).forEach(([emotion, patterns]) => {\n            if (patterns.some(pattern => text.includes(pattern))) {\n                emotions.push(emotion);\n            }\n        });\n        \n        return emotions.length > 0 ? emotions : ['neutral'];\n    }\n    \n    generateVisualElements(section, domain) {\n        const elements = [];\n        const style = this.visualStyles[domain];\n        \n        // Background element\n        elements.push({\n            type: 'background',\n            style: style.backgroundStyle,\n            opacity: 0.8\n        });\n        \n        // Character element if characters detected\n        const characters = this.detectSceneCharacters(section.content);\n        if (characters.length > 0) {\n            elements.push({\n                type: 'character',\n                character: characters[0],\n                position: 'right',\n                expression: 'speaking',\n                size: 'medium'\n            });\n        }\n        \n        // Content-specific visual elements\n        if (section.type === 'technical') {\n            elements.push({\n                type: 'code_overlay',\n                content: this.extractCodeSnippets(section.content),\n                position: 'left',\n                animated: true\n            });\n        }\n        \n        // Text overlay\n        elements.push({\n            type: 'text_overlay',\n            content: this.createDisplayText(section.content),\n            position: 'bottom',\n            style: 'animated_typewriter',\n            duration: this.calculateSceneDuration(section.content) * 0.8\n        });\n        \n        return elements;\n    }\n    \n    generateAudioElements(section, domain) {\n        const elements = [];\n        \n        // Background music\n        elements.push({\n            type: 'background_music',\n            track: `${domain}_${section.type}`,\n            volume: 0.2,\n            loop: true\n        });\n        \n        // Character narration\n        const characters = this.detectSceneCharacters(section.content);\n        if (characters.length > 0) {\n            elements.push({\n                type: 'narration',\n                character: characters[0],\n                text: this.createNarrationText(section.content),\n                voiceStyle: this.characterProfiles[characters[0]].voiceStyle\n            });\n        }\n        \n        // Sound effects\n        const emotions = this.detectSceneEmotions(section.content, domain);\n        if (emotions.includes('dramatic')) {\n            elements.push({\n                type: 'sound_effect',\n                effect: 'dramatic_sting',\n                timing: 'halfway',\n                volume: 0.5\n            });\n        }\n        \n        return elements;\n    }\n    \n    generateInteractiveElements(section, domain) {\n        const elements = [];\n        \n        // Always add a continue button\n        elements.push({\n            type: 'continue_button',\n            position: 'bottom-right',\n            text: 'Continue',\n            style: domain\n        });\n        \n        // Add domain-specific interactive elements\n        if (domain === 'crypto' && section.content.toLowerCase().includes('treasure')) {\n            elements.push({\n                type: 'treasure_hunt',\n                position: 'hidden',\n                reward: 'bonus_content',\n                hint: 'Click the treasure chest for a bonus!'\n            });\n        }\n        \n        if (section.type === 'technical') {\n            elements.push({\n                type: 'code_playground',\n                position: 'top-right',\n                text: 'Try It',\n                codeSnippet: this.extractCodeSnippets(section.content)\n            });\n        }\n        \n        return elements;\n    }\n    \n    /**\n     * Enhance scenes with generated visuals and effects\n     */\n    async enhanceScenes(scenes, visualStyle, options = {}) {\n        const enhancedScenes = [];\n        \n        for (let i = 0; i < scenes.length; i++) {\n            const scene = scenes[i];\n            console.log(`ðŸŽ¨ Enhancing scene ${i + 1}/${scenes.length}: ${scene.title}`);\n            \n            const enhancedScene = {\n                ...scene,\n                \n                // Generate visual assets\n                generatedAssets: await this.generateSceneAssets(scene, visualStyle),\n                \n                // Add transitions\n                transitions: this.generateSceneTransitions(scene, i, scenes.length),\n                \n                // Add effects\n                effects: this.generateSceneEffects(scene, visualStyle),\n                \n                // Add watermarks\n                watermarks: this.generateWatermarks(scene, visualStyle)\n            };\n            \n            enhancedScenes.push(enhancedScene);\n        }\n        \n        return enhancedScenes;\n    }\n    \n    async generateSceneAssets(scene, visualStyle) {\n        const assets = {\n            images: [],\n            audio: [],\n            animations: []\n        };\n        \n        // Generate background image\n        if (this.options.enableImageGeneration) {\n            const backgroundPrompt = this.createImagePrompt(scene, 'background', visualStyle);\n            assets.images.push({\n                type: 'background',\n                prompt: backgroundPrompt,\n                style: visualStyle.backgroundStyle,\n                filename: `bg_${scene.id}.jpg`\n            });\n            \n            // Generate character image if needed\n            if (scene.characters.length > 0) {\n                const characterPrompt = this.createImagePrompt(scene, 'character', visualStyle);\n                assets.images.push({\n                    type: 'character',\n                    character: scene.characters[0],\n                    prompt: characterPrompt,\n                    filename: `char_${scene.id}.png`\n                });\n            }\n        }\n        \n        return assets;\n    }\n    \n    createImagePrompt(scene, type, visualStyle) {\n        const basePrompts = {\n            background: {\n                crypto: 'Pirate ship deck at sunset, treasure chests, nautical theme, cinematic lighting',\n                cyberpunk: 'Neon-lit cyberpunk cityscape, holographic displays, futuristic architecture',\n                business: 'Modern corporate boardroom, city skyline, professional atmosphere',\n                fantasy: 'Magical library with floating books, crystal orbs, mystical atmosphere'\n            },\n            character: {\n                crypto: 'Wise pirate captain with beard, tricorn hat, confident expression',\n                cyberpunk: 'Cyberpunk agent with glowing cybernetic implants, sleek outfit',\n                business: 'Professional executive in suit, confident posture, boardroom setting',\n                fantasy: 'Wise wizard with robes and staff, magical aura, ancient library'\n            }\n        };\n        \n        const domain = Object.keys(visualStyle).includes('colorPalette') ? \n            Object.keys(this.visualStyles).find(key => this.visualStyles[key] === visualStyle) :\n            'crypto';\n        \n        let prompt = basePrompts[type][domain] || basePrompts[type]['crypto'];\n        \n        // Add scene-specific context\n        const emotions = scene.emotions || [];\n        if (emotions.includes('dramatic')) {\n            prompt += ', dramatic lighting, epic atmosphere';\n        }\n        if (emotions.includes('mysterious')) {\n            prompt += ', mysterious shadows, enigmatic mood';\n        }\n        \n        prompt += ', high quality, detailed, professional artwork';\n        \n        return prompt;\n    }\n    \n    generateSceneTransitions(scene, index, totalScenes) {\n        const transitions = {\n            in: 'fade-in',\n            out: 'fade-out'\n        };\n        \n        // First scene\n        if (index === 0) {\n            transitions.in = 'dramatic-entrance';\n        }\n        \n        // Last scene\n        if (index === totalScenes - 1) {\n            transitions.out = 'epic-fade';\n        }\n        \n        // Scene type specific transitions\n        if (scene.type === 'technical') {\n            transitions.in = 'slide-left';\n        } else if (scene.type === 'climax') {\n            transitions.in = 'zoom-in';\n        }\n        \n        return transitions;\n    }\n    \n    generateSceneEffects(scene, visualStyle) {\n        const effects = [];\n        \n        // Emotion-based effects\n        if (scene.emotions.includes('dramatic')) {\n            effects.push({\n                type: 'lightning_flash',\n                timing: 'climax',\n                intensity: 0.7\n            });\n        }\n        \n        if (scene.emotions.includes('mysterious')) {\n            effects.push({\n                type: 'fog_overlay',\n                opacity: 0.3,\n                movement: 'slow_drift'\n            });\n        }\n        \n        // Technical scenes get data stream effects\n        if (scene.type === 'technical') {\n            effects.push({\n                type: 'data_streams',\n                direction: 'vertical',\n                speed: 'medium',\n                color: visualStyle.colorPalette[2]\n            });\n        }\n        \n        return effects;\n    }\n    \n    generateWatermarks(scene, visualStyle) {\n        if (!this.options.enableSEOOptimization) {\n            return [];\n        }\n        \n        const watermarks = [];\n        \n        // Main brand watermark\n        watermarks.push({\n            type: 'brand_logo',\n            position: 'bottom-left',\n            opacity: 0.6,\n            style: visualStyle.watermarkStyle || this.options.watermarkStyle,\n            text: 'Generated by Document Generator'\n        });\n        \n        // Scene-specific watermark\n        watermarks.push({\n            type: 'scene_credit',\n            position: 'bottom-right',\n            opacity: 0.4,\n            text: `Scene ${scene.id}`,\n            style: 'minimal'\n        });\n        \n        return watermarks;\n    }\n    \n    /**\n     * Create the final interactive movie structure\n     */\n    async createInteractiveMovie(movieData) {\n        const movie = {\n            ...movieData,\n            \n            // Interactive controls\n            controls: {\n                playback: {\n                    play: true,\n                    pause: true,\n                    seek: true,\n                    speed: [0.5, 1, 1.5, 2]\n                },\n                navigation: {\n                    sceneJump: true,\n                    chapterSelect: true,\n                    bookmarks: true\n                },\n                customization: {\n                    themes: Object.keys(this.visualStyles),\n                    characters: Object.keys(this.characterProfiles),\n                    audioTracks: ['narration', 'music', 'effects']\n                }\n            },\n            \n            // SEO and sharing\n            seo: {\n                description: this.generateMovieDescription(movieData),\n                keywords: this.generateMovieKeywords(movieData),\n                socialImage: `${movieData.id}_social.jpg`,\n                canonicalUrl: `https://your-domain.com/movies/${movieData.id}`\n            },\n            \n            // Analytics tracking\n            analytics: {\n                trackingEvents: [\n                    'movie_start',\n                    'scene_complete',\n                    'movie_complete',\n                    'interaction_click',\n                    'share_action'\n                ],\n                customProperties: {\n                    domain: movieData.domain,\n                    sceneCount: movieData.scenes.length,\n                    estimatedDuration: movieData.metadata.estimatedDuration\n                }\n            }\n        };\n        \n        return movie;\n    }\n    \n    /**\n     * Generate SEO assets for traffic generation\n     */\n    async generateSEOAssets(movie) {\n        const seoAssets = {\n            socialImages: [],\n            metaTags: {},\n            backlinks: [],\n            descriptions: {}\n        };\n        \n        // Generate social sharing image\n        const socialImagePrompt = this.createSocialImagePrompt(movie);\n        seoAssets.socialImages.push({\n            filename: `${movie.id}_social.jpg`,\n            prompt: socialImagePrompt,\n            dimensions: { width: 1200, height: 630 },\n            watermark: true\n        });\n        \n        // Generate scene preview images\n        movie.scenes.forEach((scene, index) => {\n            seoAssets.socialImages.push({\n                filename: `${movie.id}_scene_${index}.jpg`,\n                prompt: this.createScenePreviewPrompt(scene),\n                dimensions: { width: 800, height: 600 },\n                watermark: true\n            });\n        });\n        \n        // Generate meta descriptions\n        seoAssets.descriptions.main = this.generateMovieDescription(movie);\n        seoAssets.descriptions.scenes = movie.scenes.map(scene => \n            this.generateSceneDescription(scene)\n        );\n        \n        movie.seoAssets = seoAssets;\n        return seoAssets;\n    }\n    \n    createSocialImagePrompt(movie) {\n        const domain = movie.domain;\n        const character = movie.characters[0] || 'captain-cal';\n        \n        return `Movie poster style image featuring ${character} from ${movie.title}, ` +\n               `${domain} theme with ${this.visualStyles[domain].backgroundStyle} background, ` +\n               `cinematic composition, high quality, poster design`;\n    }\n    \n    createScenePreviewPrompt(scene) {\n        return `Preview image for scene: ${scene.title}, showing key visual elements, ` +\n               `${scene.emotions.join(' and ')} mood, cinematic frame, high quality`;\n    }\n    \n    generateMovieDescription(movie) {\n        return `Interactive movie experience: ${movie.title}. ` +\n               `Join ${movie.characters.join(' and ')} in this ${movie.domain} adventure. ` +\n               `Features ${movie.scenes.length} interactive scenes with immersive storytelling.`;\n    }\n    \n    generateSceneDescription(scene) {\n        return `Scene: ${scene.title}. ${scene.content.substring(0, 100)}...`;\n    }\n    \n    generateMovieKeywords(movie) {\n        const baseKeywords = [\n            'interactive movie',\n            'educational content',\n            'immersive storytelling',\n            movie.domain,\n            'ai generated',\n            'interactive learning'\n        ];\n        \n        const characterKeywords = movie.characters.map(char => \n            char.replace('-', ' ')\n        );\n        \n        return [...baseKeywords, ...characterKeywords].join(', ');\n    }\n    \n    /**\n     * Save movie data and assets\n     */\n    async saveMovie(movie) {\n        const moviePath = path.join(this.options.outputDir, 'movies', `${movie.id}.json`);\n        \n        // Save movie data\n        await fs.writeFile(moviePath, JSON.stringify(movie, null, 2));\n        \n        // Generate HTML player\n        const playerHTML = await this.generateMoviePlayer(movie);\n        const playerPath = path.join(this.options.outputDir, 'movies', `${movie.id}.html`);\n        await fs.writeFile(playerPath, playerHTML);\n        \n        console.log(`ðŸ’¾ Movie saved: ${moviePath}`);\n        console.log(`ðŸŽ¬ Player created: ${playerPath}`);\n    }\n    \n    async generateMoviePlayer(movie) {\n        return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${movie.title} - Interactive Movie</title>\n    <meta name=\"description\" content=\"${movie.seo.description}\">\n    <meta name=\"keywords\" content=\"${movie.seo.keywords}\">\n    \n    <!-- Open Graph / Social Media -->\n    <meta property=\"og:type\" content=\"video.movie\">\n    <meta property=\"og:title\" content=\"${movie.title}\">\n    <meta property=\"og:description\" content=\"${movie.seo.description}\">\n    <meta property=\"og:image\" content=\"${movie.seo.socialImage}\">\n    <meta property=\"og:url\" content=\"${movie.seo.canonicalUrl}\">\n    \n    <!-- Twitter Card -->\n    <meta name=\"twitter:card\" content=\"summary_large_image\">\n    <meta name=\"twitter:title\" content=\"${movie.title}\">\n    <meta name=\"twitter:description\" content=\"${movie.seo.description}\">\n    <meta name=\"twitter:image\" content=\"${movie.seo.socialImage}\">\n    \n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background: #000;\n            font-family: 'Arial', sans-serif;\n            overflow: hidden;\n        }\n        \n        #movie-canvas {\n            width: 100vw;\n            height: 100vh;\n            display: block;\n        }\n        \n        .movie-controls {\n            position: fixed;\n            bottom: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            background: rgba(0, 0, 0, 0.8);\n            padding: 15px 30px;\n            border-radius: 25px;\n            display: flex;\n            gap: 15px;\n            align-items: center;\n            color: white;\n        }\n        \n        .control-button {\n            background: #4CAF50;\n            border: none;\n            color: white;\n            padding: 10px 15px;\n            border-radius: 5px;\n            cursor: pointer;\n            font-size: 14px;\n        }\n        \n        .control-button:hover {\n            background: #45a049;\n        }\n        \n        .progress-bar {\n            width: 300px;\n            height: 5px;\n            background: #333;\n            border-radius: 3px;\n            cursor: pointer;\n        }\n        \n        .progress-fill {\n            height: 100%;\n            background: #4CAF50;\n            border-radius: 3px;\n            width: 0%;\n            transition: width 0.1s;\n        }\n        \n        .scene-title {\n            position: fixed;\n            top: 30px;\n            left: 30px;\n            color: white;\n            font-size: 24px;\n            font-weight: bold;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);\n        }\n        \n        .watermark {\n            position: fixed;\n            bottom: 10px;\n            right: 10px;\n            color: rgba(255,255,255,0.6);\n            font-size: 12px;\n            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"movie-canvas\"></canvas>\n    \n    <div class=\"scene-title\" id=\"scene-title\">${movie.title}</div>\n    \n    <div class=\"movie-controls\">\n        <button class=\"control-button\" id=\"play-pause\">Play</button>\n        <div class=\"progress-bar\" id=\"progress-bar\">\n            <div class=\"progress-fill\" id=\"progress-fill\"></div>\n        </div>\n        <span id=\"time-display\">0:00 / ${this.formatDuration(movie.metadata.estimatedDuration)}</span>\n        <button class=\"control-button\" id=\"share-btn\">Share</button>\n    </div>\n    \n    <div class=\"watermark\">Generated by Document Generator</div>\n    \n    <script>\n        // Movie data\n        const movieData = ${JSON.stringify(movie, null, 2)};\n        \n        // Initialize movie player\n        class InteractiveMoviePlayer {\n            constructor(canvas, movieData) {\n                this.canvas = canvas;\n                this.ctx = canvas.getContext('2d');\n                this.movieData = movieData;\n                this.currentScene = 0;\n                this.isPlaying = false;\n                this.startTime = 0;\n                this.currentTime = 0;\n                \n                this.setupCanvas();\n                this.setupControls();\n                this.loadScene(0);\n            }\n            \n            setupCanvas() {\n                this.canvas.width = window.innerWidth;\n                this.canvas.height = window.innerHeight;\n                \n                window.addEventListener('resize', () => {\n                    this.canvas.width = window.innerWidth;\n                    this.canvas.height = window.innerHeight;\n                    this.redraw();\n                });\n            }\n            \n            setupControls() {\n                document.getElementById('play-pause').addEventListener('click', () => {\n                    this.togglePlayPause();\n                });\n                \n                document.getElementById('progress-bar').addEventListener('click', (e) => {\n                    this.seekToPosition(e);\n                });\n                \n                document.getElementById('share-btn').addEventListener('click', () => {\n                    this.shareMovie();\n                });\n            }\n            \n            loadScene(sceneIndex) {\n                if (sceneIndex >= this.movieData.scenes.length) {\n                    this.onMovieComplete();\n                    return;\n                }\n                \n                this.currentScene = sceneIndex;\n                const scene = this.movieData.scenes[sceneIndex];\n                \n                document.getElementById('scene-title').textContent = scene.title;\n                \n                // Load scene assets and render\n                this.renderScene(scene);\n                \n                // Track analytics\n                this.trackEvent('scene_start', {\n                    scene: sceneIndex,\n                    title: scene.title\n                });\n            }\n            \n            renderScene(scene) {\n                // Clear canvas\n                this.ctx.fillStyle = '#000';\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                // Render background\n                this.renderBackground(scene);\n                \n                // Render character\n                if (scene.characters.length > 0) {\n                    this.renderCharacter(scene);\n                }\n                \n                // Render text content\n                this.renderTextContent(scene);\n                \n                // Render interactive elements\n                this.renderInteractiveElements(scene);\n            }\n            \n            renderBackground(scene) {\n                // For now, render a colored gradient based on domain\n                const colors = this.movieData.style.colorPalette;\n                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);\n                gradient.addColorStop(0, colors[0] || '#1E3A8A');\n                gradient.addColorStop(1, colors[1] || '#374151');\n                \n                this.ctx.fillStyle = gradient;\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            }\n            \n            renderCharacter(scene) {\n                // Placeholder character rendering\n                const x = this.canvas.width * 0.8;\n                const y = this.canvas.height * 0.7;\n                const size = 150;\n                \n                this.ctx.fillStyle = this.movieData.style.colorPalette[2] || '#DAA520';\n                this.ctx.beginPath();\n                this.ctx.arc(x, y, size, 0, Math.PI * 2);\n                this.ctx.fill();\n                \n                // Character name\n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '18px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(scene.characters[0].replace('-', ' '), x, y + size + 30);\n            }\n            \n            renderTextContent(scene) {\n                const maxWidth = this.canvas.width * 0.6;\n                const x = 50;\n                const y = this.canvas.height * 0.3;\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '20px Arial';\n                this.ctx.textAlign = 'left';\n                \n                // Word wrap the content\n                const words = scene.content.split(' ');\n                let line = '';\n                let lineY = y;\n                \n                for (let i = 0; i < words.length; i++) {\n                    const testLine = line + words[i] + ' ';\n                    const metrics = this.ctx.measureText(testLine);\n                    \n                    if (metrics.width > maxWidth && i > 0) {\n                        this.ctx.fillText(line, x, lineY);\n                        line = words[i] + ' ';\n                        lineY += 30;\n                    } else {\n                        line = testLine;\n                    }\n                }\n                this.ctx.fillText(line, x, lineY);\n            }\n            \n            renderInteractiveElements(scene) {\n                // Render continue button\n                const buttonWidth = 120;\n                const buttonHeight = 40;\n                const buttonX = this.canvas.width - buttonWidth - 30;\n                const buttonY = this.canvas.height - buttonHeight - 100;\n                \n                this.ctx.fillStyle = this.movieData.style.colorPalette[3] || '#4CAF50';\n                this.ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '16px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText('Continue', buttonX + buttonWidth/2, buttonY + buttonHeight/2 + 5);\n                \n                // Add click handler\n                this.canvas.addEventListener('click', (e) => {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const clickX = e.clientX - rect.left;\n                    const clickY = e.clientY - rect.top;\n                    \n                    if (clickX >= buttonX && clickX <= buttonX + buttonWidth &&\n                        clickY >= buttonY && clickY <= buttonY + buttonHeight) {\n                        this.nextScene();\n                    }\n                });\n            }\n            \n            nextScene() {\n                this.loadScene(this.currentScene + 1);\n            }\n            \n            togglePlayPause() {\n                this.isPlaying = !this.isPlaying;\n                document.getElementById('play-pause').textContent = this.isPlaying ? 'Pause' : 'Play';\n                \n                if (this.isPlaying) {\n                    this.startTime = Date.now() - this.currentTime;\n                    this.animate();\n                }\n            }\n            \n            animate() {\n                if (!this.isPlaying) return;\n                \n                this.currentTime = Date.now() - this.startTime;\n                this.updateProgress();\n                \n                // Check if scene should advance\n                const currentScene = this.movieData.scenes[this.currentScene];\n                if (this.currentTime >= currentScene.duration) {\n                    this.nextScene();\n                    this.currentTime = 0;\n                    this.startTime = Date.now();\n                }\n                \n                requestAnimationFrame(() => this.animate());\n            }\n            \n            updateProgress() {\n                const totalDuration = this.movieData.metadata.estimatedDuration;\n                const sceneStartTime = this.movieData.scenes.slice(0, this.currentScene)\n                    .reduce((sum, scene) => sum + scene.duration, 0);\n                const currentTotalTime = sceneStartTime + this.currentTime;\n                \n                const progress = (currentTotalTime / totalDuration) * 100;\n                document.getElementById('progress-fill').style.width = progress + '%';\n                \n                const currentMinutes = Math.floor(currentTotalTime / 60000);\n                const currentSeconds = Math.floor((currentTotalTime % 60000) / 1000);\n                const totalMinutes = Math.floor(totalDuration / 60000);\n                const totalSeconds = Math.floor((totalDuration % 60000) / 1000);\n                \n                document.getElementById('time-display').textContent = \n                    \\`\\${currentMinutes}:\\${currentSeconds.toString().padStart(2, '0')} / \\${totalMinutes}:\\${totalSeconds.toString().padStart(2, '0')}\\`;\n            }\n            \n            seekToPosition(e) {\n                const rect = e.target.getBoundingClientRect();\n                const clickX = e.clientX - rect.left;\n                const progress = clickX / rect.width;\n                \n                const totalDuration = this.movieData.metadata.estimatedDuration;\n                const targetTime = totalDuration * progress;\n                \n                // Find which scene this time corresponds to\n                let accumulatedTime = 0;\n                for (let i = 0; i < this.movieData.scenes.length; i++) {\n                    if (accumulatedTime + this.movieData.scenes[i].duration > targetTime) {\n                        this.loadScene(i);\n                        this.currentTime = targetTime - accumulatedTime;\n                        this.startTime = Date.now() - this.currentTime;\n                        break;\n                    }\n                    accumulatedTime += this.movieData.scenes[i].duration;\n                }\n            }\n            \n            shareMovie() {\n                if (navigator.share) {\n                    navigator.share({\n                        title: this.movieData.title,\n                        text: this.movieData.seo.description,\n                        url: window.location.href\n                    });\n                } else {\n                    // Fallback: copy URL to clipboard\n                    navigator.clipboard.writeText(window.location.href).then(() => {\n                        alert('Movie URL copied to clipboard!');\n                    });\n                }\n                \n                this.trackEvent('share_action', {\n                    method: navigator.share ? 'native' : 'clipboard'\n                });\n            }\n            \n            onMovieComplete() {\n                this.isPlaying = false;\n                document.getElementById('play-pause').textContent = 'Replay';\n                \n                // Show completion message\n                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n                \n                this.ctx.fillStyle = 'white';\n                this.ctx.font = '36px Arial';\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText('Movie Complete!', this.canvas.width/2, this.canvas.height/2);\n                \n                this.ctx.font = '18px Arial';\n                this.ctx.fillText('Thank you for watching', this.canvas.width/2, this.canvas.height/2 + 50);\n                \n                this.trackEvent('movie_complete', {\n                    totalTime: this.movieData.metadata.estimatedDuration,\n                    sceneCount: this.movieData.scenes.length\n                });\n            }\n            \n            trackEvent(eventName, properties = {}) {\n                // Analytics tracking\n                console.log('Analytics Event:', eventName, properties);\n                \n                // You can integrate with Google Analytics, Mixpanel, etc. here\n                if (typeof gtag !== 'undefined') {\n                    gtag('event', eventName, properties);\n                }\n            }\n            \n            redraw() {\n                if (this.currentScene < this.movieData.scenes.length) {\n                    this.renderScene(this.movieData.scenes[this.currentScene]);\n                }\n            }\n        }\n        \n        // Initialize the movie player\n        const canvas = document.getElementById('movie-canvas');\n        const player = new InteractiveMoviePlayer(canvas, movieData);\n        \n        // Track page view\n        player.trackEvent('movie_start', {\n            title: movieData.title,\n            domain: movieData.domain\n        });\n    </script>\n</body>\n</html>`;\n    }\n    \n    // Utility methods\n    generateMovieId() {\n        return `movie_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n    }\n    \n    calculateDuration(scenes) {\n        return scenes.reduce((total, scene) => total + scene.duration, 0);\n    }\n    \n    countInteractiveElements(scenes) {\n        return scenes.reduce((total, scene) => \n            total + (scene.interactiveElements ? scene.interactiveElements.length : 0), 0\n        );\n    }\n    \n    formatDuration(milliseconds) {\n        const minutes = Math.floor(milliseconds / 60000);\n        const seconds = Math.floor((milliseconds % 60000) / 1000);\n        return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    }\n    \n    extractCharacters(content) {\n        // Extract character mentions from content\n        const characters = [];\n        const text = typeof content === 'string' ? content : content.textContent || '';\n        \n        Object.keys(this.characterProfiles).forEach(characterId => {\n            if (text.toLowerCase().includes(characterId.replace('-', ' '))) {\n                characters.push(characterId);\n            }\n        });\n        \n        return characters.length > 0 ? characters : ['captain-cal'];\n    }\n    \n    extractMetadata(document) {\n        const metadata = {};\n        \n        // Extract generation stats if available\n        const statsElement = document.querySelector('.generation-stats');\n        if (statsElement) {\n            metadata.generationStats = statsElement.textContent;\n        }\n        \n        // Extract cost analysis\n        const costElement = document.querySelector('.cost-analysis');\n        if (costElement) {\n            metadata.costAnalysis = costElement.textContent;\n        }\n        \n        return metadata;\n    }\n    \n    extractCodeSnippets(content) {\n        // Extract code blocks from content\n        const codePattern = /```([\\s\\S]*?)```|`([^`]+)`/g;\n        const matches = content.match(codePattern);\n        \n        return matches ? matches.map(match => match.replace(/`/g, '')) : [];\n    }\n    \n    createDisplayText(content) {\n        // Create display-friendly version of content\n        return content.length > 200 ? content.substring(0, 197) + '...' : content;\n    }\n    \n    createNarrationText(content) {\n        // Create narration-friendly version of content\n        return content\n            .replace(/[\\r\\n]+/g, ' ') // Remove line breaks\n            .replace(/\\s+/g, ' ') // Normalize spaces\n            .substring(0, 300); // Limit length for narration\n    }\n    \n    // Placeholder methods for file parsing\n    async parseMarkdownFile(filePath) {\n        const content = await fs.readFile(filePath, 'utf-8');\n        // Basic markdown parsing - you could use a library like marked.js\n        return {\n            type: 'markdown',\n            title: content.split('\\n')[0].replace(/^#+\\s*/, ''),\n            sections: content.split('\\n\\n').map((section, index) => ({\n                id: `md_section_${index}`,\n                title: `Section ${index + 1}`,\n                content: section,\n                type: 'narrative'\n            })),\n            rawText: content,\n            characters: this.extractCharacters(content),\n            metadata: {}\n        };\n    }\n    \n    async parseTextFile(filePath) {\n        const content = await fs.readFile(filePath, 'utf-8');\n        return {\n            type: 'text',\n            title: path.basename(filePath, path.extname(filePath)),\n            sections: [{\n                id: 'text_section_0',\n                title: 'Main Content',\n                content: content,\n                type: 'narrative'\n            }],\n            rawText: content,\n            characters: this.extractCharacters(content),\n            metadata: {}\n        };\n    }\n    \n    async parseDirectContent(input) {\n        return {\n            type: 'direct',\n            title: input.title || 'Direct Content',\n            sections: input.sections || [{\n                id: 'direct_section_0',\n                title: input.title || 'Content',\n                content: input.content || '',\n                type: 'narrative'\n            }],\n            rawText: input.content || '',\n            characters: this.extractCharacters(input.content || ''),\n            metadata: input.metadata || {}\n        };\n    }\n}\n\nmodule.exports = ContentToMovieGenerator;