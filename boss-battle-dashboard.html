<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Boss Battle Arena - Submit & Watch AI Fight</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.1em;
            color: #b3b3b3;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .panel h2 {
            color: #feca57;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #ffffff;
            font-weight: bold;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #feca57;
            box-shadow: 0 0 10px rgba(254, 202, 87, 0.3);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .abilities-section {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
        }

        .ability-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .ability-item input {
            flex: 1;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: #000;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48dbfb, #ff9ff3);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            color: white;
        }

        .boss-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .boss-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .boss-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-color: #feca57;
        }

        .boss-card h3 {
            color: #feca57;
            margin-bottom: 10px;
        }

        .boss-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            text-align: center;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .difficulty-easy { background: #2ed573; color: #000; }
        .difficulty-medium { background: #ffa502; color: #000; }
        .difficulty-hard { background: #ff4757; color: #fff; }
        .difficulty-legendary { background: linear-gradient(45deg, #ffd700, #ffed4a); color: #000; }

        .battle-viewer {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
        }

        .battle-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        .battle-arena {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        #battleCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .battle-log {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .log-hit { background: rgba(255, 107, 107, 0.2); }
        .log-miss { background: rgba(255, 255, 255, 0.1); }
        .log-death { background: rgba(255, 71, 87, 0.3); }
        .log-move { background: rgba(72, 219, 251, 0.2); }

        .leaderboard {
            grid-column: span 2;
            margin-top: 30px;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
        }

        .leaderboard-table th,
        .leaderboard-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-table th {
            background: rgba(254, 202, 87, 0.2);
            color: #feca57;
            font-weight: bold;
        }

        .rank-1 { color: #ffd700; }
        .rank-2 { color: #c0c0c0; }
        .rank-3 { color: #cd7f32; }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-online { background: #2ed573; }
        .status-fighting { background: #ff4757; animation: pulse 1s infinite; }
        .status-offline { background: #747d8c; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .file-upload {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload:hover {
            border-color: #feca57;
            background: rgba(254, 202, 87, 0.1);
        }

        .template-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .template-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .template-option:hover,
        .template-option.selected {
            border-color: #feca57;
            background: rgba(254, 202, 87, 0.2);
        }

        .template-option h4 {
            color: #feca57;
            margin-bottom: 5px;
        }

        /* Live Battle Streaming Styles */
        .live-battle-viewer {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }

        .connection-status.disconnected {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .connection-status.connecting {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
        }

        .battle-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .battle-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .battle-stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .participant-list {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .participant {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .participant:last-child {
            border-bottom: none;
        }

        .health-bar {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #27ae60 100%);
            transition: width 0.3s ease;
        }

        .battle-grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            gap: 1px;
            margin-bottom: 20px;
            max-width: 600px;
            margin: 0 auto 20px;
            border: 2px solid #555;
            border-radius: 8px;
            overflow: hidden;
        }

        .grid-cell {
            width: 28px;
            height: 28px;
            background: #34495e;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .grid-cell.walkable {
            background: #34495e;
        }

        .grid-cell.obstacle {
            background: #e74c3c;
        }

        .entity {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .entity.boss {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            width: 24px;
            height: 24px;
            border: 2px solid #fff;
        }

        .entity.monster {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            width: 24px;
            height: 24px;
            border: 2px solid #fff;
        }

        .entity.player {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            width: 18px;
            height: 18px;
            border: 2px solid #fff;
        }

        .entity.targeting::after {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px dashed #f39c12;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .battle-log {
            height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            font-size: 0.9em;
        }

        .battle-log::-webkit-scrollbar {
            width: 8px;
        }

        .battle-log::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        .battle-log::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            opacity: 0;
            animation: fadeInUp 0.3s ease forwards;
        }

        .log-entry.combat-hit {
            background: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
        }

        .log-entry.combat-miss {
            background: rgba(149, 165, 166, 0.2);
            border-left: 3px solid #95a5a6;
        }

        .log-entry.movement {
            background: rgba(52, 152, 219, 0.2);
            border-left: 3px solid #3498db;
        }

        .log-entry.death {
            background: rgba(155, 89, 182, 0.2);
            border-left: 3px solid #9b59b6;
            font-weight: bold;
        }

        .log-entry.system {
            background: rgba(149, 165, 166, 0.2);
            border-left: 3px solid #95a5a6;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.5);
            }
        }

        @media (max-width: 768px) {
            .main-grid,
            .battle-grid {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2em;
            }

            .battle-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>‚öîÔ∏è Boss Battle Arena ‚öîÔ∏è</h1>
            <p>Create custom bosses and watch AI agents fight them in real-time RuneScape-style combat!</p>
            <div style="margin-top: 15px;">
                <span class="status-indicator status-online"></span> API Connected
                <span style="margin: 0 15px;">|</span>
                <span class="status-indicator status-fighting"></span> <span id="activeBattles">0</span> Active Battles
                <span style="margin: 0 15px;">|</span>
                <span id="totalBosses">0</span> Total Bosses
            </div>
        </header>

        <div class="main-grid">
            <!-- Boss Creation Panel -->
            <div class="panel">
                <h2>üõ†Ô∏è Create Your Boss</h2>
                
                <div class="template-selector" id="templateSelector">
                    <div class="template-option" data-template="basic">
                        <h4>Basic</h4>
                        <p>Level 5<br>Easy</p>
                    </div>
                    <div class="template-option" data-template="warrior">
                        <h4>Warrior</h4>
                        <p>Level 25<br>Medium</p>
                    </div>
                    <div class="template-option" data-template="dragon">
                        <h4>Dragon</h4>
                        <p>Level 100<br>Legendary</p>
                    </div>
                </div>

                <form id="bossForm">
                    <div class="form-group">
                        <label for="bossName">Boss Name *</label>
                        <input type="text" id="bossName" name="name" required maxlength="50" placeholder="Enter boss name...">
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="bossLevel">Level *</label>
                            <input type="number" id="bossLevel" name="level" required min="1" max="999" value="10">
                        </div>
                        <div class="form-group">
                            <label for="bossSize">Size (tiles)</label>
                            <select id="bossSize" name="size">
                                <option value="1">1x1 (Small)</option>
                                <option value="2">2x2 (Medium)</option>
                                <option value="3">3x3 (Large)</option>
                                <option value="4">4x4 (Huge)</option>
                                <option value="5">5x5 (Massive)</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="bossHealth">Health *</label>
                            <input type="number" id="bossHealth" name="health" required min="10" max="100000" value="100">
                        </div>
                        <div class="form-group">
                            <label for="bossDamage">Damage *</label>
                            <input type="number" id="bossDamage" name="damage" required min="1" max="5000" value="15">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="bossDefense">Defense</label>
                            <input type="number" id="bossDefense" name="defense" min="0" max="1000" value="5">
                        </div>
                        <div class="form-group">
                            <label for="bossAggroRange">Aggro Range</label>
                            <input type="number" id="bossAggroRange" name="aggroRange" min="1" max="20" value="10">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="bossDescription">Description</label>
                        <textarea id="bossDescription" name="description" maxlength="500" rows="3" placeholder="Describe your boss..."></textarea>
                    </div>

                    <div class="abilities-section">
                        <label>Abilities</label>
                        <div id="abilitiesList">
                            <div class="ability-item">
                                <input type="text" placeholder="Ability name..." maxlength="30">
                                <button type="button" class="btn btn-danger" onclick="removeAbility(this)">‚ùå</button>
                            </div>
                        </div>
                        <button type="button" class="btn btn-secondary" onclick="addAbility()">‚ûï Add Ability</button>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label>Boss Assets (Images/Sounds)</label>
                        <div class="file-upload" onclick="document.getElementById('bossAssets').click()">
                            <p>üìÅ Click to upload images/sounds (Max 5MB each)</p>
                            <input type="file" id="bossAssets" name="assets" multiple accept="image/*,audio/*" style="display: none;">
                        </div>
                        <div id="uploadedFiles"></div>
                    </div>

                    <div class="form-group">
                        <label for="creatorName">Your Name</label>
                        <input type="text" id="creatorName" name="creator" placeholder="Creator name (optional)">
                    </div>

                    <button type="submit" class="btn">‚öîÔ∏è Submit Boss</button>
                    <button type="button" class="btn btn-secondary" onclick="resetForm()">üîÑ Reset</button>
                </form>
            </div>

            <!-- Boss Gallery Panel -->
            <div class="panel">
                <h2>üëπ Boss Gallery</h2>
                <div style="margin-bottom: 15px;">
                    <select id="difficultyFilter" onchange="filterBosses()">
                        <option value="">All Difficulties</option>
                        <option value="EASY">Easy</option>
                        <option value="MEDIUM">Medium</option>
                        <option value="HARD">Hard</option>
                        <option value="LEGENDARY">Legendary</option>
                    </select>
                    <select id="sortBy" onchange="loadBosses()">
                        <option value="createdAt">Newest First</option>
                        <option value="battles">Most Battles</option>
                        <option value="rating">Highest Rating</option>
                        <option value="revenue">Most Revenue</option>
                    </select>
                </div>
                <div class="boss-gallery" id="bossGallery">
                    <!-- Bosses will be loaded here -->
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="loadMoreBosses()">Load More Bosses</button>
                </div>
            </div>
        </div>

        <!-- Live Battle Viewer -->
        <div class="live-battle-viewer">
            <h2>‚öîÔ∏èüì° Live Battle Stream</h2>
            
            <!-- Connection Status -->
            <div id="connectionStatus" class="connection-status disconnected">
                üî¥ Disconnected from battle server
            </div>
            
            <!-- Battle Controls -->
            <div class="battle-controls">
                <button class="btn" onclick="connectToStream()">üì° Connect to Stream</button>
                <button class="btn" onclick="startCustomBattle()">‚öîÔ∏è Start Battle</button>
                <button class="btn btn-secondary" onclick="refreshBattleList()">üîÑ Refresh Battles</button>
            </div>
            
            <!-- Active Battles List -->
            <div class="battle-info">
                <div class="battle-stats">
                    <h3>üìä Battle Stats</h3>
                    <div id="battleStats">
                        <p>Total Battles: <span id="totalBattles">0</span></p>
                        <p>Active Battles: <span id="activeBattles">0</span></p>
                        <p>Live Viewers: <span id="activeViewers">0</span></p>
                        <p>Available Bosses: <span id="availableBosses">0</span></p>
                    </div>
                </div>
                
                <div class="participant-list">
                    <h3>üë• Battle Participants</h3>
                    <div id="participantsList">
                        <p style="color: #888;">No active battle</p>
                    </div>
                </div>
            </div>
            
            <!-- Battle Grid -->
            <div class="battle-grid" id="battleGrid">
                <!-- Grid cells will be generated dynamically -->
            </div>
            
            <!-- Battle Log -->
            <div class="battle-log" id="battleLog">
                <div class="log-entry system">‚öîÔ∏è Battle stream ready! Connect to watch live battles...</div>
            </div>
        </div>

        <!-- Leaderboards -->
        <div class="panel leaderboard">
            <h2>üèÜ Leaderboards</h2>
            <div style="margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="loadLeaderboard('rating')">Top Rated</button>
                <button class="btn btn-secondary" onclick="loadLeaderboard('battles')">Most Battles</button>
                <button class="btn btn-secondary" onclick="loadLeaderboard('revenue')">Highest Revenue</button>
                <button class="btn btn-secondary" onclick="loadLeaderboard('winrate')">Best Win Rate</button>
            </div>
            <table class="leaderboard-table" id="leaderboardTable">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Boss Name</th>
                        <th>Creator</th>
                        <th>Level</th>
                        <th>Battles</th>
                        <th>Win Rate</th>
                        <th>Rating</th>
                        <th>Revenue</th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                    <!-- Leaderboard data will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Global state
        let currentBosses = [];
        let currentPage = 1;
        let battleCanvas, battleCtx;
        let battleSystem = null;
        let websocket = null;

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
        });

        async function initializeDashboard() {
            console.log('üöÄ Initializing Boss Battle Dashboard...');
            
            // Initialize battle canvas
            battleCanvas = document.getElementById('battleCanvas');
            battleCtx = battleCanvas.getContext('2d');
            
            // Set up form handlers
            setupFormHandlers();
            
            // Load initial data
            await loadTemplates();
            await loadBosses();
            await loadLeaderboard('rating');
            
            // Set up WebSocket for real-time updates
            setupWebSocket();
            
            console.log('‚úÖ Dashboard initialized!');
        }

        function setupFormHandlers() {
            // Boss form submission
            document.getElementById('bossForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                await submitBoss();
            });

            // Template selector
            document.querySelectorAll('.template-option').forEach(option => {
                option.addEventListener('click', function() {
                    selectTemplate(this.dataset.template);
                });
            });

            // File upload handler
            document.getElementById('bossAssets').addEventListener('change', function(e) {
                displayUploadedFiles(e.target.files);
            });
        }

        async function loadTemplates() {
            try {
                const response = await fetch('http://localhost:4200/api/templates');
                const data = await response.json();
                
                if (data.success) {
                    console.log('üìã Templates loaded:', data.templates.length);
                }
            } catch (error) {
                console.error('Failed to load templates:', error);
            }
        }

        function selectTemplate(templateId) {
            // Clear previous selection
            document.querySelectorAll('.template-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Mark selected
            document.querySelector(`[data-template="${templateId}"]`).classList.add('selected');
            
            // Load template data into form
            const templates = {
                basic: {
                    name: 'Basic Enemy',
                    level: 5,
                    health: 100,
                    damage: 15,
                    defense: 5,
                    size: 1,
                    aggroRange: 10,
                    description: 'A basic enemy perfect for new challengers.',
                    abilities: ['basic_attack']
                },
                warrior: {
                    name: 'Fierce Warrior',
                    level: 25,
                    health: 500,
                    damage: 45,
                    defense: 20,
                    size: 2,
                    aggroRange: 12,
                    description: 'A skilled warrior with devastating attacks.',
                    abilities: ['slash_attack', 'shield_bash', 'war_cry']
                },
                dragon: {
                    name: 'Ancient Dragon',
                    level: 100,
                    health: 5000,
                    damage: 200,
                    defense: 100,
                    size: 4,
                    aggroRange: 15,
                    description: 'An ancient dragon of immense power.',
                    abilities: ['dragon_breath', 'tail_sweep', 'wing_buffet', 'roar']
                }
            };
            
            const template = templates[templateId];
            if (template) {
                document.getElementById('bossName').value = template.name;
                document.getElementById('bossLevel').value = template.level;
                document.getElementById('bossHealth').value = template.health;
                document.getElementById('bossDamage').value = template.damage;
                document.getElementById('bossDefense').value = template.defense;
                document.getElementById('bossSize').value = template.size;
                document.getElementById('bossAggroRange').value = template.aggroRange;
                document.getElementById('bossDescription').value = template.description;
                
                // Set abilities
                setFormAbilities(template.abilities);
            }
        }

        function setFormAbilities(abilities) {
            const container = document.getElementById('abilitiesList');
            container.innerHTML = '';
            
            abilities.forEach(ability => {
                const abilityDiv = document.createElement('div');
                abilityDiv.className = 'ability-item';
                abilityDiv.innerHTML = `
                    <input type="text" value="${ability}" placeholder="Ability name..." maxlength="30">
                    <button type="button" class="btn btn-danger" onclick="removeAbility(this)">‚ùå</button>
                `;
                container.appendChild(abilityDiv);
            });
        }

        function addAbility() {
            const container = document.getElementById('abilitiesList');
            const abilityDiv = document.createElement('div');
            abilityDiv.className = 'ability-item';
            abilityDiv.innerHTML = `
                <input type="text" placeholder="Ability name..." maxlength="30">
                <button type="button" class="btn btn-danger" onclick="removeAbility(this)">‚ùå</button>
            `;
            container.appendChild(abilityDiv);
        }

        function removeAbility(button) {
            button.parentElement.remove();
        }

        function displayUploadedFiles(files) {
            const container = document.getElementById('uploadedFiles');
            container.innerHTML = '';
            
            Array.from(files).forEach(file => {
                const fileDiv = document.createElement('div');
                fileDiv.style.cssText = 'margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 5px;';
                fileDiv.innerHTML = `üìÑ ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                container.appendChild(fileDiv);
            });
        }

        async function submitBoss() {
            const formData = new FormData();
            
            // Get form data
            const form = document.getElementById('bossForm');
            const formElements = form.elements;
            
            for (let element of formElements) {
                if (element.name && element.value && element.type !== 'file') {
                    formData.append(element.name, element.value);
                }
            }

            // Get abilities
            const abilities = [];
            document.querySelectorAll('#abilitiesList input').forEach(input => {
                if (input.value.trim()) {
                    abilities.push(input.value.trim());
                }
            });
            formData.append('abilities', JSON.stringify(abilities));

            // Add files
            const fileInput = document.getElementById('bossAssets');
            for (let file of fileInput.files) {
                formData.append('assets', file);
            }

            // Set max health same as health
            formData.append('maxHealth', formData.get('health'));

            try {
                const response = await fetch('http://localhost:4200/api/bosses/submit', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    alert('‚úÖ Boss submitted successfully!');
                    resetForm();
                    await loadBosses(); // Refresh boss gallery
                } else {
                    alert('‚ùå Failed to submit boss: ' + (result.details ? result.details.join('\n') : result.error));
                }
            } catch (error) {
                console.error('Submission error:', error);
                alert('‚ùå Network error: ' + error.message);
            }
        }

        function resetForm() {
            document.getElementById('bossForm').reset();
            document.getElementById('uploadedFiles').innerHTML = '';
            document.querySelectorAll('.template-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Reset abilities to one empty field
            document.getElementById('abilitiesList').innerHTML = `
                <div class="ability-item">
                    <input type="text" placeholder="Ability name..." maxlength="30">
                    <button type="button" class="btn btn-danger" onclick="removeAbility(this)">‚ùå</button>
                </div>
            `;
        }

        async function loadBosses(reset = false) {
            if (reset) currentPage = 1;
            
            try {
                const sortBy = document.getElementById('sortBy').value;
                const difficulty = document.getElementById('difficultyFilter').value;
                
                let url = `http://localhost:4200/api/bosses?page=${currentPage}&limit=20&sortBy=${sortBy}`;
                if (difficulty) url += `&difficulty=${difficulty}`;
                
                const response = await fetch(url);
                const data = await response.json();

                if (data.success) {
                    if (reset || currentPage === 1) {
                        currentBosses = data.bosses;
                    } else {
                        currentBosses.push(...data.bosses);
                    }
                    
                    displayBosses();
                    updateStats();
                }
            } catch (error) {
                console.error('Failed to load bosses:', error);
            }
        }

        function displayBosses() {
            const container = document.getElementById('bossGallery');
            container.innerHTML = '';

            currentBosses.forEach(boss => {
                const bossCard = createBossCard(boss);
                container.appendChild(bossCard);
            });
        }

        function createBossCard(boss) {
            const card = document.createElement('div');
            card.className = 'boss-card';
            card.onclick = () => selectBossForBattle(boss);
            
            const winRate = boss.battles > 0 ? ((boss.wins / boss.battles) * 100).toFixed(1) : '0';
            const difficultyClass = `difficulty-${boss.difficulty ? boss.difficulty.toLowerCase() : 'easy'}`;
            
            card.innerHTML = `
                <h3>${boss.name}</h3>
                <div class="boss-stats">
                    <div class="stat-item">Level: ${boss.level}</div>
                    <div class="stat-item">HP: ${boss.health}</div>
                    <div class="stat-item">DMG: ${boss.damage}</div>
                    <div class="stat-item">DEF: ${boss.defense}</div>
                    <div class="stat-item">Battles: ${boss.battles || 0}</div>
                    <div class="stat-item">Win Rate: ${winRate}%</div>
                </div>
                <div style="margin: 10px 0;">
                    <span class="difficulty-badge ${difficultyClass}">
                        ${boss.difficulty || 'Easy'}
                    </span>
                </div>
                <p style="font-size: 0.9em; color: #b3b3b3;">${boss.description || 'No description'}</p>
                <div style="margin-top: 10px; font-size: 0.8em; color: #888;">
                    By: ${boss.creator || 'Unknown'} | Revenue: $${(boss.revenue || 0).toFixed(2)}
                </div>
            `;
            
            return card;
        }

        function selectBossForBattle(boss) {
            console.log('‚öîÔ∏è Selected boss for battle:', boss.name);
            addLogEntry(`üéØ Selected ${boss.name} for battle!`, 'log-move');
            
            // Store selected boss for battle
            window.selectedBoss = boss;
        }

        function filterBosses() {
            loadBosses(true);
        }

        function loadMoreBosses() {
            currentPage++;
            loadBosses();
        }

        async function loadLeaderboard(type) {
            try {
                const response = await fetch(`http://localhost:4200/api/leaderboards?type=${type}&limit=10`);
                const data = await response.json();

                if (data.success) {
                    displayLeaderboard(data.leaderboard);
                }
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
            }
        }

        function displayLeaderboard(leaderboard) {
            const tbody = document.getElementById('leaderboardBody');
            tbody.innerHTML = '';

            leaderboard.forEach(entry => {
                const row = document.createElement('tr');
                const rankClass = entry.rank <= 3 ? `rank-${entry.rank}` : '';
                
                row.innerHTML = `
                    <td class="${rankClass}">#${entry.rank}</td>
                    <td>${entry.name}</td>
                    <td>${entry.creator}</td>
                    <td>${entry.level}</td>
                    <td>${entry.battles}</td>
                    <td>${entry.winRate}%</td>
                    <td>${entry.rating}</td>
                    <td>$${entry.revenue}</td>
                `;
                
                tbody.appendChild(row);
            });
        }

        function startRandomBattle() {
            if (currentBosses.length === 0) {
                alert('No bosses available! Create or load some bosses first.');
                return;
            }
            
            const randomBoss = currentBosses[Math.floor(Math.random() * currentBosses.length)];
            selectBossForBattle(randomBoss);
            
            // Simulate battle
            simulateBattle(randomBoss);
        }

        function simulateBattle(boss) {
            addLogEntry(`‚öîÔ∏è Battle starting: AI Agent vs ${boss.name}!`, 'log-hit');
            
            // Create mock battle data
            let agentHealth = 100;
            let bossHealth = boss.health;
            let turn = 0;
            
            const battleInterval = setInterval(() => {
                turn++;
                
                // Agent attacks boss
                if (Math.random() > 0.3) { // 70% hit chance
                    const damage = Math.floor(Math.random() * 20) + 10;
                    bossHealth -= damage;
                    addLogEntry(`üó°Ô∏è AI Agent hits ${boss.name} for ${damage} damage!`, 'log-hit');
                } else {
                    addLogEntry(`üõ°Ô∏è AI Agent misses ${boss.name}!`, 'log-miss');
                }
                
                if (bossHealth <= 0) {
                    addLogEntry(`üíÄ ${boss.name} has been defeated by AI Agent!`, 'log-death');
                    clearInterval(battleInterval);
                    recordBattleResult(boss.id, 'ai_agent');
                    return;
                }
                
                // Boss attacks agent
                if (Math.random() > 0.2) { // 80% hit chance
                    const damage = Math.floor(Math.random() * boss.damage) + 5;
                    agentHealth -= damage;
                    addLogEntry(`üí• ${boss.name} hits AI Agent for ${damage} damage!`, 'log-hit');
                } else {
                    addLogEntry(`‚öîÔ∏è ${boss.name} misses AI Agent!`, 'log-miss');
                }
                
                if (agentHealth <= 0) {
                    addLogEntry(`üíÄ AI Agent has been defeated by ${boss.name}!`, 'log-death');
                    clearInterval(battleInterval);
                    recordBattleResult(boss.id, boss.id);
                    return;
                }
                
                // Stop after 20 turns to prevent infinite battles
                if (turn >= 20) {
                    addLogEntry(`‚è∞ Battle timeout - ${bossHealth > agentHealth ? boss.name : 'AI Agent'} wins!`, 'log-death');
                    clearInterval(battleInterval);
                    recordBattleResult(boss.id, bossHealth > agentHealth ? boss.id : 'ai_agent');
                }
                
            }, 2000); // Battle turn every 2 seconds
        }

        async function recordBattleResult(bossId, winnerId) {
            try {
                const response = await fetch('http://localhost:4200/api/battles/result', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bossId: bossId,
                        winnerId: winnerId,
                        battleData: {
                            duration: 60,
                            viewers: Math.floor(Math.random() * 50) + 1
                        }
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ Battle result recorded');
                    await loadBosses(true); // Refresh boss stats
                    await loadLeaderboard('rating'); // Refresh leaderboard
                }
            } catch (error) {
                console.error('Failed to record battle result:', error);
            }
        }

        function pauseBattle() {
            addLogEntry(`‚è∏Ô∏è Battle paused`, 'log-move');
        }

        function resetBattle() {
            const logContainer = document.getElementById('logEntries');
            logContainer.innerHTML = '<div class="log-entry">‚öîÔ∏è Battle arena reset!</div>';
        }

        function addLogEntry(message, cssClass = 'log-entry') {
            const logContainer = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = `log-entry ${cssClass}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // WebSocket connection and real-time battle streaming
        let wsConnection = null;
        let currentBattleId = null;
        let battleGrid = null;
        let battleEntities = new Map();

        function setupWebSocket() {
            // Auto-connect to streaming on page load
            setTimeout(() => {
                connectToStream();
            }, 1000);
        }

        function connectToStream() {
            const wsUrl = 'ws://localhost:8081';
            
            updateConnectionStatus('connecting', 'üü° Connecting to battle server...');
            
            try {
                wsConnection = new WebSocket(wsUrl);
                
                wsConnection.onopen = function(event) {
                    console.log('üì° Connected to battle streaming server');
                    updateConnectionStatus('connected', 'üü¢ Connected to battle server');
                };
                
                wsConnection.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    handleStreamMessage(message);
                };
                
                wsConnection.onclose = function(event) {
                    console.log('üì° Disconnected from battle streaming server');
                    updateConnectionStatus('disconnected', 'üî¥ Disconnected from battle server');
                    
                    // Auto-reconnect after 5 seconds
                    setTimeout(() => {
                        if (!wsConnection || wsConnection.readyState === WebSocket.CLOSED) {
                            connectToStream();
                        }
                    }, 5000);
                };
                
                wsConnection.onerror = function(error) {
                    console.error('üì° WebSocket error:', error);
                    updateConnectionStatus('disconnected', 'üî¥ Connection error');
                };
                
            } catch (error) {
                console.error('üì° Failed to connect to streaming server:', error);
                updateConnectionStatus('disconnected', 'üî¥ Failed to connect');
            }
        }

        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.className = `connection-status ${status}`;
            statusElement.textContent = message;
        }

        function handleStreamMessage(message) {
            console.log('üì° Received stream message:', message.type);
            
            switch (message.type) {
                case 'welcome':
                    handleWelcomeMessage(message);
                    break;
                    
                case 'battle_started':
                    handleBattleStarted(message.battle);
                    break;
                    
                case 'battle_state':
                    handleBattleState(message.state);
                    break;
                    
                case 'battle_event':
                    handleBattleEvent(message);
                    break;
                    
                case 'battle_ended':
                    handleBattleEnded(message.data);
                    break;
                    
                case 'error':
                    console.error('Stream error:', message.message);
                    addLogEntry('system', `‚ùå Error: ${message.message}`);
                    break;
            }
        }

        function handleWelcomeMessage(message) {
            console.log('üì° Welcome to battle stream:', message.clientId);
            
            // Update stats from server
            if (message.stats) {
                document.getElementById('totalBattles').textContent = message.stats.totalBattles;
                document.getElementById('activeBattles').textContent = message.stats.activeBattles;
                document.getElementById('activeViewers').textContent = message.stats.activeViewers;
                document.getElementById('availableBosses').textContent = message.stats.availableBosses;
            }
            
            // Subscribe to any available battles
            if (message.availableBattles && message.availableBattles.length > 0) {
                const battleId = message.availableBattles[0];
                subscribeToBattle(battleId);
            }
        }

        function handleBattleStarted(battle) {
            addLogEntry('system', `‚öîÔ∏è New battle started: ${battle.bossName} (Level ${battle.bossLevel})`);
            subscribeToBattle(battle.id);
        }

        function handleBattleState(battleState) {
            console.log('üì° Battle state received:', battleState);
            
            if (battleState.id !== currentBattleId) {
                currentBattleId = battleState.id;
                initializeBattleGrid(battleState.gridSize);
            }
            
            updateBattleInfo(battleState);
            updateBattleGrid(battleState.entities);
        }

        function handleBattleEvent(message) {
            const { eventType, data } = message;
            
            switch (eventType) {
                case 'combat_hit':
                    addLogEntry('combat-hit', 
                        `‚öîÔ∏è ${data.attacker.name} hits ${data.target.name} for ${data.damage} damage!`
                    );
                    animateHealthChange(data.target.id, data.damage);
                    break;
                    
                case 'combat_miss':
                    addLogEntry('combat-miss', 
                        `üõ°Ô∏è ${data.attacker.name} misses ${data.target.name}!`
                    );
                    break;
                    
                case 'entity_moved':
                    addLogEntry('movement', 
                        `üö∂ ${data.entity.name} moves to (${data.newX}, ${data.newY})`
                    );
                    updateEntityPosition(data.entity);
                    break;
                    
                case 'entity_death':
                    addLogEntry('death', 
                        `üíÄ ${data.deceased.name} has been defeated by ${data.killer.name}!`
                    );
                    removeEntityFromGrid(data.deceased.id);
                    break;
                    
                case 'entity_added':
                    addLogEntry('system', 
                        `üëπ ${data.entity.name} (${data.entity.type}) enters the battle!`
                    );
                    break;
            }
        }

        function handleBattleEnded(data) {
            addLogEntry('system', `üèÅ Battle ended: ${data.reason} (Duration: ${(data.duration / 1000).toFixed(1)}s)`);
            
            // Clear battle grid after a few seconds
            setTimeout(() => {
                clearBattleGrid();
                currentBattleId = null;
            }, 5000);
        }

        function subscribeToBattle(battleId) {
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                wsConnection.send(JSON.stringify({
                    type: 'subscribe_battle',
                    battleId: battleId
                }));
                console.log('üëÅÔ∏è Subscribed to battle:', battleId);
            }
        }

        function startCustomBattle() {
            // Get random approved boss
            if (currentBosses.length === 0) {
                alert('No bosses available! Please submit a boss first.');
                return;
            }
            
            const randomBoss = currentBosses[Math.floor(Math.random() * currentBosses.length)];
            
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                wsConnection.send(JSON.stringify({
                    type: 'start_battle',
                    bossId: randomBoss.id,
                    options: {
                        opponents: 3 // 3 AI fighters
                    }
                }));
                
                addLogEntry('system', `üé≤ Starting custom battle with ${randomBoss.name}...`);
            } else {
                alert('Not connected to battle server!');
            }
        }

        function refreshBattleList() {
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                wsConnection.send(JSON.stringify({
                    type: 'request_battle_list'
                }));
            }
        }

        function initializeBattleGrid(gridSize) {
            const gridContainer = document.getElementById('battleGrid');
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${Math.min(20, gridSize.width)}, 1fr)`;
            
            // Create grid cells (show a 20x20 viewport of the larger grid)
            const viewportSize = 20;
            for (let y = 0; y < viewportSize; y++) {
                for (let x = 0; x < viewportSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell walkable';
                    cell.id = `cell-${x}-${y}`;
                    gridContainer.appendChild(cell);
                }
            }
            
            battleEntities.clear();
            console.log('üó∫Ô∏è Battle grid initialized');
        }

        function updateBattleGrid(entities) {
            // Clear existing entities
            document.querySelectorAll('.entity').forEach(e => e.remove());
            
            entities.forEach(entity => {
                updateEntityPosition(entity);
                battleEntities.set(entity.id, entity);
            });
        }

        function updateEntityPosition(entity) {
            // Only show entities within our 20x20 viewport
            if (entity.x >= 20 || entity.y >= 20) return;
            
            const cell = document.getElementById(`cell-${entity.x}-${entity.y}`);
            if (!cell) return;
            
            // Remove existing entity at this position
            const existingEntity = cell.querySelector('.entity');
            if (existingEntity) {
                existingEntity.remove();
            }
            
            // Create entity element
            const entityElement = document.createElement('div');
            entityElement.className = `entity ${entity.type}`;
            entityElement.id = `entity-${entity.id}`;
            entityElement.textContent = entity.name.charAt(0).toUpperCase();
            entityElement.title = `${entity.name} (${entity.health}/${entity.maxHealth} HP)`;
            
            // Add targeting animation if in combat
            if (entity.combatState === 'attacking' || entity.combatState === 'moving') {
                entityElement.classList.add('targeting');
            }
            
            cell.appendChild(entityElement);
        }

        function removeEntityFromGrid(entityId) {
            const entityElement = document.getElementById(`entity-${entityId}`);
            if (entityElement) {
                entityElement.style.animation = 'fadeOut 0.5s ease';
                setTimeout(() => {
                    entityElement.remove();
                }, 500);
            }
            battleEntities.delete(entityId);
        }

        function animateHealthChange(entityId, damage) {
            const entityElement = document.getElementById(`entity-${entityId}`);
            if (entityElement) {
                // Flash red for damage
                entityElement.style.boxShadow = '0 0 10px #e74c3c';
                setTimeout(() => {
                    entityElement.style.boxShadow = '';
                }, 200);
            }
        }

        function updateBattleInfo(battleState) {
            // Update participant list
            const participantsList = document.getElementById('participantsList');
            participantsList.innerHTML = '';
            
            if (battleState.entities && battleState.entities.length > 0) {
                battleState.entities.forEach(entity => {
                    const participant = document.createElement('div');
                    participant.className = 'participant';
                    
                    const healthPercentage = (entity.health / entity.maxHealth) * 100;
                    
                    participant.innerHTML = `
                        <div>
                            <strong>${entity.name}</strong>
                            <small>(${entity.type}, Level ${entity.level})</small>
                        </div>
                        <div class="health-bar">
                            <div class="health-fill" style="width: ${healthPercentage}%"></div>
                        </div>
                    `;
                    
                    participantsList.appendChild(participant);
                });
            } else {
                participantsList.innerHTML = '<p style="color: #888;">No participants</p>';
            }
        }

        function clearBattleGrid() {
            document.querySelectorAll('.entity').forEach(e => e.remove());
            battleEntities.clear();
            
            document.getElementById('participantsList').innerHTML = '<p style="color: #888;">No active battle</p>';
        }

        function addLogEntry(type, message) {
            const logContainer = document.getElementById('battleLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="opacity: 0.7;">[${timestamp}]</span> ${message}`;
            
            logContainer.appendChild(entry);
            
            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Remove old entries (keep last 100)
            const entries = logContainer.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        function updateStats() {
            // Stats are now updated via WebSocket messages
            // This function kept for compatibility
        }
    </script>
</body>
</html>