#!/usr/bin/env node

/**
 * Document Generator Git Integration Wrapper
 * Manages generated MVPs with git workflows
 */

const { spawn, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class DocumentGeneratorGitWrapper {
  constructor() {
    this.projectRoot = __dirname;
    this.generatedDir = path.join(this.projectRoot, 'generated');
    this.templatesDir = path.join(this.projectRoot, 'templates');
  }

  async initialize() {
    console.log('🔧 DOCUMENT GENERATOR GIT WRAPPER');
    console.log('==================================');
    
    await this.ensureDirectories();
    await this.initializeGitRepos();
    
    return this;
  }

  async ensureDirectories() {
    const dirs = [this.generatedDir, this.templatesDir];
    
    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`📁 Created directory: ${dir}`);
      }
    });
  }

  async initializeGitRepos() {
    // Initialize main repo if not already
    if (!fs.existsSync(path.join(this.projectRoot, '.git'))) {
      console.log('🔧 Initializing main git repository...');
      this.execGit('init', this.projectRoot);
      this.execGit('add .', this.projectRoot);
      this.execGit('commit -m "Initial Document Generator setup"', this.projectRoot);
    }

    // Initialize generated projects repo
    const generatedGitPath = path.join(this.generatedDir, '.git');
    if (!fs.existsSync(generatedGitPath)) {
      console.log('🔧 Initializing generated projects repository...');
      this.execGit('init', this.generatedDir);
      
      // Create initial structure
      const readmePath = path.join(this.generatedDir, 'README.md');
      fs.writeFileSync(readmePath, `# Generated MVPs

This repository contains all MVPs generated by Document Generator.

Each subdirectory contains a complete, deployable application:
- Source code
- Docker configuration
- Deployment scripts
- Documentation

Generated on: ${new Date().toISOString()}
`);
      
      this.execGit('add .', this.generatedDir);
      this.execGit('commit -m "Initialize generated projects repository"', this.generatedDir);
    }
  }

  async createMVPRepository(projectName, projectData) {
    console.log(`🚀 Creating MVP repository: ${projectName}`);
    
    const projectPath = path.join(this.generatedDir, projectName);
    
    // Create project directory
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
    }

    // Generate project files
    await this.generateProjectFiles(projectPath, projectData);
    
    // Initialize git repo for the project
    this.execGit('init', projectPath);
    
    // Create initial commit
    this.execGit('add .', projectPath);
    this.execGit(`commit -m "Initial MVP: ${projectName}

Generated from: ${projectData.sourceDocument || 'Document'}
Timestamp: ${new Date().toISOString()}
Features: ${projectData.features?.join(', ') || 'Core functionality'}
Tech Stack: ${projectData.techStack?.join(', ') || 'Full-stack application'}

🎭 Generated by Document Generator with human oversight"`, projectPath);

    // Create development branch
    this.execGit('checkout -b development', projectPath);
    this.execGit('checkout main', projectPath);

    // Add to main generated projects repo
    process.chdir(this.generatedDir);
    this.execGit(`add ${projectName}`, this.generatedDir);
    this.execGit(`commit -m "Add ${projectName} MVP to collection"`, this.generatedDir);

    console.log(`✅ MVP repository created: ${projectPath}`);
    
    return {
      projectPath,
      gitUrl: this.getGitUrl(projectPath),
      branches: ['main', 'development'],
      commitHash: this.getLatestCommitHash(projectPath)
    };
  }

  async generateProjectFiles(projectPath, projectData) {
    // Package.json
    const packageJson = {
      name: projectData.name || 'generated-mvp',
      version: '1.0.0',
      description: projectData.description || 'MVP generated by Document Generator',
      main: 'src/index.js',
      scripts: {
        start: 'node src/index.js',
        dev: 'nodemon src/index.js',
        build: 'npm run build:frontend',
        test: 'jest',
        docker: 'docker-compose up --build',
        deploy: './deploy.sh'
      },
      dependencies: projectData.dependencies || {
        express: '^4.18.2',
        react: '^18.2.0'
      }
    };
    
    fs.writeFileSync(
      path.join(projectPath, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );

    // README.md
    const readme = `# ${projectData.name || 'Generated MVP'}

${projectData.description || 'An MVP generated by Document Generator'}

## 🚀 Quick Start

\`\`\`bash
npm install
npm run dev
\`\`\`

## 📦 Docker Deployment

\`\`\`bash
npm run docker
\`\`\`

## 🏗️ Architecture

${projectData.architecture || 'Full-stack application with modern architecture'}

## 📋 Features

${projectData.features?.map(f => `- ${f}`).join('\n') || '- Core functionality implemented'}

## 🛠️ Tech Stack

${projectData.techStack?.map(t => `- ${t}`).join('\n') || '- Modern web technologies'}

## 📊 Generated Information

- **Source Document**: ${projectData.sourceDocument || 'N/A'}
- **Generated On**: ${new Date().toISOString()}
- **Generator**: Document Generator v1.0.0
- **Human Oversight**: ✅ Approved

## 🚀 Deployment

This MVP is ready for deployment to:
- Vercel/Netlify (Frontend)
- Railway/Heroku (Backend)
- AWS/GCP (Full stack)

See \`deploy.sh\` for automated deployment options.
`;

    fs.writeFileSync(path.join(projectPath, 'README.md'), readme);

    // Docker files
    this.generateDockerFiles(projectPath, projectData);
    
    // Source code structure
    this.generateSourceStructure(projectPath, projectData);
    
    // Deployment scripts
    this.generateDeploymentScripts(projectPath, projectData);
  }

  generateDockerFiles(projectPath, projectData) {
    // Dockerfile
    const dockerfile = `FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
`;

    fs.writeFileSync(path.join(projectPath, 'Dockerfile'), dockerfile);

    // docker-compose.yml
    const dockerCompose = `version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    volumes:
      - ./data:/app/data
    
  database:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ${projectData.name || 'mvp_db'}
      POSTGRES_USER: app
      POSTGRES_PASSWORD: password
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

volumes:
  db_data:
`;

    fs.writeFileSync(path.join(projectPath, 'docker-compose.yml'), dockerCompose);
  }

  generateSourceStructure(projectPath, projectData) {
    const srcPath = path.join(projectPath, 'src');
    fs.mkdirSync(srcPath, { recursive: true });

    // Basic index.js
    const indexJs = `const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static('public'));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date() });
});

// Main routes
app.get('/', (req, res) => {
  res.json({ 
    message: 'Welcome to ${projectData.name || 'Generated MVP'}',
    version: '1.0.0',
    generated: true
  });
});

app.listen(PORT, () => {
  console.log(\`🚀 \${process.env.npm_package_name || 'MVP'} running on port \${PORT}\`);
});
`;

    fs.writeFileSync(path.join(srcPath, 'index.js'), indexJs);

    // Public directory
    const publicPath = path.join(projectPath, 'public');
    fs.mkdirSync(publicPath, { recursive: true });
    
    fs.writeFileSync(path.join(publicPath, 'index.html'), `<!DOCTYPE html>
<html>
<head>
    <title>${projectData.name || 'Generated MVP'}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; text-align: center; border-radius: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎭 ${projectData.name || 'Generated MVP'}</h1>
        <p>${projectData.description || 'Your MVP is ready!'}</p>
    </div>
    <h2>Features</h2>
    <ul>
        ${projectData.features?.map(f => `<li>${f}</li>`).join('') || '<li>Core functionality</li>'}
    </ul>
    <p><em>Generated by Document Generator with human oversight ✅</em></p>
</body>
</html>`);
  }

  generateDeploymentScripts(projectPath, projectData) {
    // deploy.sh
    const deployScript = `#!/bin/bash

echo "🚀 Deploying ${projectData.name || 'MVP'}"

# Build and test
npm install
npm test

# Docker deployment option
if command -v docker &> /dev/null; then
    echo "🐳 Building Docker image..."
    docker build -t ${projectData.name || 'mvp'}:latest .
    echo "✅ Docker image ready"
fi

# Vercel deployment option
if command -v vercel &> /dev/null; then
    echo "🌐 Deploying to Vercel..."
    vercel --prod
fi

# Railway deployment option
if command -v railway &> /dev/null; then
    echo "🚂 Deploying to Railway..."
    railway up
fi

echo "✅ Deployment complete!"
`;

    fs.writeFileSync(path.join(projectPath, 'deploy.sh'), deployScript);
    
    // Make executable
    try {
      fs.chmodSync(path.join(projectPath, 'deploy.sh'), '755');
    } catch (error) {
      // Ignore chmod errors on Windows
    }
  }

  execGit(command, cwd = this.projectRoot) {
    try {
      const result = execSync(`git ${command}`, { 
        cwd,
        stdio: 'pipe'
      }).toString();
      return result.trim();
    } catch (error) {
      console.error(`Git command failed: git ${command}`);
      console.error(error.message);
      return null;
    }
  }

  getGitUrl(projectPath) {
    try {
      const result = this.execGit('remote get-url origin', projectPath);
      return result || `file://${projectPath}`;
    } catch (error) {
      return `file://${projectPath}`;
    }
  }

  getLatestCommitHash(projectPath) {
    try {
      return this.execGit('rev-parse HEAD', projectPath);
    } catch (error) {
      return null;
    }
  }

  async setupRemoteRepository(projectName, remoteUrl) {
    const projectPath = path.join(this.generatedDir, projectName);
    
    if (!fs.existsSync(projectPath)) {
      throw new Error(`Project ${projectName} does not exist`);
    }

    console.log(`🔗 Setting up remote repository for ${projectName}`);
    
    this.execGit(`remote add origin ${remoteUrl}`, projectPath);
    this.execGit('push -u origin main', projectPath);
    this.execGit('push origin development', projectPath);
    
    console.log(`✅ Remote repository configured: ${remoteUrl}`);
    
    return {
      projectName,
      remoteUrl,
      branches: ['main', 'development']
    };
  }

  async listProjects() {
    const projects = [];
    
    if (fs.existsSync(this.generatedDir)) {
      const entries = fs.readdirSync(this.generatedDir);
      
      for (const entry of entries) {
        const projectPath = path.join(this.generatedDir, entry);
        const gitPath = path.join(projectPath, '.git');
        
        if (fs.statSync(projectPath).isDirectory() && fs.existsSync(gitPath)) {
          const packageJsonPath = path.join(projectPath, 'package.json');
          let projectInfo = { name: entry, path: projectPath };
          
          if (fs.existsSync(packageJsonPath)) {
            try {
              const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
              projectInfo = {
                ...projectInfo,
                description: packageJson.description,
                version: packageJson.version
              };
            } catch (error) {
              // Ignore JSON parse errors
            }
          }
          
          projectInfo.commitHash = this.getLatestCommitHash(projectPath);
          projectInfo.gitUrl = this.getGitUrl(projectPath);
          
          projects.push(projectInfo);
        }
      }
    }
    
    return projects;
  }

  async showStatus() {
    console.log('\n📊 DOCUMENT GENERATOR GIT STATUS');
    console.log('=================================');
    
    const projects = await this.listProjects();
    
    if (projects.length === 0) {
      console.log('No generated projects found.');
      return;
    }
    
    console.log(`Found ${projects.length} generated projects:\n`);
    
    projects.forEach((project, index) => {
      console.log(`${index + 1}. ${project.name}`);
      console.log(`   Description: ${project.description || 'N/A'}`);
      console.log(`   Path: ${project.path}`);
      console.log(`   Git URL: ${project.gitUrl}`);
      console.log(`   Latest Commit: ${project.commitHash?.substring(0, 8) || 'N/A'}`);
      console.log('');
    });
  }
}

// CLI interface
async function main() {
  const gitWrapper = new DocumentGeneratorGitWrapper();
  await gitWrapper.initialize();
  
  const args = process.argv.slice(2);
  const command = args[0];
  
  switch (command) {
    case 'status':
      await gitWrapper.showStatus();
      break;
      
    case 'create':
      const projectName = args[1];
      if (!projectName) {
        console.log('Usage: git-wrapper.js create <project-name>');
        process.exit(1);
      }
      
      const mockProjectData = {
        name: projectName,
        description: 'Generated MVP from Document Generator',
        features: ['User authentication', 'Dashboard', 'API endpoints'],
        techStack: ['Node.js', 'React', 'PostgreSQL'],
        sourceDocument: 'Manual creation'
      };
      
      await gitWrapper.createMVPRepository(projectName, mockProjectData);
      break;
      
    case 'remote':
      const [, projectName2, remoteUrl] = args;
      if (!projectName2 || !remoteUrl) {
        console.log('Usage: git-wrapper.js remote <project-name> <remote-url>');
        process.exit(1);
      }
      
      await gitWrapper.setupRemoteRepository(projectName2, remoteUrl);
      break;
      
    default:
      console.log('Document Generator Git Wrapper');
      console.log('Usage:');
      console.log('  git-wrapper.js status                    - Show all generated projects');
      console.log('  git-wrapper.js create <name>             - Create new MVP project');
      console.log('  git-wrapper.js remote <name> <url>       - Setup remote repository');
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = DocumentGeneratorGitWrapper;